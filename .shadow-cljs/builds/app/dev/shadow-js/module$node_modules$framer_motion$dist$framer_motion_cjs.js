["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/framer-motion/dist/framer-motion.cjs.js"],"~:js","shadow$provide.module$node_modules$framer_motion$dist$framer_motion_cjs=function(global,require,module,exports){function _interopDefaultLegacy(e){return e&&\"object\"===typeof e&&\"default\"in e?e:{\"default\":e}}function loadFeatures(features){for(var key in features){var Component=features[key];null!==Component&&(featureDefinitions[key].Component=Component)}}function useConstant(init){var ref=React.useRef(null);null===ref.current&&(ref.current=init());return ref.current}function usePresence(){var context=\nReact.useContext(PresenceContext);if(null===context)return[!0,null];var isPresent=context.isPresent,onExitComplete=context.onExitComplete,register=context.register,id=useConstant(incrementId);React.useEffect(function(){return register(id)},[]);return!isPresent&&onExitComplete?[!1,function(){return null===onExitComplete||void 0===onExitComplete?void 0:onExitComplete(id)}]:[!0]}function useLayoutId(_a){_a=_a.layoutId;var layoutGroupId=React.useContext(LayoutGroupContext);return layoutGroupId&&void 0!==\n_a?layoutGroupId+\"-\"+_a:_a}function useVisualElement(Component,visualState,props,createVisualElement){var config=React.useContext(MotionConfigContext),lazyContext=React.useContext(LazyContext),parent=React.useContext(MotionContext).visualElement,presenceContext=React.useContext(PresenceContext),layoutId=useLayoutId(props),visualElementRef=React.useRef(void 0);createVisualElement||(createVisualElement=lazyContext.renderer);!visualElementRef.current&&createVisualElement&&(visualElementRef.current=createVisualElement(Component,\n{visualState:visualState,parent:parent,props:tslib.__assign(tslib.__assign({},props),{layoutId:layoutId}),presenceId:null===presenceContext||void 0===presenceContext?void 0:presenceContext.id,blockInitialAnimation:!1===(null===presenceContext||void 0===presenceContext?void 0:presenceContext.initial)}));var visualElement=visualElementRef.current;useIsomorphicLayoutEffect(function(){visualElement&&(visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({},config),props),{layoutId:layoutId})),\nvisualElement.isPresent=null===presenceContext?!0:presenceContext.isPresent,visualElement.isPresenceRoot=!parent||parent.presenceId!==(null===presenceContext||void 0===presenceContext?void 0:presenceContext.id),visualElement.syncRender())});React.useEffect(function(){var _a;visualElement&&(null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.animateChanges())});useIsomorphicLayoutEffect(function(){return function(){return null===visualElement||void 0===visualElement?void 0:visualElement.notifyUnmount()}},\n[]);return visualElement}function isRefObject(ref){return\"object\"===typeof ref&&Object.prototype.hasOwnProperty.call(ref,\"current\")}function useMotionRef(visualState,visualElement,externalRef){return React.useCallback(function(instance){var _a;instance&&(null===(_a=visualState.mount)||void 0===_a?void 0:_a.call(visualState,instance));visualElement&&(instance?visualElement.mount(instance):visualElement.unmount());externalRef&&(\"function\"===typeof externalRef?externalRef(instance):isRefObject(externalRef)&&\n(externalRef.current=instance))},[visualElement])}function isVariantLabel(v){return\"string\"===typeof v||Array.isArray(v)}function getCurrent(visualElement){var current={};visualElement.forEachValue(function(value,key){return current[key]=value.get()});return current}function getVelocity$1(visualElement){var velocity={};visualElement.forEachValue(function(value,key){return velocity[key]=value.getVelocity()});return velocity}function resolveVariantFromProps(props,definition,custom,currentValues,currentVelocity){var _a;\nvoid 0===currentValues&&(currentValues={});void 0===currentVelocity&&(currentVelocity={});\"string\"===typeof definition&&(definition=null===(_a=props.variants)||void 0===_a?void 0:_a[definition]);return\"function\"===typeof definition?definition(null!==custom&&void 0!==custom?custom:props.custom,currentValues,currentVelocity):definition}function resolveVariant(visualElement,definition,custom){var props=visualElement.getProps();return resolveVariantFromProps(props,definition,null!==custom&&void 0!==custom?\ncustom:props.custom,getCurrent(visualElement),getVelocity$1(visualElement))}function checkIfControllingVariants(props){var _a;return\"function\"===typeof(null===(_a=props.animate)||void 0===_a?void 0:_a.start)||isVariantLabel(props.initial)||isVariantLabel(props.animate)||isVariantLabel(props.whileHover)||isVariantLabel(props.whileDrag)||isVariantLabel(props.whileTap)||isVariantLabel(props.whileFocus)||isVariantLabel(props.exit)}function checkIfVariantNode(props){return!(!checkIfControllingVariants(props)&&\n!props.variants)}function getCurrentTreeVariants(props,context){return checkIfControllingVariants(props)?(context=props.initial,props=props.animate,{initial:!1===context||isVariantLabel(context)?context:void 0,animate:isVariantLabel(props)?props:void 0}):!1!==props.inherit?context:{}}function useCreateMotionContext(props,isStatic){props=getCurrentTreeVariants(props,React.useContext(MotionContext));var initial=props.initial,animate=props.animate;return React.useMemo(function(){return{initial:initial,\nanimate:animate}},isStatic?[variantLabelsAsDependency(initial),variantLabelsAsDependency(animate)]:[])}function variantLabelsAsDependency(prop){return Array.isArray(prop)?prop.join(\" \"):prop}function createMotionComponent(_a$jscomp$0){var preloadedFeatures=_a$jscomp$0.preloadedFeatures,createVisualElement=_a$jscomp$0.createVisualElement,useRender=_a$jscomp$0.useRender,useVisualState=_a$jscomp$0.useVisualState,Component=_a$jscomp$0.Component;preloadedFeatures&&loadFeatures(preloadedFeatures);return React.forwardRef(function(props,\nexternalRef){var isStatic=React.useContext(MotionConfigContext).isStatic,features=null,context=useCreateMotionContext(props,isStatic),visualState=useVisualState(props,isStatic);if(!isStatic&&isBrowser){context.visualElement=useVisualElement(Component,visualState,props,createVisualElement);features=context.visualElement;var features$jscomp$0=[],lazyContext=React.useContext(LazyContext);if(features){preloadedFeatures&&lazyContext.strict&&heyListen.invariant(!1,\"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\nfor(lazyContext=0;lazyContext<numFeatures;lazyContext++){var name_1=featureNames[lazyContext],_a=featureDefinitions[name_1],isEnabled=_a.isEnabled;_a=_a.Component;isEnabled(props)&&_a&&features$jscomp$0.push(React__namespace.createElement(_a,tslib.__assign({key:name_1},props,{visualElement:features})))}features=features$jscomp$0}else features=null}return React__namespace.createElement(React__namespace.Fragment,null,React__namespace.createElement(MotionContext.Provider,{value:context},useRender(Component,\nprops,useMotionRef(visualState,context.visualElement,externalRef),visualState,isStatic)),features)})}function createMotionProxy(createConfig){function custom(Component,customMotionComponentConfig){void 0===customMotionComponentConfig&&(customMotionComponentConfig={});return createMotionComponent(createConfig(Component,customMotionComponentConfig))}var componentCache=new Map;return new Proxy(custom,{get:function(_target,key){componentCache.has(key)||componentCache.set(key,custom(key));return componentCache.get(key)}})}\nfunction isSVGComponent(Component){return\"string\"===typeof Component&&!Component.includes(\"-\")&&(-1<lowercaseSVGElements.indexOf(Component)||/[A-Z]/.test(Component))?!0:!1}function addScaleCorrection(correctors){for(var key in correctors)valueScaleCorrection[key]=correctors[key]}function sortTransformProps(a,b){return transformProps.indexOf(a)-transformProps.indexOf(b)}function isForcedMotionValue(key,_a){var layout=_a.layout;_a=_a.layoutId;return transformPropSet.has(key)||transformOriginProps.has(key)||\n(layout||void 0!==_a)&&(!!valueScaleCorrection[key]||\"opacity\"===key)}function buildHTMLStyles(state,latestValues,projection,layoutState,options,transformTemplate,buildProjectionTransform,buildProjectionTransformOrigin){var _a,style=state.style,vars=state.vars,transform=state.transform,transformKeys=state.transformKeys,transformOrigin=state.transformOrigin;transformKeys.length=0;var hasTransform=!1,hasTransformOrigin=!1,transformIsNone=!0,key;for(key in latestValues){var value=latestValues[key];if(key.startsWith(\"--\"))vars[key]=\nvalue;else{var valueType=numberValueTypes[key];var valueAsType=value;valueAsType=valueType&&\"number\"===typeof valueAsType?valueType.transform(valueAsType):valueAsType;if(transformPropSet.has(key))hasTransform=!0,transform[key]=valueAsType,transformKeys.push(key),transformIsNone&&value!==(null!==(_a=valueType.default)&&void 0!==_a?_a:0)&&(transformIsNone=!1);else if(transformOriginProps.has(key))transformOrigin[key]=valueAsType,hasTransformOrigin=!0;else if((null===projection||void 0===projection?\n0:projection.isHydrated)&&(null===layoutState||void 0===layoutState?0:layoutState.isHydrated)&&valueScaleCorrection[key])if(value=valueScaleCorrection[key].process(value,layoutState,projection),valueType=valueScaleCorrection[key].applyTo){valueAsType=valueType.length;for(var i=0;i<valueAsType;i++)style[valueType[i]]=value}else style[key]=value;else style[key]=valueAsType}}if(layoutState&&projection&&buildProjectionTransform&&buildProjectionTransformOrigin)style.transform=buildProjectionTransform(layoutState.deltaFinal,\nlayoutState.treeScale,hasTransform?transform:void 0),transformTemplate&&(style.transform=transformTemplate(transform,style.transform)),style.transformOrigin=buildProjectionTransformOrigin(layoutState);else{if(hasTransform){latestValues=transformIsNone;projection=state.transform;state=state.transformKeys;layoutState=options.enableHardwareAcceleration;layoutState=void 0===layoutState?!0:layoutState;options=options.allowTransformNone;options=void 0===options?!0:options;buildProjectionTransform=\"\";state.sort(sortTransformProps);\nbuildProjectionTransformOrigin=!1;_a=state.length;for(vars=0;vars<_a;vars++)transform=state[vars],buildProjectionTransform+=(translateAlias[transform]||transform)+\"(\"+projection[transform]+\") \",\"z\"===transform&&(buildProjectionTransformOrigin=!0);buildProjectionTransform=!buildProjectionTransformOrigin&&layoutState?buildProjectionTransform+\"translateZ(0)\":buildProjectionTransform.trim();transformTemplate?buildProjectionTransform=transformTemplate(projection,latestValues?\"\":buildProjectionTransform):\noptions&&latestValues&&(buildProjectionTransform=\"none\");style.transform=buildProjectionTransform}hasTransformOrigin&&(transformTemplate=transformOrigin.originX,hasTransformOrigin=transformOrigin.originY,transformOrigin=transformOrigin.originZ,style.transformOrigin=(void 0===transformTemplate?\"50%\":transformTemplate)+\" \"+(void 0===hasTransformOrigin?\"50%\":hasTransformOrigin)+\" \"+(void 0===transformOrigin?0:transformOrigin))}}function copyRawValuesOnly(target,source,props){for(var key in source)isMotionValue(source[key])||\nisForcedMotionValue(key,props)||(target[key]=source[key])}function useInitialMotionValues(_a,visualState,isStatic){var transformTemplate=_a.transformTemplate;return React.useMemo(function(){var state=createHtmlRenderState();buildHTMLStyles(state,visualState,void 0,void 0,{enableHardwareAcceleration:!isStatic},transformTemplate);var style=state.style;return tslib.__assign(tslib.__assign({},state.vars),style)},[visualState])}function useHTMLProps(props,visualState,isStatic){var htmlProps={},style={};\ncopyRawValuesOnly(style,props.style||{},props);Object.assign(style,useInitialMotionValues(props,visualState,isStatic));props.transformValues&&(style=props.transformValues(style));visualState=style;props.drag&&(htmlProps.draggable=!1,visualState.userSelect=visualState.WebkitUserSelect=visualState.WebkitTouchCallout=\"none\",visualState.touchAction=!0===props.drag?\"none\":\"pan-\"+(\"x\"===props.drag?\"y\":\"x\"));htmlProps.style=visualState;return htmlProps}function isValidMotionProp(key){return validMotionProps.has(key)}\nfunction calcOrigin$1(origin,offset,size){return\"string\"===typeof origin?origin:styleValueTypes.px.transform(offset+size*origin)}function buildSVGAttrs(state,_a,projection,layoutState,options,transformTemplate,buildProjectionTransform,buildProjectionTransformOrigin){var attrX=_a.attrX,attrY=_a.attrY,originX=_a.originX,originY=_a.originY,pathLength=_a.pathLength,_b=_a.pathSpacing;_b=void 0===_b?1:_b;var _c=_a.pathOffset;_c=void 0===_c?0:_c;_a=tslib.__rest(_a,\"attrX attrY originX originY pathLength pathSpacing pathOffset\".split(\" \"));\nbuildHTMLStyles(state,_a,projection,layoutState,options,transformTemplate,buildProjectionTransform,buildProjectionTransformOrigin);state.attrs=state.style;state.style={};projection=state.attrs;layoutState=state.style;options=state.dimensions;state=state.totalPathLength;projection.transform&&(options&&(layoutState.transform=projection.transform),delete projection.transform);options&&(void 0!==originX||void 0!==originY||layoutState.transform)&&(originY=void 0!==originY?originY:.5,originX=calcOrigin$1(void 0!==\noriginX?originX:.5,options.x,options.width),originY=calcOrigin$1(originY,options.y,options.height),layoutState.transformOrigin=originX+\" \"+originY);void 0!==attrX&&(projection.x=attrX);void 0!==attrY&&(projection.y=attrY);void 0!==state&&void 0!==pathLength&&(attrX=_b,_b=_c,attrY=!1,void 0===attrX&&(attrX=1),void 0===_b&&(_b=0),void 0===attrY&&(attrY=!0),attrY=attrY?dashKeys:camelKeys,projection[attrY.offset]=styleValueTypes.px.transform(-_b*state),pathLength=styleValueTypes.px.transform(pathLength*\nstate),attrX=styleValueTypes.px.transform(attrX*state),projection[attrY.array]=pathLength+\" \"+attrX)}function useSVGProps(props,visualState){var visualProps=React.useMemo(function(){var state=createSvgRenderState();buildSVGAttrs(state,visualState,void 0,void 0,{enableHardwareAcceleration:!1},props.transformTemplate);return tslib.__assign(tslib.__assign({},state.attrs),{style:tslib.__assign({},state.style)})},[visualState]);if(props.style){var rawStyles={};copyRawValuesOnly(rawStyles,props.style,props);\nvisualProps.style=tslib.__assign(tslib.__assign({},rawStyles),visualProps.style)}return visualProps}function createUseRender(forwardMotionProps$jscomp$0){void 0===forwardMotionProps$jscomp$0&&(forwardMotionProps$jscomp$0=!1);return function(Component,props,ref,_a,isStatic){_a=_a.latestValues;isStatic=(isSVGComponent(Component)?useSVGProps:useHTMLProps)(props,_a,isStatic);_a=\"string\"===typeof Component;var forwardMotionProps=forwardMotionProps$jscomp$0,filteredProps={},key;for(key in props)if(shouldForward(key)||\n!0===forwardMotionProps&&isValidMotionProp(key)||!_a&&!isValidMotionProp(key))filteredProps[key]=props[key];props=tslib.__assign(tslib.__assign(tslib.__assign({},filteredProps),isStatic),{ref:ref});return React.createElement(Component,props)}}function renderHTML(element,_a){var vars=_a.vars;Object.assign(element.style,_a.style);for(var key in vars)element.style.setProperty(key,vars[key])}function renderSVG(element,renderState){renderHTML(element,renderState);for(var key in renderState.attrs)element.setAttribute(camelCaseAttributes.has(key)?\nkey:key.replace(CAMEL_CASE_PATTERN,\"$1-$2\").toLowerCase(),renderState.attrs[key])}function scrapeMotionValuesFromProps$1(props){var style=props.style,newValues={},key;for(key in style)if(isMotionValue(style[key])||isForcedMotionValue(key,props))newValues[key]=style[key];return newValues}function scrapeMotionValuesFromProps(props){var newValues=scrapeMotionValuesFromProps$1(props),key;for(key in props)if(isMotionValue(props[key])){var targetKey=\"x\"===key||\"y\"===key?\"attr\"+key.toUpperCase():key;newValues[targetKey]=\nprops[key]}return newValues}function isAnimationControls(v){return\"object\"===typeof v&&\"function\"===typeof v.start}function resolveMotionValue(value){return(value=isMotionValue(value)?value.get():value)&&\"object\"===typeof value&&value.mix&&value.toValue?value.toValue():value}function makeState(_a,props,context,presenceContext){var createRenderState=_a.createRenderState,onMount=_a.onMount,state={latestValues:makeLatestValues(props,context,presenceContext,_a.scrapeMotionValuesFromProps),renderState:createRenderState()};\nonMount&&(state.mount=function(instance){return onMount(props,instance,state)});return state}function makeLatestValues(props,context,presenceContext,scrapeMotionValues){var values={};presenceContext=!1===(null===presenceContext||void 0===presenceContext?void 0:presenceContext.initial);scrapeMotionValues=scrapeMotionValues(props);for(var key$jscomp$0 in scrapeMotionValues)values[key$jscomp$0]=resolveMotionValue(scrapeMotionValues[key$jscomp$0]);key$jscomp$0=props.initial;scrapeMotionValues=props.animate;\nvar isControllingVariants=checkIfControllingVariants(props),isVariantNode=checkIfVariantNode(props);context&&isVariantNode&&!isControllingVariants&&!1!==props.inherit&&(null!==key$jscomp$0&&void 0!==key$jscomp$0?key$jscomp$0:key$jscomp$0=context.initial,null!==scrapeMotionValues&&void 0!==scrapeMotionValues?scrapeMotionValues:scrapeMotionValues=context.animate);(context=presenceContext||!1===key$jscomp$0?scrapeMotionValues:key$jscomp$0)&&\"boolean\"!==typeof context&&!isAnimationControls(context)&&\n(Array.isArray(context)?context:[context]).forEach(function(definition){var resolved=resolveVariantFromProps(props,definition);if(resolved){definition=resolved.transitionEnd;resolved.transition;resolved=tslib.__rest(resolved,[\"transitionEnd\",\"transition\"]);for(var key in resolved)values[key]=resolved[key];for(key in definition)values[key]=definition[key]}});return values}function createDomMotionConfig(Component,_a,preloadedFeatures,createVisualElement){_a=_a.forwardMotionProps;_a=void 0===_a?!1:_a;\nvar baseConfig=isSVGComponent(Component)?svgMotionConfig:htmlMotionConfig;return tslib.__assign(tslib.__assign({},baseConfig),{preloadedFeatures:preloadedFeatures,useRender:createUseRender(_a),createVisualElement:createVisualElement,Component:Component})}function addDomEvent(target,eventName,handler,options){target.addEventListener(eventName,handler,options);return function(){return target.removeEventListener(eventName,handler,options)}}function useDomEvent(ref,eventName,handler,options){React.useEffect(function(){var element=\nref.current;if(handler&&element)return addDomEvent(element,eventName,handler,options)},[ref,eventName,handler,options])}function isMouseEvent(event){return\"undefined\"!==typeof PointerEvent&&event instanceof PointerEvent?\"mouse\"===event.pointerType:event instanceof MouseEvent}function filterPrimaryPointer(eventHandler){return function(event){var isMouseEvent=event instanceof MouseEvent;(!isMouseEvent||isMouseEvent&&0===event.button)&&eventHandler(event)}}function extractEventInfo(event,pointType){void 0===\npointType&&(pointType=\"page\");event.touches?(void 0===pointType&&(pointType=\"page\"),event=event.touches[0]||event.changedTouches[0]||defaultPagePoint,event={x:event[pointType+\"X\"],y:event[pointType+\"Y\"]}):(void 0===pointType&&(pointType=\"page\"),event={x:event[pointType+\"X\"],y:event[pointType+\"Y\"]});return{point:event}}function getPointerEventName(name){if(!isBrowser||null!==window.onpointerdown){if(isBrowser&&null===window.ontouchstart)return touchEventNames[name];if(isBrowser&&null===window.onmousedown)return mouseEventNames[name]}return name}\nfunction addPointerEvent(target,eventName,handler,options){return addDomEvent(target,getPointerEventName(eventName),wrapHandler(handler,\"pointerdown\"===eventName),options)}function usePointerEvent(ref,eventName,handler,options){return useDomEvent(ref,getPointerEventName(eventName),handler&&wrapHandler(handler,\"pointerdown\"===eventName),options)}function createLock(name){var lock=null;return function(){return null===lock?(lock=name,function(){lock=null}):!1}}function getGlobalLock(drag){var lock=!1;\nif(\"y\"===drag)lock=globalVerticalLock();else if(\"x\"===drag)lock=globalHorizontalLock();else{var openHorizontal_1=globalHorizontalLock(),openVertical_1=globalVerticalLock();openHorizontal_1&&openVertical_1?lock=function(){openHorizontal_1();openVertical_1()}:(openHorizontal_1&&openHorizontal_1(),openVertical_1&&openVertical_1())}return lock}function isDragActive(){var openGestureLock=getGlobalLock(!0);if(!openGestureLock)return!0;openGestureLock();return!1}function createHoverEvent(visualElement,isActive,\ncallback){return function(event,info){var _a;isMouseEvent(event)&&!isDragActive()&&(null===callback||void 0===callback?void 0:callback(event,info),null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.setActive(AnimationType.Hover,isActive))}}function useUnmountEffect(callback){return React.useEffect(function(){return function(){return callback()}},[])}function shallowCompare(next,prev){if(!Array.isArray(prev))return!1;var prevLength=prev.length;if(prevLength!==next.length)return!1;for(var i=\n0;i<prevLength;i++)if(prev[i]!==next[i])return!1;return!0}function getAnimatableNone(key,value){var _a;key=defaultValueTypes[key];key!==styleValueTypes.filter&&(key=styleValueTypes.complex);return null===(_a=key.getAnimatableNone)||void 0===_a?void 0:_a.call(key,value)}function convertTransitionToAnimationOptions(_a){var ease=_a.ease,times=_a.times,yoyo=_a.yoyo,flip=_a.flip,loop=_a.loop;_a=tslib.__rest(_a,[\"ease\",\"times\",\"yoyo\",\"flip\",\"loop\"]);var options=tslib.__assign({},_a);times&&(options.offset=\ntimes);_a.duration&&(options.duration=1E3*_a.duration);_a.repeatDelay&&(options.repeatDelay=1E3*_a.repeatDelay);ease&&(times=Array.isArray(ease)&&\"number\"!==typeof ease[0],options.ease=times?ease.map(easingDefinitionToFunction):easingDefinitionToFunction(ease));\"tween\"===_a.type&&(options.type=\"keyframes\");if(yoyo||loop||flip)heyListen.warning(!legacyRepeatWarning,\"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\"),legacyRepeatWarning=!0,yoyo?options.repeatType=\n\"reverse\":loop?options.repeatType=\"loop\":flip&&(options.repeatType=\"mirror\"),options.repeat=loop||yoyo||flip||_a.repeat;\"spring\"!==_a.type&&(options.type=\"keyframes\");return options}function getDelayFromTransition(transition,key){var _a;return null!==(_a=(getValueTransition(transition,key)||{}).delay)&&void 0!==_a?_a:0}function getPopmotionAnimationOptions(transition,options,key){var _a;Array.isArray(options.to)&&(null!==(_a=transition.duration)&&void 0!==_a?_a:transition.duration=.8);Array.isArray(options.to)&&\nnull===options.to[0]&&(options.to=tslib.__spreadArray([],tslib.__read(options.to)),options.to[0]=options.from);_a=transition;_a.when;_a.delay;_a.delayChildren;_a.staggerChildren;_a.staggerDirection;_a.repeat;_a.repeatType;_a.repeatDelay;_a.from;_a=tslib.__rest(_a,\"when delay delayChildren staggerChildren staggerDirection repeat repeatType repeatDelay from\".split(\" \"));Object.keys(_a).length||(transition=tslib.__assign(tslib.__assign({},transition),getDefaultTransition(key,options.to)));return tslib.__assign(tslib.__assign({},\noptions),convertTransitionToAnimationOptions(transition))}function getAnimation(key,value,target,transition,onComplete){function start(){var options={from:origin,to:target,velocity:value.getVelocity(),onComplete:onComplete,onUpdate:function(v){return value.set(v)}};return\"inertia\"===valueTransition.type||\"decay\"===valueTransition.type?popmotion.inertia(tslib.__assign(tslib.__assign({},options),valueTransition)):popmotion.animate(tslib.__assign(tslib.__assign({},getPopmotionAnimationOptions(valueTransition,\noptions,key)),{onUpdate:function(v){var _a;options.onUpdate(v);null===(_a=valueTransition.onUpdate)||void 0===_a?void 0:_a.call(valueTransition,v)},onComplete:function(){var _a;options.onComplete();null===(_a=valueTransition.onComplete)||void 0===_a?void 0:_a.call(valueTransition)}}))}function set(){var _a;value.set(target);onComplete();null===(_a=null===valueTransition||void 0===valueTransition?void 0:valueTransition.onComplete)||void 0===_a?void 0:_a.call(valueTransition);return{stop:function(){}}}\nvar _a$jscomp$0,valueTransition=getValueTransition(transition,key),origin=null!==(_a$jscomp$0=valueTransition.from)&&void 0!==_a$jscomp$0?_a$jscomp$0:value.get();transition=isAnimatable(key,target);\"none\"===origin&&transition&&\"string\"===typeof target?origin=getAnimatableNone(key,target):isZero(origin)&&\"string\"===typeof target?origin=\"number\"===typeof target?0:getAnimatableNone(\"\",target):!Array.isArray(target)&&isZero(target)&&\"string\"===typeof origin&&(target=\"number\"===typeof origin?0:getAnimatableNone(\"\",\norigin));_a$jscomp$0=isAnimatable(key,origin);heyListen.warning(_a$jscomp$0===transition,\"You are trying to animate \"+key+' from \"'+origin+'\" to \"'+target+'\". '+origin+\" is not an animatable value - to enable this animation set \"+origin+\" to a value animatable to \"+target+\" via the `style` property.\");return _a$jscomp$0&&transition&&!1!==valueTransition.type?start:set}function isZero(value){return 0===value||\"string\"===typeof value&&0===parseFloat(value)&&-1===value.indexOf(\" \")}function getValueTransition(transition,\nkey){return transition[key]||transition[\"default\"]||transition}function startAnimation(key,value,target,transition){void 0===transition&&(transition={});return value.start(function(onComplete){var delayTimer,controls,animation=getAnimation(key,value,target,transition,onComplete);onComplete=getDelayFromTransition(transition,key);var start=function(){return controls=animation()};onComplete?delayTimer=setTimeout(start,1E3*onComplete):start();return function(){clearTimeout(delayTimer);null===controls||\nvoid 0===controls?void 0:controls.stop()}})}function addUniqueItem(arr,item){-1===arr.indexOf(item)&&arr.push(item)}function motionValue(init){return new MotionValue(init)}function setTarget(visualElement,definition){definition=(definition=resolveVariant(visualElement,definition))?visualElement.makeTargetAnimatable(definition,!1):{};var _b=definition.transitionEnd;_b=void 0===_b?{}:_b;definition.transition;definition=tslib.__rest(definition,[\"transitionEnd\",\"transition\"]);definition=tslib.__assign(tslib.__assign({},\ndefinition),_b);for(var key in definition){_b=definition[key];var value=Array.isArray(_b)?_b[_b.length-1]||0:_b;_b=visualElement;var key$jscomp$0=key;_b.hasValue(key$jscomp$0)?_b.getValue(key$jscomp$0).set(value):_b.addValue(key$jscomp$0,motionValue(value))}}function setVariants(visualElement,variantLabels){tslib.__spreadArray([],tslib.__read(variantLabels)).reverse().forEach(function(key){var _a;(key=visualElement.getVariant(key))&&setTarget(visualElement,key);null===(_a=visualElement.variantChildren)||\nvoid 0===_a?void 0:_a.forEach(function(child){setVariants(child,variantLabels)})})}function checkTargetForNewValues(visualElement,target,origin){var _a,_b,_c,_d,newValueKeys=Object.keys(target).filter(function(key){return!visualElement.hasValue(key)}),numNewValues=newValueKeys.length;if(numNewValues)for(var i=0;i<numNewValues;i++){var key$jscomp$0=newValueKeys[i],targetValue=target[key$jscomp$0],value=null;Array.isArray(targetValue)&&(value=targetValue[0]);null===value&&(value=null!==(_b=null!==(_a=\norigin[key$jscomp$0])&&void 0!==_a?_a:visualElement.readValue(key$jscomp$0))&&void 0!==_b?_b:target[key$jscomp$0]);void 0!==value&&null!==value&&(\"string\"===typeof value&&/^\\-?\\d*\\.?\\d+$/.test(value)?value=parseFloat(value):!valueTypes.find(testValueType(value))&&styleValueTypes.complex.test(targetValue)&&(value=getAnimatableNone(key$jscomp$0,targetValue)),visualElement.addValue(key$jscomp$0,motionValue(value)),null!==(_c=(_d=origin)[key$jscomp$0])&&void 0!==_c?_c:_d[key$jscomp$0]=value,visualElement.setBaseTarget(key$jscomp$0,\nvalue))}}function getOrigin(target,transition,visualElement){var _a,_b,origin={},key;for(key in target){target=key;var JSCompiler_inline_result=transition?(transition[key]||transition[\"default\"]||transition).from:void 0;origin[target]=null!==(_a=JSCompiler_inline_result)&&void 0!==_a?_a:null===(_b=visualElement.getValue(key))||void 0===_b?void 0:_b.get()}return origin}function animateVisualElement(visualElement,definition,options){void 0===options&&(options={});visualElement.notifyAnimationStart();\nif(Array.isArray(definition)){var animation=definition.map(function(variant){return animateVariant(visualElement,variant,options)});animation=Promise.all(animation)}else\"string\"===typeof definition?animation=animateVariant(visualElement,definition,options):(animation=\"function\"===typeof definition?resolveVariant(visualElement,definition,options.custom):definition,animation=animateTarget(visualElement,animation,options));return animation.then(function(){return visualElement.notifyAnimationComplete(definition)})}\nfunction animateVariant(visualElement,variant,options){var _a$jscomp$0;void 0===options&&(options={});var resolved=resolveVariant(visualElement,variant,options.custom),_b=(resolved||{}).transition,transition=void 0===_b?visualElement.getDefaultTransition()||{}:_b;options.transitionOverride&&(transition=options.transitionOverride);_b=resolved?function(){return animateTarget(visualElement,resolved,options)}:function(){return Promise.resolve()};var getChildAnimations=(null===(_a$jscomp$0=visualElement.variantChildren)||\nvoid 0===_a$jscomp$0?0:_a$jscomp$0.size)?function(forwardDelay){void 0===forwardDelay&&(forwardDelay=0);var _a=transition.delayChildren;return animateChildren(visualElement,variant,(void 0===_a?0:_a)+forwardDelay,transition.staggerChildren,transition.staggerDirection,options)}:function(){return Promise.resolve()};return(_a$jscomp$0=transition.when)?(_a$jscomp$0=tslib.__read(\"beforeChildren\"===_a$jscomp$0?[_b,getChildAnimations]:[getChildAnimations,_b],2),_b=_a$jscomp$0[1],(0,_a$jscomp$0[0])().then(_b)):\nPromise.all([_b(),getChildAnimations(options.delay)])}function animateTarget(visualElement,definition,_a){var _b,_c=void 0===_a?{}:_a;_a=_c.delay;_a=void 0===_a?0:_a;var transitionOverride=_c.transitionOverride,type=_c.type;_c=visualElement.makeTargetAnimatable(definition);definition=_c.transition;definition=void 0===definition?visualElement.getDefaultTransition():definition;var transitionEnd=_c.transitionEnd;_c=tslib.__rest(_c,[\"transition\",\"transitionEnd\"]);transitionOverride&&(definition=transitionOverride);\ntransitionOverride=[];type=type&&(null===(_b=visualElement.animationState)||void 0===_b?void 0:_b.getState()[type]);for(var key in _c){_b=visualElement.getValue(key);var valueTarget=_c[key];!_b||void 0===valueTarget||type&&shouldBlockAnimation(type,key)||(_b=startAnimation(key,_b,valueTarget,tslib.__assign({delay:_a},definition)),transitionOverride.push(_b))}return Promise.all(transitionOverride).then(function(){transitionEnd&&setTarget(visualElement,transitionEnd)})}function animateChildren(visualElement,\nvariant,delayChildren,staggerChildren,staggerDirection,options){void 0===delayChildren&&(delayChildren=0);void 0===staggerChildren&&(staggerChildren=0);void 0===staggerDirection&&(staggerDirection=1);var animations=[],maxStaggerDuration=(visualElement.variantChildren.size-1)*staggerChildren,generateStaggerDuration=1===staggerDirection?function(i){void 0===i&&(i=0);return i*staggerChildren}:function(i){void 0===i&&(i=0);return maxStaggerDuration-i*staggerChildren};Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function(child,\ni){animations.push(animateVariant(child,variant,tslib.__assign(tslib.__assign({},options),{delay:delayChildren+generateStaggerDuration(i)})).then(function(){return child.notifyAnimationComplete(variant)}))});return Promise.all(animations)}function stopAnimation(visualElement){visualElement.forEachValue(function(value){return value.stop()})}function sortByTreeOrder(a,b){return a.sortNodePosition(b)}function shouldBlockAnimation(_a,key){var needsAnimating=_a.needsAnimating;_a=_a.protectedKeys.hasOwnProperty(key)&&\n!0!==needsAnimating[key];needsAnimating[key]=!1;return _a}function animateList(visualElement){return function(animations){return Promise.all(animations.map(function(_a){return animateVisualElement(visualElement,_a.animation,_a.options)}))}}function createAnimationState(visualElement){function animateChanges(options,changedActiveType){for(var _a,props=visualElement.getProps(),context=visualElement.getVariantContext(!0)||{},animations=[],removedKeys=new Set,encounteredKeys={},removedVariantIndex=Infinity,\n_loop_1=function(i){var type=reversePriorityOrder[i],typeState=state[type],prop=null!==(_a=props[type])&&void 0!==_a?_a:context[type],propIsVariant=isVariantLabel(prop),activeDelta=type===changedActiveType?typeState.isActive:null;!1===activeDelta&&(removedVariantIndex=i);var isInherited=prop===context[type]&&prop!==props[type]&&propIsVariant;isInherited&&isInitialRender&&visualElement.manuallyAnimateOnMount&&(isInherited=!1);typeState.protectedKeys=tslib.__assign({},encounteredKeys);if(!typeState.isActive&&\nnull===activeDelta||!prop&&!typeState.prevProp||isAnimationControls(prop)||\"boolean\"===typeof prop)return\"continue\";var shouldAnimateType=variantsHaveChanged(typeState.prevProp,prop)||type===changedActiveType&&typeState.isActive&&!isInherited&&propIsVariant||i>removedVariantIndex&&propIsVariant;i=Array.isArray(prop)?prop:[prop];propIsVariant=i.reduce(buildResolvedTypeValues,{});!1===activeDelta&&(propIsVariant={});activeDelta=typeState.prevResolvedValues;activeDelta=void 0===activeDelta?{}:activeDelta;\nvar allKeys=tslib.__assign(tslib.__assign({},activeDelta),propIsVariant),markToAnimate=function(key){shouldAnimateType=!0;removedKeys.delete(key);typeState.needsAnimating[key]=!0},key$jscomp$0;for(key$jscomp$0 in allKeys){allKeys=propIsVariant[key$jscomp$0];var prev=activeDelta[key$jscomp$0];encounteredKeys.hasOwnProperty(key$jscomp$0)||(allKeys!==prev?Array.isArray(allKeys)&&Array.isArray(prev)?shallowCompare(allKeys,prev)?typeState.protectedKeys[key$jscomp$0]=!0:markToAnimate(key$jscomp$0):void 0!==\nallKeys?markToAnimate(key$jscomp$0):removedKeys.add(key$jscomp$0):void 0!==allKeys&&removedKeys.has(key$jscomp$0)?markToAnimate(key$jscomp$0):typeState.protectedKeys[key$jscomp$0]=!0)}typeState.prevProp=prop;typeState.prevResolvedValues=propIsVariant;typeState.isActive&&(encounteredKeys=tslib.__assign(tslib.__assign({},encounteredKeys),propIsVariant));isInitialRender&&visualElement.blockInitialAnimation&&(shouldAnimateType=!1);shouldAnimateType&&!isInherited&&animations.push.apply(animations,tslib.__spreadArray([],\ntslib.__read(i.map(function(animation){return{animation:animation,options:tslib.__assign({type:type},options)}}))))},i$jscomp$0=0;i$jscomp$0<numAnimationTypes;i$jscomp$0++)_loop_1(i$jscomp$0);allAnimatedKeys=tslib.__assign({},encounteredKeys);if(removedKeys.size){var fallbackAnimation_1={};removedKeys.forEach(function(key){var fallbackTarget=visualElement.getBaseTarget(key);void 0!==fallbackTarget&&(fallbackAnimation_1[key]=fallbackTarget)});animations.push({animation:fallbackAnimation_1})}_loop_1=\n!!animations.length;isInitialRender&&!1===props.initial&&!visualElement.manuallyAnimateOnMount&&(_loop_1=!1);isInitialRender=!1;return _loop_1?animate(animations):Promise.resolve()}var animate=animateList(visualElement),state=createState(),allAnimatedKeys={},isInitialRender=!0,buildResolvedTypeValues=function(acc,definition){var resolved=resolveVariant(visualElement,definition);resolved&&(resolved.transition,definition=resolved.transitionEnd,resolved=tslib.__rest(resolved,[\"transition\",\"transitionEnd\"]),\nacc=tslib.__assign(tslib.__assign(tslib.__assign({},acc),resolved),definition));return acc};return{isAnimated:function(key){return void 0!==allAnimatedKeys[key]},animateChanges:animateChanges,setActive:function(type,isActive,options){var _a$jscomp$0;if(state[type].isActive===isActive)return Promise.resolve();null===(_a$jscomp$0=visualElement.variantChildren)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.forEach(function(child){var _a;return null===(_a=child.animationState)||void 0===_a?void 0:_a.setActive(type,\nisActive)});state[type].isActive=isActive;return animateChanges(options,type)},setAnimateFunction:function(makeAnimator){animate=makeAnimator(visualElement)},getState:function(){return state}}}function variantsHaveChanged(prev,next){return\"string\"===typeof next?next!==prev:Array.isArray(next)?!shallowCompare(next,prev):!1}function createTypeState(isActive){void 0===isActive&&(isActive=!1);return{isActive:isActive,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function createState(){var _a;\nreturn _a={},_a[AnimationType.Animate]=createTypeState(!0),_a[AnimationType.Hover]=createTypeState(),_a[AnimationType.Tap]=createTypeState(),_a[AnimationType.Drag]=createTypeState(),_a[AnimationType.Focus]=createTypeState(),_a[AnimationType.Exit]=createTypeState(),_a}function transformPoint(info,transformPagePoint){return transformPagePoint?{point:transformPagePoint(info.point)}:info}function subtractPoint(a,b){return{x:a.x-b.x,y:a.y-b.y}}function getPanInfo(_a,history){_a=_a.point;return{point:_a,\ndelta:subtractPoint(_a,history[history.length-1]),offset:subtractPoint(_a,history[0]),velocity:getVelocity(history,.1)}}function getVelocity(history,timeDelta){if(2>history.length)return{x:0,y:0};for(var i=history.length-1,timestampedPoint=null,lastPoint=history[history.length-1];0<=i;){timestampedPoint=history[i];if(lastPoint.timestamp-timestampedPoint.timestamp>1E3*timeDelta)break;i--}if(!timestampedPoint)return{x:0,y:0};history=(lastPoint.timestamp-timestampedPoint.timestamp)/1E3;if(0===history)return{x:0,\ny:0};timestampedPoint={x:(lastPoint.x-timestampedPoint.x)/history,y:(lastPoint.y-timestampedPoint.y)/history};Infinity===timestampedPoint.x&&(timestampedPoint.x=0);Infinity===timestampedPoint.y&&(timestampedPoint.y=0);return timestampedPoint}function noop(any){return any}function convertBoundingBoxToAxisBox(_a){return{x:{min:_a.left,max:_a.right},y:{min:_a.top,max:_a.bottom}}}function axisBox(){return{x:{min:0,max:1},y:{min:0,max:1}}}function copyAxisBox(box){return{x:tslib.__assign({},box.x),y:tslib.__assign({},\nbox.y)}}function eachAxis(handler){return[handler(\"x\"),handler(\"y\")]}function isNear(value,target,maxDistance){void 0===target&&(target=0);void 0===maxDistance&&(maxDistance=.01);return popmotion.distance(value,target)<maxDistance}function updateAxisDelta(delta,source,target,origin){void 0===origin&&(origin=.5);delta.origin=origin;delta.originPoint=popmotion.mix(source.min,source.max,delta.origin);delta.scale=(target.max-target.min)/(source.max-source.min);isNear(delta.scale,1,1E-4)&&(delta.scale=\n1);delta.translate=popmotion.mix(target.min,target.max,delta.origin)-delta.originPoint;isNear(delta.translate)&&(delta.translate=0)}function updateBoxDelta(delta,source,target,origin){updateAxisDelta(delta.x,source.x,target.x,defaultOrigin(origin.originX));updateAxisDelta(delta.y,source.y,target.y,defaultOrigin(origin.originY))}function defaultOrigin(origin){return\"number\"===typeof origin?origin:.5}function applyConstraints(point,_a,elastic){var min=_a.min;_a=_a.max;void 0!==min&&point<min?point=\nelastic?popmotion.mix(min,point,elastic.min):Math.max(point,min):void 0!==_a&&point>_a&&(point=elastic?popmotion.mix(_a,point,elastic.max):Math.min(point,_a));return point}function calcRelativeAxisConstraints(axis,min,max){return{min:void 0!==min?axis.min+min:void 0,max:void 0!==max?axis.max+max-(axis.max-axis.min):void 0}}function calcRelativeConstraints(layoutBox,_a){var top=_a.top,bottom=_a.bottom;return{x:calcRelativeAxisConstraints(layoutBox.x,_a.left,_a.right),y:calcRelativeAxisConstraints(layoutBox.y,\ntop,bottom)}}function calcViewportAxisConstraints(layoutAxis,constraintsAxis){var min=constraintsAxis.min-layoutAxis.min,max=constraintsAxis.max-layoutAxis.max;constraintsAxis.max-constraintsAxis.min<layoutAxis.max-layoutAxis.min&&(constraintsAxis=tslib.__read([max,min],2),min=constraintsAxis[0],max=constraintsAxis[1]);return{min:layoutAxis.min+min,max:layoutAxis.min+max}}function resolveDragElastic(dragElastic){!1===dragElastic?dragElastic=0:!0===dragElastic&&(dragElastic=.35);var JSCompiler_inline_result=\ndragElastic;JSCompiler_inline_result={min:resolvePointElastic(JSCompiler_inline_result,\"left\"),max:resolvePointElastic(JSCompiler_inline_result,\"right\")};dragElastic={min:resolvePointElastic(dragElastic,\"top\"),max:resolvePointElastic(dragElastic,\"bottom\")};return{x:JSCompiler_inline_result,y:dragElastic}}function resolvePointElastic(dragElastic,label){var _a;return\"number\"===typeof dragElastic?dragElastic:null!==(_a=dragElastic[label])&&void 0!==_a?_a:0}function getBoundingBox(element,transformPagePoint){var box=\nelement.getBoundingClientRect(),top=box.top,left=box.left;element=box.bottom;box=box.right;void 0===transformPagePoint&&(transformPagePoint=noop);top=transformPagePoint({x:left,y:top});transformPagePoint=transformPagePoint({x:box,y:element});return convertBoundingBoxToAxisBox({top:top.y,left:top.x,bottom:transformPagePoint.y,right:transformPagePoint.x})}function collectProjectingAncestors(visualElement,ancestors){void 0===ancestors&&(ancestors=[]);var parent=visualElement.parent;parent&&collectProjectingAncestors(parent,\nancestors);(visualElement.projection.isEnabled||visualElement.shouldResetTransform())&&ancestors.push(visualElement);return ancestors}function collectProjectingChildren(visualElement){var children=[],addChild=function(child){(child.projection.isEnabled||child.shouldResetTransform())&&children.push(child);child.children.forEach(addChild)};visualElement.children.forEach(addChild);return children.sort(compareByDepth)}function updateLayoutMeasurement(visualElement){if(!visualElement.shouldResetTransform()){var layoutState=\nvisualElement.getLayoutState();visualElement.notifyBeforeLayoutMeasure(layoutState.layout);layoutState.isHydrated=!0;layoutState.layout=visualElement.measureViewportBox();layoutState.layoutCorrected=copyAxisBox(layoutState.layout);visualElement.notifyLayoutMeasure(layoutState.layout,visualElement.prevViewportBox||layoutState.layout);sync__default[\"default\"].update(function(){return visualElement.rebaseProjectionTarget()})}}function snapshotViewportBox(visualElement){visualElement.shouldResetTransform()||\n(visualElement.prevViewportBox=visualElement.measureViewportBox(!1),visualElement.rebaseProjectionTarget(!1,visualElement.prevViewportBox))}function calcRelativeOffsetAxis(parent,child){return{min:child.min-parent.min,max:child.max-parent.min}}function calcRelativeOffset(parent,child){return{x:calcRelativeOffsetAxis(parent.x,child.x),y:calcRelativeOffsetAxis(parent.y,child.y)}}function checkIfParentHasChanged(prev,next){var prevId=prev.getLayoutId(),nextId=next.getLayoutId();return prevId!==nextId||\nvoid 0===nextId&&prev!==next}function isDraggable(visualElement){visualElement=visualElement.getProps();var _dragX=visualElement._dragX;return visualElement.drag&&!_dragX}function applyPointDelta(point,translate,scale,originPoint,boxScale){void 0!==boxScale&&(point=originPoint+boxScale*(point-originPoint));return originPoint+scale*(point-originPoint)+translate}function applyAxisDelta(axis,translate,scale,originPoint,boxScale){void 0===translate&&(translate=0);void 0===scale&&(scale=1);axis.min=applyPointDelta(axis.min,\ntranslate,scale,originPoint,boxScale);axis.max=applyPointDelta(axis.max,translate,scale,originPoint,boxScale)}function applyAxisTransforms(final,axis,transforms,_a){var _b=tslib.__read(_a,3);_a=_b[0];var scaleKey=_b[1];_b=_b[2];final.min=axis.min;final.max=axis.max;axis=popmotion.mix(axis.min,axis.max,void 0!==transforms[_b]?transforms[_b]:.5);applyAxisDelta(final,transforms[_a],transforms[scaleKey],axis,transforms.scale)}function applyBoxTransforms(finalBox,box,transforms){applyAxisTransforms(finalBox.x,\nbox.x,transforms,xKeys);applyAxisTransforms(finalBox.y,box.y,transforms,yKeys)}function removePointDelta(point,translate,scale,originPoint,boxScale){point=originPoint+1/scale*(point-translate-originPoint);void 0!==boxScale&&(point=originPoint+1/boxScale*(point-originPoint));return point}function removeAxisTransforms(axis,transforms,_a){var _b=tslib.__read(_a,3);_a=transforms[_b[0]];var scale=transforms[_b[1]];_b=transforms[_b[2]];transforms=transforms.scale;void 0===_a&&(_a=0);void 0===scale&&(scale=\n1);void 0===_b&&(_b=.5);_b=popmotion.mix(axis.min,axis.max,_b)-_a;axis.min=removePointDelta(axis.min,_a,scale,_b,transforms);axis.max=removePointDelta(axis.max,_a,scale,_b,transforms)}function removeBoxTransforms(box,transforms){removeAxisTransforms(box.x,transforms,xKeys);removeAxisTransforms(box.y,transforms,yKeys)}function convertToRelativeProjection(visualElement,isLayoutDrag){void 0===isLayoutDrag&&(isLayoutDrag=!0);var projectionParent=visualElement.getProjectionParent();if(!projectionParent)return!1;\nif(isLayoutDrag){var offset=calcRelativeOffset(projectionParent.projection.target,visualElement.projection.target);removeBoxTransforms(offset,projectionParent.getLatestValues())}else offset=calcRelativeOffset(projectionParent.getLayoutState().layout,visualElement.getLayoutState().layout);eachAxis(function(axis){return visualElement.setProjectionTargetAxis(axis,offset[axis].min,offset[axis].max,!0)});return!0}function batchLayout(callback){unresolvedJobs.add(callback);return function(){return unresolvedJobs.delete(callback)}}\nfunction flushLayout(){if(unresolvedJobs.size){var pointer$jscomp$0=0,reads=[[]],writes=[],setRead=function(job){var pointer=pointer$jscomp$0;reads[pointer]||(reads[pointer]=[]);reads[pointer].push(job)},setWrite=function(job){var pointer=pointer$jscomp$0;writes[pointer]||(writes[pointer]=[]);writes[pointer].push(job);pointer$jscomp$0++};unresolvedJobs.forEach(function(callback){callback(setRead,setWrite);pointer$jscomp$0=0});unresolvedJobs.clear();for(var numStacks=writes.length,i=0;i<=numStacks;i++)reads[i]&&\nreads[i].forEach(executeJob),writes[i]&&writes[i].forEach(executeJob)}}function shouldDrag(direction,drag,currentDirection){return(!0===drag||drag===direction)&&(null===currentDirection||currentDirection===direction)}function isCSSVariable(value){return\"string\"===typeof value&&value.startsWith(\"var(--\")}function parseCSSVariable(current){current=cssVariableRegex.exec(current);if(!current)return[,];current=tslib.__read(current,3);return[current[1],current[2]]}function getVariableValue(current,element,\ndepth){void 0===depth&&(depth=1);heyListen.invariant(4>=depth,'Max CSS variable fallback depth detected in property \"'+current+'\". This may indicate a circular fallback dependency.');var _a=tslib.__read(parseCSSVariable(current),2);current=_a[0];_a=_a[1];if(current)return(current=window.getComputedStyle(element).getPropertyValue(current))?current.trim():isCSSVariable(_a)?getVariableValue(_a,element,depth+1):_a}function resolveCSSVariables(visualElement,_a,transitionEnd){var _b;_a=tslib.__rest(_a,\n[]);var element=visualElement.getInstance();if(!(element instanceof HTMLElement))return{target:_a,transitionEnd:transitionEnd};transitionEnd&&(transitionEnd=tslib.__assign({},transitionEnd));visualElement.forEachValue(function(value){var current=value.get();isCSSVariable(current)&&(current=getVariableValue(current,element))&&value.set(current)});for(var key in _a)if(visualElement=_a[key],isCSSVariable(visualElement)){var resolved=getVariableValue(visualElement,element);resolved&&(_a[key]=resolved,\ntransitionEnd&&(null!==(_b=transitionEnd[key])&&void 0!==_b?_b:transitionEnd[key]=visualElement))}return{target:_a,transitionEnd:transitionEnd}}function hasMoved(a,b){return!isZeroBox(a)&&!isZeroBox(b)&&(!axisIsEqual(a.x,b.x)||!axisIsEqual(a.y,b.y))}function isZeroBox(a){return axisIsEqual(a.x,zeroAxis)&&axisIsEqual(a.y,zeroAxis)}function axisIsEqual(a,b){return a.min===b.min&&a.max===b.max}function createBatcher(){var queue=new Set;return{add:function(child){return queue.add(child)},flush:function(_a){_a=\nvoid 0===_a?defaultHandler:_a;var layoutReady=_a.layoutReady,parent=_a.parent;batchLayout(function(read,write){var order=Array.from(queue).sort(compareByDepth),ancestors=parent?collectProjectingAncestors(parent):[];write(function(){tslib.__spreadArray(tslib.__spreadArray([],tslib.__read(ancestors)),tslib.__read(order)).forEach(function(element){return element.resetTransform()})});read(function(){order.forEach(updateLayoutMeasurement)});write(function(){ancestors.forEach(function(element){return element.restoreTransform()});\norder.forEach(layoutReady)});read(function(){order.forEach(function(child){child.isPresent&&(child.presence=Presence.Present)})});write(function(){sync.flushSync.preRender();sync.flushSync.render()});read(function(){sync__default[\"default\"].postRender(function(){return order.forEach(assignProjectionToSnapshot)});queue.clear()})});flushLayout()}}}function assignProjectionToSnapshot(child){child.prevViewportBox=child.projection.target}function createLayoutState(){return{isHydrated:!1,layout:axisBox(),\nlayoutCorrected:axisBox(),treeScale:{x:1,y:1},delta:{x:tslib.__assign({},zeroDelta),y:tslib.__assign({},zeroDelta)},deltaFinal:{x:tslib.__assign({},zeroDelta),y:tslib.__assign({},zeroDelta)},deltaTransform:\"\"}}function buildLayoutProjectionTransform(_a,treeScale,latestTransform){var x=_a.x;_a=_a.y;treeScale=\"translate3d(\"+x.translate/treeScale.x+\"px, \"+_a.translate/treeScale.y+\"px, 0) \";if(latestTransform){var rotate=latestTransform.rotate,rotateX=latestTransform.rotateX,rotateY=latestTransform.rotateY;\nrotate&&(treeScale+=\"rotate(\"+rotate+\") \");rotateX&&(treeScale+=\"rotateX(\"+rotateX+\") \");rotateY&&(treeScale+=\"rotateY(\"+rotateY+\") \")}treeScale+=\"scale(\"+x.scale+\", \"+_a.scale+\")\";return latestTransform||treeScale!==identityProjection?treeScale:\"\"}function buildLayoutProjectionTransformOrigin(_a){_a=_a.deltaFinal;return 100*_a.x.origin+\"% \"+100*_a.y.origin+\"% 0\"}function createLifecycles(){var managers=names.map(function(){return new SubscriptionManager}),propSubscriptions={},lifecycles={clearAllListeners:function(){return managers.forEach(function(manager){return manager.clear()})},\nupdatePropListeners:function(props){return names.forEach(function(name){var _a;null===(_a=propSubscriptions[name])||void 0===_a?void 0:_a.call(propSubscriptions);_a=\"on\"+name;var propListener=props[_a];propListener&&(propSubscriptions[name]=lifecycles[_a](propListener))})}};managers.forEach(function(manager,i){lifecycles[\"on\"+names[i]]=function(handler){return manager.add(handler)};lifecycles[\"notify\"+names[i]]=function(){for(var args=[],_i=0;_i<arguments.length;_i++)args[_i]=arguments[_i];return manager.notify.apply(manager,\ntslib.__spreadArray([],tslib.__read(args)))}});return lifecycles}function setCurrentViewportBox(visualElement){var projectionParent=visualElement.getProjectionParent();if(projectionParent){var relativeOffset=calcRelativeOffset(projectionParent.getLayoutState().layout,visualElement.getLayoutState().layout);eachAxis(function(axis){visualElement.setProjectionTargetAxis(axis,relativeOffset[axis].min,relativeOffset[axis].max,!0)})}else visualElement.rebaseProjectionTarget()}function fireResolveRelativeTargetBox(child){child.resolveRelativeTargetBox()}\nfunction fireUpdateLayoutProjection(child){child.updateLayoutProjection()}function removeNonTranslationalTransform(visualElement){var removedTransforms=[];nonTranslationalTransformKeys.forEach(function(key){var value=visualElement.getValue(key);void 0!==value&&(removedTransforms.push([key,value.get()]),value.set(key.startsWith(\"scale\")?1:0))});removedTransforms.length&&visualElement.syncRender();return removedTransforms}function useForceUpdate(){var unloadingRef=React.useRef(!1),_a=tslib.__read(React.useState(0),\n2),forcedRenderCount=_a[0],setForcedRenderCount=_a[1];useUnmountEffect(function(){return unloadingRef.current=!0});return React.useCallback(function(){!unloadingRef.current&&setForcedRenderCount(forcedRenderCount+1)},[forcedRenderCount])}function getPresenceId(){var id=presenceId;presenceId++;return id}function newChildrenMap(){return new Map}function getChildKey(child){return child.key||\"\"}function updateChildLookup(children,allChildren){var seenChildren=new Set;children.forEach(function(child){var key=\ngetChildKey(child);seenChildren&&(seenChildren.has(key)&&console.warn('Children of AnimatePresence require unique keys. \"'+key+'\" is a duplicate.'),seenChildren.add(key));allChildren.set(key,child)})}function onlyElements(children){var filtered=[];React.Children.forEach(children,function(child){React.isValidElement(child)&&filtered.push(child)});return filtered}function animate$jscomp$0(from,to,transition){void 0===transition&&(transition={});var value=isMotionValue(from)?from:motionValue(from);startAnimation(\"\",\nvalue,to,transition);return{stop:function(){return value.stop()}}}function createCrossfader(){function startCrossfadeAnimation(target,transition){var lead=options.lead,follow=options.follow;isActive=!0;finalCrossfadeFrame=null;var hasUpdated=!1,onUpdate=function(){hasUpdated=!0;lead&&lead.scheduleRender();follow&&follow.scheduleRender()},onComplete=function(){isActive=!1;finalCrossfadeFrame=sync.getFrameData().timestamp};transition=transition&&getValueTransition(transition,\"crossfade\");return animate$jscomp$0(progress,\ntarget,tslib.__assign(tslib.__assign({},transition),{onUpdate:onUpdate,onComplete:function(){hasUpdated?onComplete():(progress.set(target),sync__default[\"default\"].read(onComplete));onUpdate()}}))}var progress=motionValue(1),options={lead:void 0,follow:void 0,crossfadeOpacity:!1,preserveFollowOpacity:!1},prevOptions=tslib.__assign({},options),leadState={},followState={},isActive=!1,finalCrossfadeFrame=null,prevUpdate=0;return{isActive:function(){return leadState&&(isActive||sync.getFrameData().timestamp===\nfinalCrossfadeFrame)},fromLead:function(transition){return startCrossfadeAnimation(0,transition)},toLead:function(transition){var initialProgress=0;options.prevValues||options.follow?prevOptions.lead===options.follow&&prevOptions.follow===options.lead&&(initialProgress=1-progress.get()):initialProgress=1;progress.set(initialProgress);return startCrossfadeAnimation(1,transition)},reset:function(){return progress.set(1)},stop:function(){return progress.stop()},getCrossfadeState:function(element){var _a,\n_b,timestamp=sync.getFrameData().timestamp,lead=options.lead,follow=options.follow;if(timestamp!==prevUpdate&&lead){prevUpdate=timestamp;timestamp=lead.getLatestValues();Object.assign(leadState,timestamp);var latestFollowValues=follow?follow.getLatestValues():options.prevValues;Object.assign(followState,latestFollowValues);lead=progress.get();var leadTargetOpacity=null!==(_a=timestamp.opacity)&&void 0!==_a?_a:1;_a=null!==(_b=null===latestFollowValues||void 0===latestFollowValues?void 0:latestFollowValues.opacity)&&\nvoid 0!==_b?_b:1;options.crossfadeOpacity&&follow?(leadState.opacity=popmotion.mix(!1!==follow.isVisible?0:_a,leadTargetOpacity,easeCrossfadeIn(lead)),followState.opacity=options.preserveFollowOpacity?_a:popmotion.mix(_a,0,easeCrossfadeOut(lead))):follow||(leadState.opacity=popmotion.mix(_a,leadTargetOpacity,lead));_b=leadState;_a=followState;latestFollowValues=latestFollowValues||{};follow=!!follow;for(leadTargetOpacity=0;leadTargetOpacity<numBorders;leadTargetOpacity++){var borderLabel=\"border\"+\nborders[leadTargetOpacity]+\"Radius\",followRadius=getRadius(latestFollowValues,borderLabel),leadRadius=getRadius(timestamp,borderLabel);if(void 0!==followRadius||void 0!==leadRadius)followRadius||(followRadius=0),leadRadius||(leadRadius=0),\"number\"===typeof followRadius&&\"number\"===typeof leadRadius&&(followRadius=Math.max(popmotion.mix(followRadius,leadRadius,lead),0),_b[borderLabel]=_a[borderLabel]=followRadius)}if(latestFollowValues.rotate||timestamp.rotate)leadTargetOpacity=popmotion.mix(latestFollowValues.rotate||\n0,timestamp.rotate||0,lead),_b.rotate=_a.rotate=leadTargetOpacity;!follow&&timestamp.backgroundColor&&latestFollowValues.backgroundColor&&(_b.backgroundColor=_a.backgroundColor=popmotion.mixColor(latestFollowValues.backgroundColor,timestamp.backgroundColor)(lead))}if(element===options.lead)return leadState;if(element===options.follow)return followState},setOptions:function(newOptions){prevOptions=options;options=newOptions;leadState={};followState={}},getLatestValues:function(){return leadState}}}\nfunction compress(min,max,easing){return function(p){return p<min?0:p>max?1:easing(popmotion.progress(min,max,p))}}function getRadius(values,radiusName){var _a;return null!==(_a=values[radiusName])&&void 0!==_a?_a:values.borderRadius}function layoutStack(){var stack=new Set,state={leadIsExiting:!1},prevState=tslib.__assign({},state),prevValues,prevViewportBox,prevDragCursor,crossfader=createCrossfader(),needsCrossfadeAnimation=!1;return{add:function(element){element.setCrossfader(crossfader);stack.add(element);\nprevDragCursor&&(element.prevDragCursor=prevDragCursor);state.lead||(state.lead=element)},remove:function(element){stack.delete(element)},getLead:function(){return state.lead},updateSnapshot:function(){if(state.lead){prevValues=crossfader.isActive()?crossfader.getLatestValues():state.lead.getLatestValues();prevViewportBox=state.lead.prevViewportBox;var dragControls=elementDragControls.get(state.lead);dragControls&&dragControls.isDragging&&(prevDragCursor=dragControls.cursorProgress)}},clearSnapshot:function(){prevDragCursor=\nprevViewportBox=void 0},updateLeadAndFollow:function(){var _a;prevState=tslib.__assign({},state);for(var lead,follow,order=Array.from(stack),i=order.length;i--;0<=i){var element=order[i];lead&&(null!==follow&&void 0!==follow?follow:follow=element);null!==lead&&void 0!==lead?lead:lead=element;if(lead&&follow)break}state.lead=lead;state.follow=follow;state.leadIsExiting=(null===(_a=state.lead)||void 0===_a?void 0:_a.presence)===Presence.Exiting;crossfader.setOptions({lead:lead,follow:follow,prevValues:prevValues,\ncrossfadeOpacity:(null===follow||void 0===follow?void 0:follow.isPresenceRoot)||(null===lead||void 0===lead?void 0:lead.isPresenceRoot)});state.lead===prevState.follow||prevState.lead===state.lead&&prevState.leadIsExiting===state.leadIsExiting||(needsCrossfadeAnimation=!0)},animate:function(child,shouldCrossfade){var _a;void 0===shouldCrossfade&&(shouldCrossfade=!1);if(child===state.lead){shouldCrossfade?child.pointTo(state.lead):child.setVisibility(!0);shouldCrossfade={};var prevParent=null===(_a=\nstate.follow)||void 0===_a?void 0:_a.getProjectionParent();prevParent&&(shouldCrossfade.prevParent=prevParent);if(child.presence===Presence.Entering)shouldCrossfade.originBox=state.follow?state.follow.prevViewportBox:prevViewportBox;else if(child.presence===Presence.Exiting){var _a$jscomp$0;_a=null===(_a$jscomp$0=state.follow)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.getLayoutState().layout;shouldCrossfade.targetBox=_a}needsCrossfadeAnimation&&(needsCrossfadeAnimation=!1,_a$jscomp$0=child.getDefaultTransition(),\nchild.presence===Presence.Entering?crossfader.toLead(_a$jscomp$0):crossfader.fromLead(_a$jscomp$0));child.notifyLayoutReady(shouldCrossfade)}else shouldCrossfade?state.lead&&child.pointTo(state.lead):child.setVisibility(!1)}}}function isLazyBundle(features){return\"function\"===typeof features}function useMotionValue(initial){var value=useConstant(function(){return motionValue(initial)});if(React.useContext(MotionConfigContext).isStatic){var setLatest_1=tslib.__read(React.useState(initial),2)[1];React.useEffect(function(){return value.onChange(setLatest_1)},\n[])}return value}function useOnChange(value,callback){React.useEffect(function(){if(isMotionValue(value))return value.onChange(callback)},[callback])}function useMultiOnChange(values,handler){React.useEffect(function(){var subscriptions=values.map(function(value){return value.onChange(handler)});return function(){return subscriptions.forEach(function(unsubscribe){return unsubscribe()})}})}function useCombineMotionValues(values,combineValues){var value=useMotionValue(combineValues()),updateValue=function(){return value.set(combineValues())};\nupdateValue();useMultiOnChange(values,function(){return sync__default[\"default\"].update(updateValue,!1,!0)});return value}function transform$jscomp$0(){for(var args=[],_i=0;_i<arguments.length;_i++)args[_i]=arguments[_i];var argOffset=(_i=!Array.isArray(args[0]))?0:-1,inputValue=args[0+argOffset],outputRange=args[2+argOffset],options=args[3+argOffset];args=popmotion.interpolate(args[1+argOffset],outputRange,tslib.__assign({mixer:getMixer(outputRange[0])},options));return _i?args(inputValue):args}\nfunction useTransform(input,inputRangeOrTransformer,outputRange,options){var transformer=\"function\"===typeof inputRangeOrTransformer?inputRangeOrTransformer:transform$jscomp$0(inputRangeOrTransformer,outputRange,options);return Array.isArray(input)?useListTransform(input,transformer):useListTransform([input],function(_a){_a=tslib.__read(_a,1)[0];return transformer(_a)})}function useListTransform(values,transformer){var latest=useConstant(function(){return[]});return useCombineMotionValues(values,\nfunction(){latest.length=0;for(var numValues=values.length,i=0;i<numValues;i++)latest[i]=values[i].get();return transformer(latest)})}function createScrollMotionValues(){return{scrollX:motionValue(0),scrollY:motionValue(0),scrollXProgress:motionValue(0),scrollYProgress:motionValue(0)}}function createScrollUpdater(values,getOffsets){var update=function(){var _a=getOffsets(),xOffset=_a.xOffset,yOffset=_a.yOffset,xMaxOffset=_a.xMaxOffset;_a=_a.yMaxOffset;values.scrollX.set(xOffset);values.scrollY.set(yOffset);\nvalues.scrollXProgress.set(xOffset&&xMaxOffset?xOffset/xMaxOffset:0);values.scrollYProgress.set(yOffset&&_a?yOffset/_a:0)};update();return update}function getViewportScrollOffsets(){return{xOffset:window.pageXOffset,yOffset:window.pageYOffset,xMaxOffset:document.body.clientWidth-window.innerWidth,yMaxOffset:document.body.clientHeight-window.innerHeight}}function initPrefersReducedMotion(){prefersReducedMotion=motionValue(null);if(\"undefined\"!==typeof window)if(window.matchMedia){var motionMediaQuery_1=\nwindow.matchMedia(\"(prefers-reduced-motion)\"),setReducedMotionPreferences=function(){return prefersReducedMotion.set(motionMediaQuery_1.matches)};motionMediaQuery_1.addListener(setReducedMotionPreferences);setReducedMotionPreferences()}else prefersReducedMotion.set(!1)}function animationControls(){var hasMounted=!1,pendingAnimations=[],subscribers=new Set,controls={subscribe:function(visualElement){subscribers.add(visualElement);return function(){return void subscribers.delete(visualElement)}},start:function(definition,\ntransitionOverride){if(hasMounted){var animations_1=[];subscribers.forEach(function(visualElement){animations_1.push(animateVisualElement(visualElement,definition,{transitionOverride:transitionOverride}))});return Promise.all(animations_1)}return new Promise(function(resolve){pendingAnimations.push({animation:[definition,transitionOverride],resolve:resolve})})},set:function(definition){heyListen.invariant(hasMounted,\"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\nreturn subscribers.forEach(function(visualElement){Array.isArray(definition)?setVariants(visualElement,definition):\"string\"===typeof definition?setVariants(visualElement,[definition]):setTarget(visualElement,definition)})},stop:function(){subscribers.forEach(function(visualElement){stopAnimation(visualElement)})},mount:function(){hasMounted=!0;pendingAnimations.forEach(function(_a){var resolve=_a.resolve;controls.start.apply(controls,tslib.__spreadArray([],tslib.__read(_a.animation))).then(resolve)});\nreturn function(){hasMounted=!1;controls.stop()}}};return controls}Object.defineProperty(exports,\"__esModule\",{value:!0});var tslib=require(\"module$node_modules$tslib$tslib\"),React=require(\"module$node_modules$react$index\"),heyListen=require(\"module$node_modules$hey_listen$dist$index\"),styleValueTypes=require(\"module$node_modules$style_value_types$dist$valueTypes_cjs\"),popmotion=require(\"module$node_modules$popmotion$dist$popmotion_cjs\"),sync=require(\"module$node_modules$framesync$dist$framesync_cjs\"),\nReact__namespace=function(e){if(e&&e.__esModule)return e;var n=Object.create(null);e&&Object.keys(e).forEach(function(k){if(\"default\"!==k){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:function(){return e[k]}})}});n[\"default\"]=e;return Object.freeze(n)}(React),React__default=_interopDefaultLegacy(React),sync__default=_interopDefaultLegacy(sync),createDefinition=function(propNames){return{isEnabled:function(props){return propNames.some(function(name){return!!props[name]})}}},\nfeatureDefinitions={measureLayout:createDefinition([\"layout\",\"layoutId\",\"drag\",\"_layoutResetTransform\"]),animation:createDefinition(\"animate exit variants whileHover whileTap whileFocus whileDrag\".split(\" \")),exit:createDefinition([\"exit\"]),drag:createDefinition([\"drag\",\"dragControls\"]),focus:createDefinition([\"whileFocus\"]),hover:createDefinition([\"whileHover\",\"onHoverStart\",\"onHoverEnd\"]),tap:createDefinition([\"whileTap\",\"onTap\",\"onTapStart\",\"onTapCancel\"]),pan:createDefinition([\"onPan\",\"onPanStart\",\n\"onPanSessionStart\",\"onPanEnd\"]),layoutAnimation:createDefinition([\"layout\",\"layoutId\"])},LazyContext=React.createContext({strict:!1}),featureNames=Object.keys(featureDefinitions),numFeatures=featureNames.length,MotionConfigContext=React.createContext({transformPagePoint:function(p){return p},isStatic:!1}),MotionContext=React.createContext({}),PresenceContext=React.createContext(null),counter=0,incrementId=function(){return counter++},LayoutGroupContext=React.createContext(null),isBrowser=\"undefined\"!==\ntypeof window,useIsomorphicLayoutEffect=isBrowser?React.useLayoutEffect:React.useEffect,lowercaseSVGElements=\"animate circle defs desc ellipse g image line filter marker mask metadata path pattern polygon polyline rect stop svg switch symbol text tspan use view\".split(\" \"),valueScaleCorrection={},transformAxes=[\"\",\"X\",\"Y\",\"Z\"],transformProps=[\"transformPerspective\",\"x\",\"y\",\"z\"];[\"translate\",\"scale\",\"rotate\",\"skew\"].forEach(function(operationKey){return transformAxes.forEach(function(axesKey){return transformProps.push(operationKey+\naxesKey)})});var transformPropSet=new Set(transformProps),transformOriginProps=new Set([\"originX\",\"originY\",\"originZ\"]),isMotionValue=function(value){return null!==value&&\"object\"===typeof value&&value.getVelocity},translateAlias={x:\"translateX\",y:\"translateY\",z:\"translateZ\",transformPerspective:\"perspective\"},int=tslib.__assign(tslib.__assign({},styleValueTypes.number),{transform:Math.round}),numberValueTypes={borderWidth:styleValueTypes.px,borderTopWidth:styleValueTypes.px,borderRightWidth:styleValueTypes.px,\nborderBottomWidth:styleValueTypes.px,borderLeftWidth:styleValueTypes.px,borderRadius:styleValueTypes.px,radius:styleValueTypes.px,borderTopLeftRadius:styleValueTypes.px,borderTopRightRadius:styleValueTypes.px,borderBottomRightRadius:styleValueTypes.px,borderBottomLeftRadius:styleValueTypes.px,width:styleValueTypes.px,maxWidth:styleValueTypes.px,height:styleValueTypes.px,maxHeight:styleValueTypes.px,size:styleValueTypes.px,top:styleValueTypes.px,right:styleValueTypes.px,bottom:styleValueTypes.px,left:styleValueTypes.px,\npadding:styleValueTypes.px,paddingTop:styleValueTypes.px,paddingRight:styleValueTypes.px,paddingBottom:styleValueTypes.px,paddingLeft:styleValueTypes.px,margin:styleValueTypes.px,marginTop:styleValueTypes.px,marginRight:styleValueTypes.px,marginBottom:styleValueTypes.px,marginLeft:styleValueTypes.px,rotate:styleValueTypes.degrees,rotateX:styleValueTypes.degrees,rotateY:styleValueTypes.degrees,rotateZ:styleValueTypes.degrees,scale:styleValueTypes.scale,scaleX:styleValueTypes.scale,scaleY:styleValueTypes.scale,\nscaleZ:styleValueTypes.scale,skew:styleValueTypes.degrees,skewX:styleValueTypes.degrees,skewY:styleValueTypes.degrees,distance:styleValueTypes.px,translateX:styleValueTypes.px,translateY:styleValueTypes.px,translateZ:styleValueTypes.px,x:styleValueTypes.px,y:styleValueTypes.px,z:styleValueTypes.px,perspective:styleValueTypes.px,transformPerspective:styleValueTypes.px,opacity:styleValueTypes.alpha,originX:styleValueTypes.progressPercentage,originY:styleValueTypes.progressPercentage,originZ:styleValueTypes.px,\nzIndex:int,fillOpacity:styleValueTypes.alpha,strokeOpacity:styleValueTypes.alpha,numOctaves:int},createHtmlRenderState=function(){return{style:{},transform:{},transformKeys:[],transformOrigin:{},vars:{}}},validMotionProps=new Set(\"initial animate exit style variants transition transformTemplate transformValues custom inherit layout layoutId _layoutResetTransform onLayoutAnimationComplete onViewportBoxUpdate onLayoutMeasure onBeforeLayoutMeasure onAnimationStart onAnimationComplete onUpdate onDragStart onDrag onDragEnd onMeasureDragConstraints onDirectionLock onDragTransitionEnd drag dragControls dragListener dragConstraints dragDirectionLock _dragX _dragY dragElastic dragMomentum dragPropagation dragTransition whileDrag onPan onPanStart onPanEnd onPanSessionStart onTap onTapStart onTapCancel onHoverStart onHoverEnd whileFocus whileTap whileHover\".split(\" \")),\nshouldForward=function(key){return!isValidMotionProp(key)};try{var emotionIsPropValid_1=require(\"module$node_modules$$emotion$is_prop_valid$dist$is_prop_valid_browser_cjs\").default;shouldForward=function(key){return key.startsWith(\"on\")?!isValidMotionProp(key):emotionIsPropValid_1(key)}}catch(_a){}var dashKeys={offset:\"stroke-dashoffset\",array:\"stroke-dasharray\"},camelKeys={offset:\"strokeDashoffset\",array:\"strokeDasharray\"},createSvgRenderState=function(){return tslib.__assign(tslib.__assign({},createHtmlRenderState()),\n{attrs:{}})},CAMEL_CASE_PATTERN=/([a-z])([A-Z])/g,camelCaseAttributes=new Set(\"baseFrequency diffuseConstant kernelMatrix kernelUnitLength keySplines keyTimes limitingConeAngle markerHeight markerWidth numOctaves targetX targetY surfaceScale specularConstant specularExponent stdDeviation tableValues viewBox gradientTransform\".split(\" \")),makeUseVisualState=function(config){return function(props,isStatic){var context=React.useContext(MotionContext),presenceContext=React.useContext(PresenceContext);\nreturn isStatic?makeState(config,props,context,presenceContext):useConstant(function(){return makeState(config,props,context,presenceContext)})}},svgMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps,createRenderState:createSvgRenderState,onMount:function(props,instance,_a){var renderState=_a.renderState;_a=_a.latestValues;try{renderState.dimensions=\"function\"===typeof instance.getBBox?instance.getBBox():instance.getBoundingClientRect()}catch(e){renderState.dimensions=\n{x:0,y:0,width:0,height:0}}\"path\"===instance.tagName&&(renderState.totalPathLength=instance.getTotalLength());buildSVGAttrs(renderState,_a,void 0,void 0,{enableHardwareAcceleration:!1},props.transformTemplate);renderSVG(instance,renderState)}})},htmlMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps$1,createRenderState:createHtmlRenderState})},AnimationType;(function(AnimationType){AnimationType.Animate=\"animate\";AnimationType.Hover=\"whileHover\";\nAnimationType.Tap=\"whileTap\";AnimationType.Drag=\"whileDrag\";AnimationType.Focus=\"whileFocus\";AnimationType.Exit=\"exit\"})(AnimationType||(AnimationType={}));var defaultPagePoint={pageX:0,pageY:0},wrapHandler=function(handler,shouldFilterPrimaryPointer){void 0===shouldFilterPrimaryPointer&&(shouldFilterPrimaryPointer=!1);var listener=function(event){return handler(event,extractEventInfo(event))};return shouldFilterPrimaryPointer?filterPrimaryPointer(listener):listener},mouseEventNames={pointerdown:\"mousedown\",\npointermove:\"mousemove\",pointerup:\"mouseup\",pointercancel:\"mousecancel\",pointerover:\"mouseover\",pointerout:\"mouseout\",pointerenter:\"mouseenter\",pointerleave:\"mouseleave\"},touchEventNames={pointerdown:\"touchstart\",pointermove:\"touchmove\",pointerup:\"touchend\",pointercancel:\"touchcancel\"},globalHorizontalLock=createLock(\"dragHorizontal\"),globalVerticalLock=createLock(\"dragVertical\"),isNodeOrChild=function(parent,child){return child?parent===child?!0:isNodeOrChild(parent,child.parentElement):!1},makeRenderlessComponent=\nfunction(hook){return function(props){hook(props);return null}},gestureAnimations={tap:makeRenderlessComponent(function(_a$jscomp$0){function removePointerEndListener(){var _a;null===(_a=cancelPointerEndListeners.current)||void 0===_a?void 0:_a.call(cancelPointerEndListeners);cancelPointerEndListeners.current=null}function checkPointerEnd(){var _a;removePointerEndListener();isPressing.current=!1;null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.setActive(AnimationType.Tap,!1);return!isDragActive()}\nfunction onPointerUp(event,info){checkPointerEnd()&&(isNodeOrChild(visualElement.getInstance(),event.target)?null===onTap||void 0===onTap?void 0:onTap(event,info):null===onTapCancel||void 0===onTapCancel?void 0:onTapCancel(event,info))}function onPointerCancel(event,info){checkPointerEnd()&&(null===onTapCancel||void 0===onTapCancel?void 0:onTapCancel(event,info))}function onPointerDown(event,info){var _a;removePointerEndListener();isPressing.current||(isPressing.current=!0,cancelPointerEndListeners.current=\npopmotion.pipe(addPointerEvent(window,\"pointerup\",onPointerUp),addPointerEvent(window,\"pointercancel\",onPointerCancel)),null===onTapStart||void 0===onTapStart?void 0:onTapStart(event,info),null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.setActive(AnimationType.Tap,!0))}var onTap=_a$jscomp$0.onTap,onTapStart=_a$jscomp$0.onTapStart,onTapCancel=_a$jscomp$0.onTapCancel,whileTap=_a$jscomp$0.whileTap,visualElement=_a$jscomp$0.visualElement;_a$jscomp$0=onTap||onTapStart||onTapCancel||whileTap;\nvar isPressing=React.useRef(!1),cancelPointerEndListeners=React.useRef(null);usePointerEvent(visualElement,\"pointerdown\",_a$jscomp$0?onPointerDown:void 0);useUnmountEffect(removePointerEndListener)}),focus:makeRenderlessComponent(function(_a$jscomp$0){var whileFocus=_a$jscomp$0.whileFocus,visualElement=_a$jscomp$0.visualElement;_a$jscomp$0=function(){var _a;null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.setActive(AnimationType.Focus,!0)};var onBlur=function(){var _a;null===(_a=visualElement.animationState)||\nvoid 0===_a?void 0:_a.setActive(AnimationType.Focus,!1)};useDomEvent(visualElement,\"focus\",whileFocus?_a$jscomp$0:void 0);useDomEvent(visualElement,\"blur\",whileFocus?onBlur:void 0)}),hover:makeRenderlessComponent(function(_a){var onHoverStart=_a.onHoverStart,onHoverEnd=_a.onHoverEnd,whileHover=_a.whileHover;_a=_a.visualElement;usePointerEvent(_a,\"pointerenter\",onHoverStart||whileHover?createHoverEvent(_a,!0,onHoverStart):void 0);usePointerEvent(_a,\"pointerleave\",onHoverEnd||whileHover?createHoverEvent(_a,\n!1,onHoverEnd):void 0)})},easingLookup={linear:popmotion.linear,easeIn:popmotion.easeIn,easeInOut:popmotion.easeInOut,easeOut:popmotion.easeOut,circIn:popmotion.circIn,circInOut:popmotion.circInOut,circOut:popmotion.circOut,backIn:popmotion.backIn,backInOut:popmotion.backInOut,backOut:popmotion.backOut,anticipate:popmotion.anticipate,bounceIn:popmotion.bounceIn,bounceInOut:popmotion.bounceInOut,bounceOut:popmotion.bounceOut},easingDefinitionToFunction=function(definition){return Array.isArray(definition)?\n(heyListen.invariant(4===definition.length,\"Cubic bezier arrays must contain four numerical values.\"),definition=tslib.__read(definition,4),popmotion.cubicBezier(definition[0],definition[1],definition[2],definition[3])):\"string\"===typeof definition?(heyListen.invariant(void 0!==easingLookup[definition],\"Invalid easing type '\"+definition+\"'\"),easingLookup[definition]):definition},isAnimatable=function(key,value){return\"zIndex\"===key?!1:\"number\"===typeof value||Array.isArray(value)||\"string\"===typeof value&&\nstyleValueTypes.complex.test(value)&&!value.startsWith(\"url(\")?!0:!1},underDampedSpring=function(){return{type:\"spring\",stiffness:500,damping:25,restDelta:.5,restSpeed:10}},criticallyDampedSpring=function(to){return{type:\"spring\",stiffness:550,damping:0===to?2*Math.sqrt(550):30,restDelta:.01,restSpeed:10}},linearTween=function(){return{type:\"keyframes\",ease:\"linear\",duration:.3}},keyframes=function(values){return{type:\"keyframes\",duration:.8,values:values}},defaultTransitions={x:underDampedSpring,\ny:underDampedSpring,z:underDampedSpring,rotate:underDampedSpring,rotateX:underDampedSpring,rotateY:underDampedSpring,rotateZ:underDampedSpring,scaleX:criticallyDampedSpring,scaleY:criticallyDampedSpring,scale:criticallyDampedSpring,opacity:linearTween,backgroundColor:linearTween,color:linearTween,default:criticallyDampedSpring},getDefaultTransition=function(valueKey,to){valueKey=Array.isArray(to)?keyframes:defaultTransitions[valueKey]||defaultTransitions.default;return tslib.__assign({to:to},valueKey(to))},\ndefaultValueTypes=tslib.__assign(tslib.__assign({},numberValueTypes),{color:styleValueTypes.color,backgroundColor:styleValueTypes.color,outlineColor:styleValueTypes.color,fill:styleValueTypes.color,stroke:styleValueTypes.color,borderColor:styleValueTypes.color,borderTopColor:styleValueTypes.color,borderRightColor:styleValueTypes.color,borderBottomColor:styleValueTypes.color,borderLeftColor:styleValueTypes.color,filter:styleValueTypes.filter,WebkitFilter:styleValueTypes.filter}),legacyRepeatWarning=\n!1,SubscriptionManager=function(){function SubscriptionManager(){this.subscriptions=[]}SubscriptionManager.prototype.add=function(handler){var _this=this;addUniqueItem(this.subscriptions,handler);return function(){var arr=_this.subscriptions,index=arr.indexOf(handler);-1<index&&arr.splice(index,1)}};SubscriptionManager.prototype.notify=function(a,b,c){var numSubscriptions=this.subscriptions.length;if(numSubscriptions)if(1===numSubscriptions)this.subscriptions[0](a,b,c);else for(var i=0;i<numSubscriptions;i++){var handler=\nthis.subscriptions[i];handler&&handler(a,b,c)}};SubscriptionManager.prototype.getSize=function(){return this.subscriptions.length};SubscriptionManager.prototype.clear=function(){this.subscriptions.length=0};return SubscriptionManager}(),MotionValue=function(){function MotionValue(init){var _this=this;this.lastUpdated=this.timeDelta=0;this.updateSubscribers=new SubscriptionManager;this.velocityUpdateSubscribers=new SubscriptionManager;this.renderSubscribers=new SubscriptionManager;this.canTrackVelocity=\n!1;this.updateAndNotify=function(v,render){void 0===render&&(render=!0);_this.prev=_this.current;_this.current=v;var _a=sync.getFrameData();v=_a.delta;_a=_a.timestamp;_this.lastUpdated!==_a&&(_this.timeDelta=v,_this.lastUpdated=_a,sync__default[\"default\"].postRender(_this.scheduleVelocityCheck));_this.prev!==_this.current&&_this.updateSubscribers.notify(_this.current);_this.velocityUpdateSubscribers.getSize()&&_this.velocityUpdateSubscribers.notify(_this.getVelocity());render&&_this.renderSubscribers.notify(_this.current)};\nthis.scheduleVelocityCheck=function(){return sync__default[\"default\"].postRender(_this.velocityCheck)};this.velocityCheck=function(_a){_a.timestamp!==_this.lastUpdated&&(_this.prev=_this.current,_this.velocityUpdateSubscribers.notify(_this.getVelocity()))};this.hasAnimated=!1;this.prev=this.current=init;this.canTrackVelocity=!isNaN(parseFloat(this.current))}MotionValue.prototype.onChange=function(subscription){return this.updateSubscribers.add(subscription)};MotionValue.prototype.clearListeners=function(){this.updateSubscribers.clear()};\nMotionValue.prototype.onRenderRequest=function(subscription){subscription(this.get());return this.renderSubscribers.add(subscription)};MotionValue.prototype.attach=function(passiveEffect){this.passiveEffect=passiveEffect};MotionValue.prototype.set=function(v,render){void 0===render&&(render=!0);render&&this.passiveEffect?this.passiveEffect(v,this.updateAndNotify):this.updateAndNotify(v,render)};MotionValue.prototype.get=function(){return this.current};MotionValue.prototype.getPrevious=function(){return this.prev};\nMotionValue.prototype.getVelocity=function(){return this.canTrackVelocity?popmotion.velocityPerSecond(parseFloat(this.current)-parseFloat(this.prev),this.timeDelta):0};MotionValue.prototype.start=function(animation){var _this=this;this.stop();return(new Promise(function(resolve){_this.hasAnimated=!0;_this.stopAnimation=animation(resolve)})).then(function(){return _this.clearAnimation()})};MotionValue.prototype.stop=function(){this.stopAnimation&&this.stopAnimation();this.clearAnimation()};MotionValue.prototype.isAnimating=\nfunction(){return!!this.stopAnimation};MotionValue.prototype.clearAnimation=function(){this.stopAnimation=null};MotionValue.prototype.destroy=function(){this.updateSubscribers.clear();this.renderSubscribers.clear();this.stop()};return MotionValue}(),testValueType=function(v){return function(type){return type.test(v)}},dimensionValueTypes=[styleValueTypes.number,styleValueTypes.px,styleValueTypes.percent,styleValueTypes.degrees,styleValueTypes.vw,styleValueTypes.vh,{test:function(v){return\"auto\"===\nv},parse:function(v){return v}}],valueTypes=tslib.__spreadArray(tslib.__spreadArray([],tslib.__read(dimensionValueTypes)),[styleValueTypes.color,styleValueTypes.complex]),variantPriorityOrder=[AnimationType.Animate,AnimationType.Hover,AnimationType.Tap,AnimationType.Drag,AnimationType.Focus,AnimationType.Exit],reversePriorityOrder=tslib.__spreadArray([],tslib.__read(variantPriorityOrder)).reverse(),numAnimationTypes=variantPriorityOrder.length,animations={animation:makeRenderlessComponent(function(_a){var visualElement=\n_a.visualElement,animate=_a.animate;visualElement.animationState||(visualElement.animationState=createAnimationState(visualElement));isAnimationControls(animate)&&React.useEffect(function(){return animate.subscribe(visualElement)},[animate])}),exit:makeRenderlessComponent(function(props){var custom=props.custom,visualElement=props.visualElement;props=tslib.__read(usePresence(),2);var isPresent=props[0],onExitComplete=props[1],presenceContext=React.useContext(PresenceContext);React.useEffect(function(){var _a,\n_b,animation=null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.setActive(AnimationType.Exit,!isPresent,{custom:null!==(_b=null===presenceContext||void 0===presenceContext?void 0:presenceContext.custom)&&void 0!==_b?_b:custom});!isPresent&&(null===animation||void 0===animation?void 0:animation.then(onExitComplete))},[isPresent])})},PanSession=function(){function PanSession(event$jscomp$0,handlers,_a$jscomp$0){var _this=this;_a$jscomp$0=(void 0===_a$jscomp$0?{}:_a$jscomp$0).transformPagePoint;\nthis.lastMoveEventInfo=this.lastMoveEvent=this.startEvent=null;this.handlers={};this.updatePoint=function(){if(_this.lastMoveEvent&&_this.lastMoveEventInfo){var info=getPanInfo(_this.lastMoveEventInfo,_this.history),isPanStarted=null!==_this.startEvent,isDistancePastThreshold=3<=popmotion.distance(info.offset,{x:0,y:0});if(isPanStarted||isDistancePastThreshold){isDistancePastThreshold=info.point;var timestamp=sync.getFrameData().timestamp;_this.history.push(tslib.__assign(tslib.__assign({},isDistancePastThreshold),\n{timestamp:timestamp}));timestamp=_this.handlers;isDistancePastThreshold=timestamp.onStart;timestamp=timestamp.onMove;isPanStarted||(isDistancePastThreshold&&isDistancePastThreshold(_this.lastMoveEvent,info),_this.startEvent=_this.lastMoveEvent);timestamp&&timestamp(_this.lastMoveEvent,info)}}};this.handlePointerMove=function(event,info){_this.lastMoveEvent=event;_this.lastMoveEventInfo=transformPoint(info,_this.transformPagePoint);isMouseEvent(event)&&0===event.buttons?_this.handlePointerUp(event,\ninfo):sync__default[\"default\"].update(_this.updatePoint,!0)};this.handlePointerUp=function(event,info){_this.end();var _a=_this.handlers,onEnd=_a.onEnd;_a=_a.onSessionEnd;info=getPanInfo(transformPoint(info,_this.transformPagePoint),_this.history);_this.startEvent&&onEnd&&onEnd(event,info);_a&&_a(event,info)};if(!(event$jscomp$0.touches&&1<event$jscomp$0.touches.length)){this.handlers=handlers;this.transformPagePoint=_a$jscomp$0;_a$jscomp$0=extractEventInfo(event$jscomp$0);_a$jscomp$0=transformPoint(_a$jscomp$0,\nthis.transformPagePoint);var point=_a$jscomp$0.point,timestamp$jscomp$0=sync.getFrameData().timestamp;this.history=[tslib.__assign(tslib.__assign({},point),{timestamp:timestamp$jscomp$0})];(handlers=handlers.onSessionStart)&&handlers(event$jscomp$0,getPanInfo(_a$jscomp$0,this.history));this.removeListeners=popmotion.pipe(addPointerEvent(window,\"pointermove\",this.handlePointerMove),addPointerEvent(window,\"pointerup\",this.handlePointerUp),addPointerEvent(window,\"pointercancel\",this.handlePointerUp))}}\nPanSession.prototype.updateHandlers=function(handlers){this.handlers=handlers};PanSession.prototype.end=function(){this.removeListeners&&this.removeListeners();sync.cancelSync.update(this.updatePoint)};return PanSession}(),zeroDelta={translate:0,scale:1,origin:0,originPoint:0},compareByDepth=function(a,b){return a.depth-b.depth},xKeys=[\"x\",\"scaleX\",\"originX\"],yKeys=[\"y\",\"scaleY\",\"originY\"],unresolvedJobs=new Set,executeJob=function(job){return job()},elementDragControls=new WeakMap,lastPointerEvent,\nVisualElementDragControls=function(){function VisualElementDragControls(_a){_a=_a.visualElement;this.isDragging=!1;this.currentDirection=null;this.constraints=!1;this.elastic=axisBox();this.props={};this.hasMutatedConstraints=!1;this.cursorProgress={x:.5,y:.5};this.originPoint={};this.panSession=this.openGlobalLock=null;this.visualElement=_a;this.visualElement.enableLayoutProjection();elementDragControls.set(_a,this)}VisualElementDragControls.prototype.start=function(originEvent,_a$jscomp$1){var _this=\nthis;_a$jscomp$1=void 0===_a$jscomp$1?{}:_a$jscomp$1;var _c$jscomp$0=_a$jscomp$1.snapToCursor,snapToCursor=void 0===_c$jscomp$0?!1:_c$jscomp$0,cursorProgress=_a$jscomp$1.cursorProgress;this.panSession=new PanSession(originEvent,{onSessionStart:function(event){var _a$jscomp$0;_this.stopMotion();var initialPoint=extractEventInfo(event,\"client\").point;null===(_a$jscomp$0=_this.cancelLayout)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.call(_this);_this.cancelLayout=batchLayout(function(read,write){var ancestors=\ncollectProjectingAncestors(_this.visualElement),children=collectProjectingChildren(_this.visualElement),tree=tslib.__spreadArray(tslib.__spreadArray([],tslib.__read(ancestors)),tslib.__read(children)),hasManuallySetCursorOrigin=!1;_this.isLayoutDrag()&&_this.visualElement.lockProjectionTarget();write(function(){tree.forEach(function(element){return element.resetTransform()})});read(function(){updateLayoutMeasurement(_this.visualElement);children.forEach(updateLayoutMeasurement)});write(function(){tree.forEach(function(element){return element.restoreTransform()});\nsnapToCursor&&(hasManuallySetCursorOrigin=_this.snapToCursor(initialPoint))});read(function(){_this.getAxisMotionValue(\"x\")&&!_this.isExternalDrag()||_this.visualElement.rebaseProjectionTarget(!0,_this.visualElement.measureViewportBox(!1));_this.visualElement.scheduleUpdateLayoutProjection();var projection=_this.visualElement.projection;eachAxis(function(axis){if(!hasManuallySetCursorOrigin){var _a=projection.target[axis],min=_a.min;_a=_a.max;_this.cursorProgress[axis]=cursorProgress?cursorProgress[axis]:\npopmotion.progress(min,_a,initialPoint[axis])}(min=_this.getAxisMotionValue(axis))&&(_this.originPoint[axis]=min.get())})});write(function(){sync.flushSync.update();sync.flushSync.preRender();sync.flushSync.render();sync.flushSync.postRender()});read(function(){return _this.resolveDragConstraints()})})},onStart:function(event,info){var _a,_b,_c,_d=_this.props,drag=_d.drag;_d=_d.dragPropagation;if(drag&&!_d&&(_this.openGlobalLock&&_this.openGlobalLock(),_this.openGlobalLock=getGlobalLock(drag),!_this.openGlobalLock))return;\nflushLayout();_this.isDragging=!0;_this.currentDirection=null;null===(_b=(_a=_this.props).onDragStart)||void 0===_b?void 0:_b.call(_a,event,info);null===(_c=_this.visualElement.animationState)||void 0===_c?void 0:_c.setActive(AnimationType.Drag,!0)},onMove:function(event,info){var _a,_b,_c,_d,_e=_this.props;if(_e.dragPropagation||_this.openGlobalLock){var offset=info.offset;_e.dragDirectionLock&&null===_this.currentDirection?(event=void 0,void 0===event&&(event=10),info=null,Math.abs(offset.y)>event?\ninfo=\"y\":Math.abs(offset.x)>event&&(info=\"x\"),_this.currentDirection=info,null!==_this.currentDirection&&(null===(_b=(_a=_this.props).onDirectionLock)||void 0===_b?void 0:_b.call(_a,_this.currentDirection))):(_this.updateAxis(\"x\",info.point,offset),_this.updateAxis(\"y\",info.point,offset),null===(_d=(_c=_this.props).onDrag)||void 0===_d?void 0:_d.call(_c,event,info),lastPointerEvent=event)}},onSessionEnd:function(event,info){return _this.stop(event,info)}},{transformPagePoint:this.props.transformPagePoint})};\nVisualElementDragControls.prototype.resolveDragConstraints=function(){var _this=this,_a=this.props,dragConstraints=_a.dragConstraints;_a=_a.dragElastic;var layout$jscomp$0=this.visualElement.getLayoutState().layoutCorrected;this.constraints=dragConstraints?isRefObject(dragConstraints)?this.resolveRefConstraints(layout$jscomp$0,dragConstraints):calcRelativeConstraints(layout$jscomp$0,dragConstraints):!1;this.elastic=resolveDragElastic(_a);this.constraints&&!this.hasMutatedConstraints&&eachAxis(function(axis){if(_this.getAxisMotionValue(axis)){var JSCompiler_temp_const=\n_this.constraints,layout=layout$jscomp$0[axis],constraints=_this.constraints[axis],relativeConstraints={};void 0!==constraints.min&&(relativeConstraints.min=constraints.min-layout.min);void 0!==constraints.max&&(relativeConstraints.max=constraints.max-layout.min);JSCompiler_temp_const[axis]=relativeConstraints}})};VisualElementDragControls.prototype.resolveRefConstraints=function(layoutBox,constraints){var _a=this.props,onMeasureDragConstraints=_a.onMeasureDragConstraints;_a=_a.transformPagePoint;\nconstraints=constraints.current;heyListen.invariant(null!==constraints,\"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");constraints=this.constraintsBox=getBoundingBox(constraints,_a);layoutBox={x:calcViewportAxisConstraints(layoutBox.x,constraints.x),y:calcViewportAxisConstraints(layoutBox.y,constraints.y)};onMeasureDragConstraints&&(constraints=layoutBox.x,_a=layoutBox.y,onMeasureDragConstraints=onMeasureDragConstraints({top:_a.min,bottom:_a.max,\nleft:constraints.min,right:constraints.max}),this.hasMutatedConstraints=!!onMeasureDragConstraints,onMeasureDragConstraints&&(layoutBox=convertBoundingBoxToAxisBox(onMeasureDragConstraints)));return layoutBox};VisualElementDragControls.prototype.cancelDrag=function(){var _a,_b;this.visualElement.unlockProjectionTarget();null===(_a=this.cancelLayout)||void 0===_a?void 0:_a.call(this);this.isDragging=!1;this.panSession&&this.panSession.end();this.panSession=null;!this.props.dragPropagation&&this.openGlobalLock&&\n(this.openGlobalLock(),this.openGlobalLock=null);null===(_b=this.visualElement.animationState)||void 0===_b?void 0:_b.setActive(AnimationType.Drag,!1)};VisualElementDragControls.prototype.stop=function(event,info){var _a,_b,_c;null===(_a=this.panSession)||void 0===_a?void 0:_a.end();this.panSession=null;_a=this.isDragging;this.cancelDrag();_a&&(this.animateDragEnd(info.velocity),null===(_c=(_b=this.props).onDragEnd)||void 0===_c?void 0:_c.call(_b,event,info))};VisualElementDragControls.prototype.snapToCursor=\nfunction(point){var _this=this;return eachAxis(function(axis){if(shouldDrag(axis,_this.props.drag,_this.currentDirection)){var axisValue=_this.getAxisMotionValue(axis);if(axisValue){var box=_this.visualElement.getLayoutState().layout;box=point[axis]-(box[axis].min+(box[axis].max-box[axis].min)/2);_this.originPoint[axis]=point[axis];axisValue.set(box)}else return _this.cursorProgress[axis]=.5,!0}}).includes(!0)};VisualElementDragControls.prototype.updateAxis=function(axis,point,offset){if(shouldDrag(axis,\nthis.props.drag,this.currentDirection))return this.getAxisMotionValue(axis)?this.updateAxisMotionValue(axis,offset):this.updateVisualElementAxis(axis,point)};VisualElementDragControls.prototype.updateAxisMotionValue=function(axis,offset){var axisValue=this.getAxisMotionValue(axis);offset&&axisValue&&(offset=this.originPoint[axis]+offset[axis],axis=this.constraints?applyConstraints(offset,this.constraints[axis],this.elastic[axis]):offset,axisValue.set(axis))};VisualElementDragControls.prototype.updateVisualElementAxis=\nfunction(axis,point){var _a,axisLayout=this.visualElement.getLayoutState().layout[axis];axisLayout=axisLayout.max-axisLayout.min;var axisProgress=this.cursorProgress[axis],constraints=null===(_a=this.constraints)||void 0===_a?void 0:_a[axis];point=point[axis]-axisLayout*axisProgress;point=constraints?applyConstraints(point,constraints,this.elastic[axis]):point;this.visualElement.setProjectionTargetAxis(axis,point,point+axisLayout)};VisualElementDragControls.prototype.setProps=function(_a){var _b=\n_a.drag;_b=void 0===_b?!1:_b;var _c=_a.dragDirectionLock;_c=void 0===_c?!1:_c;var _d=_a.dragPropagation;_d=void 0===_d?!1:_d;var _e=_a.dragConstraints;_e=void 0===_e?!1:_e;var _f=_a.dragElastic;_f=void 0===_f?.35:_f;var _g=_a.dragMomentum;_g=void 0===_g?!0:_g;_a=tslib.__rest(_a,\"drag dragDirectionLock dragPropagation dragConstraints dragElastic dragMomentum\".split(\" \"));this.props=tslib.__assign({drag:_b,dragDirectionLock:_c,dragPropagation:_d,dragConstraints:_e,dragElastic:_f,dragMomentum:_g},_a)};\nVisualElementDragControls.prototype.getAxisMotionValue=function(axis){var _a=this.props,layout=_a.layout;_a=_a.layoutId;var dragKey=\"_drag\"+axis.toUpperCase();if(this.props[dragKey])return this.props[dragKey];if(!layout&&void 0===_a)return this.visualElement.getValue(axis,0)};VisualElementDragControls.prototype.isLayoutDrag=function(){return!this.getAxisMotionValue(\"x\")};VisualElementDragControls.prototype.isExternalDrag=function(){var _a=this.props,_dragY=_a._dragY;return _a._dragX||_dragY};VisualElementDragControls.prototype.animateDragEnd=\nfunction(velocity){var _this=this,_a$jscomp$0=this.props,drag=_a$jscomp$0.drag,dragMomentum=_a$jscomp$0.dragMomentum,dragElastic=_a$jscomp$0.dragElastic,dragTransition=_a$jscomp$0.dragTransition,isRelative=convertToRelativeProjection(this.visualElement,this.isLayoutDrag()&&!this.isExternalDrag()),constraints=this.constraints||{};if(isRelative&&Object.keys(constraints).length&&this.isLayoutDrag()&&(_a$jscomp$0=this.visualElement.getProjectionParent())){var relativeConstraints_1=calcRelativeOffset(_a$jscomp$0.projection.targetFinal,\nconstraints);eachAxis(function(axis){var _a=relativeConstraints_1[axis],min=_a.min;_a=_a.max;constraints[axis]={min:isNaN(min)?void 0:min,max:isNaN(_a)?void 0:_a}})}_a$jscomp$0=eachAxis(function(axis){var _a;if(shouldDrag(axis,drag,_this.currentDirection)){var transition=null!==(_a=null===constraints||void 0===constraints?void 0:constraints[axis])&&void 0!==_a?_a:{};_a=tslib.__assign(tslib.__assign({type:\"inertia\",velocity:dragMomentum?velocity[axis]:0,bounceStiffness:dragElastic?200:1E6,bounceDamping:dragElastic?\n40:1E7,timeConstant:750,restDelta:1,restSpeed:10},dragTransition),transition);return _this.getAxisMotionValue(axis)?_this.startAxisValueAnimation(axis,_a):_this.visualElement.startLayoutAnimation(axis,_a,isRelative)}});return Promise.all(_a$jscomp$0).then(function(){var _a,_b;null===(_b=(_a=_this.props).onDragTransitionEnd)||void 0===_b?void 0:_b.call(_a)})};VisualElementDragControls.prototype.stopMotion=function(){var _this=this;eachAxis(function(axis){(axis=_this.getAxisMotionValue(axis))?axis.stop():\n_this.visualElement.stopLayoutAnimation()})};VisualElementDragControls.prototype.startAxisValueAnimation=function(axis,transition){var axisValue=this.getAxisMotionValue(axis);if(axisValue){var currentValue=axisValue.get();axisValue.set(currentValue);axisValue.set(currentValue);return startAnimation(axis,axisValue,0,transition)}};VisualElementDragControls.prototype.scalePoint=function(){var _this=this,_a=this.props,drag=_a.drag;if(isRefObject(_a.dragConstraints)&&this.constraintsBox){this.stopMotion();\nvar boxProgress={x:0,y:0};eachAxis(function(axis){var JSCompiler_inline_result=_this.visualElement.projection.target[axis];var target=_this.constraintsBox[axis],origin=.5,sourceLength=JSCompiler_inline_result.max-JSCompiler_inline_result.min,targetLength=target.max-target.min;targetLength>sourceLength?origin=popmotion.progress(target.min,target.max-sourceLength,JSCompiler_inline_result.min):sourceLength>targetLength&&(origin=popmotion.progress(JSCompiler_inline_result.min,JSCompiler_inline_result.max-\ntargetLength,target.min));JSCompiler_inline_result=popmotion.clamp(0,1,origin);boxProgress[axis]=JSCompiler_inline_result});this.updateConstraints(function(){eachAxis(function(axis$jscomp$0){if(shouldDrag(axis$jscomp$0,drag,null)){var axis=_this.visualElement.projection.target[axis$jscomp$0],constraints=_this.constraintsBox[axis$jscomp$0];axis=axis.max-axis.min;constraints=popmotion.mix(constraints.min,constraints.max-axis,boxProgress[axis$jscomp$0]);_this.visualElement.setProjectionTargetAxis(axis$jscomp$0,\nconstraints,constraints+axis)}})});setTimeout(flushLayout,1)}};VisualElementDragControls.prototype.updateConstraints=function(onReady){var _this=this;this.cancelLayout=batchLayout(function(read,write){var ancestors=collectProjectingAncestors(_this.visualElement);write(function(){return ancestors.forEach(function(element){return element.resetTransform()})});read(function(){return updateLayoutMeasurement(_this.visualElement)});write(function(){return ancestors.forEach(function(element){return element.restoreTransform()})});\nread(function(){_this.resolveDragConstraints()});onReady&&write(onReady)})};VisualElementDragControls.prototype.mount=function(visualElement){var _this=this,element=visualElement.getInstance(),stopPointerListener=addPointerEvent(element,\"pointerdown\",function(event){var _a=_this.props,_b=_a.dragListener;_a.drag&&(void 0===_b||_b)&&_this.start(event)}),stopResizeListener=addDomEvent(window,\"resize\",function(){_this.scalePoint()}),stopLayoutUpdateListener=visualElement.onLayoutUpdate(function(){_this.isDragging&&\n_this.resolveDragConstraints()});(visualElement=visualElement.prevDragCursor)&&this.start(lastPointerEvent,{cursorProgress:visualElement});return function(){null===stopPointerListener||void 0===stopPointerListener?void 0:stopPointerListener();null===stopResizeListener||void 0===stopResizeListener?void 0:stopResizeListener();null===stopLayoutUpdateListener||void 0===stopLayoutUpdateListener?void 0:stopLayoutUpdateListener();_this.cancelDrag()}};return VisualElementDragControls}(),drag={pan:makeRenderlessComponent(function(_a){function onPointerDown(event){panSession.current=\nnew PanSession(event,handlers,{transformPagePoint:transformPagePoint})}var onPan=_a.onPan,onPanStart=_a.onPanStart,onPanEnd=_a.onPanEnd,onPanSessionStart=_a.onPanSessionStart;_a=_a.visualElement;var hasPanEvents=onPan||onPanStart||onPanEnd||onPanSessionStart,panSession=React.useRef(null),transformPagePoint=React.useContext(MotionConfigContext).transformPagePoint,handlers={onSessionStart:onPanSessionStart,onStart:onPanStart,onMove:onPan,onEnd:function(event,info){panSession.current=null;onPanEnd&&\nonPanEnd(event,info)}};React.useEffect(function(){null!==panSession.current&&panSession.current.updateHandlers(handlers)});usePointerEvent(_a,\"pointerdown\",hasPanEvents&&onPointerDown);useUnmountEffect(function(){return panSession.current&&panSession.current.end()})}),drag:makeRenderlessComponent(function(props){var groupDragControls=props.dragControls,visualElement=props.visualElement,transformPagePoint=React.useContext(MotionConfigContext).transformPagePoint,dragControls=useConstant(function(){return new VisualElementDragControls({visualElement:visualElement})});\ndragControls.setProps(tslib.__assign(tslib.__assign({},props),{transformPagePoint:transformPagePoint}));React.useEffect(function(){return groupDragControls&&groupDragControls.subscribe(dragControls)},[dragControls]);React.useEffect(function(){return dragControls.mount(visualElement)},[])})},Presence;(function(Presence){Presence[Presence.Entering=0]=\"Entering\";Presence[Presence.Present=1]=\"Present\";Presence[Presence.Exiting=2]=\"Exiting\"})(Presence||(Presence={}));exports.VisibilityAction=void 0;(function(VisibilityAction){VisibilityAction[VisibilityAction.Hide=\n0]=\"Hide\";VisibilityAction[VisibilityAction.Show=1]=\"Show\"})(exports.VisibilityAction||(exports.VisibilityAction={}));var cssVariableRegex=/var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/,borderCorrectionDefinition={process:function(latest,_layoutState,_a){_a=_a.target;if(\"string\"===typeof latest)if(styleValueTypes.px.test(latest))latest=parseFloat(latest);else return latest;_layoutState=_a.x;_a=_a.y;return latest/(_layoutState.max-_layoutState.min)*100+\"% \"+latest/(_a.max-_a.min)*100+\"%\"}},\ndefaultScaleCorrectors={borderRadius:tslib.__assign(tslib.__assign({},borderCorrectionDefinition),{applyTo:[\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\"]}),borderTopLeftRadius:borderCorrectionDefinition,borderTopRightRadius:borderCorrectionDefinition,borderBottomLeftRadius:borderCorrectionDefinition,borderBottomRightRadius:borderCorrectionDefinition,boxShadow:{process:function(latest,_a){var delta=_a.delta,treeScale=_a.treeScale,original=latest;_a=\nlatest.includes(\"var(\");var cssVariables=[];_a&&(latest=latest.replace(cssVariableRegex,function(match){cssVariables.push(match);return\"_$css\"}));var shadow=styleValueTypes.complex.parse(latest);if(5<shadow.length)return original;latest=styleValueTypes.complex.createTransformer(latest);original=\"number\"!==typeof shadow[0]?1:0;var xScale=delta.x.scale*treeScale.x;delta=delta.y.scale*treeScale.y;shadow[0+original]/=xScale;shadow[1+original]/=delta;delta=popmotion.mix(xScale,delta,.5);\"number\"===typeof shadow[2+\noriginal]&&(shadow[2+original]/=delta);\"number\"===typeof shadow[3+original]&&(shadow[3+original]/=delta);shadow=latest(shadow);if(_a){var i_1=0;shadow=shadow.replace(\"_$css\",function(){var cssVariable=cssVariables[i_1];i_1++;return cssVariable})}return shadow}}},Animate=function(_super){function Animate(){var _this=null!==_super&&_super.apply(this,arguments)||this;_this.frameTarget=axisBox();_this.currentAnimationTarget=axisBox();_this.isAnimating={x:!1,y:!1};_this.stopAxisAnimation={x:void 0,y:void 0};\n_this.isAnimatingTree=!1;_this.animate=function(target,origin,_a$jscomp$0){void 0===_a$jscomp$0&&(_a$jscomp$0={});var originBox=_a$jscomp$0.originBox,targetBox=_a$jscomp$0.targetBox,visibilityAction=_a$jscomp$0.visibilityAction,shouldStackAnimate=_a$jscomp$0.shouldStackAnimate,onComplete=_a$jscomp$0.onComplete,prevParent=_a$jscomp$0.prevParent,config=tslib.__rest(_a$jscomp$0,\"originBox targetBox visibilityAction shouldStackAnimate onComplete prevParent\".split(\" \"));_a$jscomp$0=_this.props;var visualElement=\n_a$jscomp$0.visualElement,layout=_a$jscomp$0.layout;if(!1===shouldStackAnimate)return _this.isAnimatingTree=!1,_this.safeToRemove();if(!_this.isAnimatingTree||!0===shouldStackAnimate){shouldStackAnimate&&(_this.isAnimatingTree=!0);origin=originBox||origin;target=targetBox||target;var isRelative=!1;if(shouldStackAnimate=visualElement.getProjectionParent()){_a$jscomp$0=shouldStackAnimate.prevViewportBox;var parentLayout=shouldStackAnimate.getLayoutState().layout;prevParent&&(targetBox&&(parentLayout=\nprevParent.getLayoutState().layout),originBox&&!checkIfParentHasChanged(prevParent,shouldStackAnimate)&&prevParent.prevViewportBox&&(_a$jscomp$0=prevParent.prevViewportBox));!_a$jscomp$0||!prevParent&&(prevParent||originBox||targetBox)||(isRelative=!0,origin=calcRelativeOffset(_a$jscomp$0,origin),target=calcRelativeOffset(parentLayout,target))}var boxHasMoved=hasMoved(origin,target);originBox=eachAxis(function(axis){var _a,_b;\"position\"===layout&&(origin[axis].max=origin[axis].min+(target[axis].max-\ntarget[axis].min));if(!visualElement.projection.isTargetLocked)if(void 0!==visibilityAction)visualElement.setVisibility(visibilityAction===exports.VisibilityAction.Show);else{if(boxHasMoved)return _this.animateAxis(axis,target[axis],origin[axis],tslib.__assign(tslib.__assign({},config),{isRelative:isRelative}));null===(_b=(_a=_this.stopAxisAnimation)[axis])||void 0===_b?void 0:_b.call(_a);return visualElement.setProjectionTargetAxis(axis,target[axis].min,target[axis].max,isRelative)}});visualElement.syncRender();\nreturn Promise.all(originBox).then(function(){_this.isAnimatingTree=!1;onComplete&&onComplete();visualElement.notifyLayoutAnimationComplete()})}};return _this}tslib.__extends(Animate,_super);Animate.prototype.componentDidMount=function(){var _this=this,visualElement=this.props.visualElement;visualElement.animateMotionValue=startAnimation;visualElement.enableLayoutProjection();this.unsubLayoutReady=visualElement.onLayoutUpdate(this.animate);visualElement.layoutSafeToRemove=function(){return _this.safeToRemove()};\naddScaleCorrection(defaultScaleCorrectors)};Animate.prototype.componentWillUnmount=function(){var _this=this;this.unsubLayoutReady();eachAxis(function(axis){var _a,_b;return null===(_b=(_a=_this.stopAxisAnimation)[axis])||void 0===_b?void 0:_b.call(_a)})};Animate.prototype.animateAxis=function(axis,target,origin,_a){var _this=this,_b,_c,_d=void 0===_a?{}:_a;_a=_d.transition;var isRelative=_d.isRelative;if(!this.isAnimating[axis]||!axisIsEqual(target,this.currentAnimationTarget[axis])){null===(_c=\n(_b=this.stopAxisAnimation)[axis])||void 0===_c?void 0:_c.call(_b);this.isAnimating[axis]=!0;var visualElement=this.props.visualElement,frameTarget=this.frameTarget[axis],layoutProgress=visualElement.getProjectionAnimationProgress()[axis];layoutProgress.clearListeners();layoutProgress.set(0);layoutProgress.set(0);_b=function(){var p=layoutProgress.get()/1E3;frameTarget.min=popmotion.mix(origin.min,target.min,p);frameTarget.max=popmotion.mix(origin.max,target.max,p);visualElement.setProjectionTargetAxis(axis,\nframeTarget.min,frameTarget.max,isRelative)};_b();var unsubscribeProgress=layoutProgress.onChange(_b);this.stopAxisAnimation[axis]=function(){_this.isAnimating[axis]=!1;layoutProgress.stop();unsubscribeProgress()};this.currentAnimationTarget[axis]=target;_b=_a||visualElement.getDefaultTransition()||defaultLayoutTransition;return startAnimation(\"x\"===axis?\"layoutX\":\"layoutY\",layoutProgress,1E3,_b&&getValueTransition(_b,\"layout\")).then(this.stopAxisAnimation[axis])}};Animate.prototype.safeToRemove=\nfunction(){var _a,_b;null===(_b=(_a=this.props).safeToRemove)||void 0===_b?void 0:_b.call(_a)};Animate.prototype.render=function(){return null};return Animate}(React__namespace.Component),zeroAxis={min:0,max:0},defaultLayoutTransition={duration:.45,ease:[.4,0,.1,1]},defaultHandler={layoutReady:function(child){return child.notifyLayoutReady()}},SharedLayoutContext=React.createContext(createBatcher()),FramerTreeLayoutContext=React.createContext(createBatcher()),Measure=function(_super){function Measure(){return null!==\n_super&&_super.apply(this,arguments)||this}tslib.__extends(Measure,_super);Measure.prototype.componentDidMount=function(){var _a=this.props,syncLayout=_a.syncLayout,framerSyncLayout=_a.framerSyncLayout,visualElement=_a.visualElement;syncLayout.forceUpdate&&syncLayout.register(visualElement);framerSyncLayout.forceUpdate&&framerSyncLayout.register(visualElement);visualElement.onUnmount(function(){syncLayout.forceUpdate&&syncLayout.remove(visualElement);framerSyncLayout.forceUpdate&&framerSyncLayout.remove(visualElement)})};\nMeasure.prototype.getSnapshotBeforeUpdate=function(){var _a=this.props,syncLayout=_a.syncLayout;_a=_a.visualElement;syncLayout.forceUpdate?syncLayout.syncUpdate():(snapshotViewportBox(_a),syncLayout.add(_a));return null};Measure.prototype.componentDidUpdate=function(){var syncLayout=this.props.syncLayout;syncLayout.forceUpdate||syncLayout.flush()};Measure.prototype.render=function(){return null};return Measure}(React__default[\"default\"].Component),layoutAnimations={measureLayout:function(props){var syncLayout=\nReact.useContext(SharedLayoutContext),framerSyncLayout=React.useContext(FramerTreeLayoutContext);return React__default[\"default\"].createElement(Measure,tslib.__assign({},props,{syncLayout:syncLayout,framerSyncLayout:framerSyncLayout}))},layoutAnimation:function(props){var safeToRemove=tslib.__read(usePresence(),2)[1];return React__namespace.createElement(Animate,tslib.__assign({},props,{safeToRemove:safeToRemove}))}},zeroLayout=createLayoutState(),identityProjection=buildLayoutProjectionTransform(zeroLayout.delta,\nzeroLayout.treeScale,{x:1,y:1}),names=\"LayoutMeasure BeforeLayoutMeasure LayoutUpdate ViewportBoxUpdate Update Render AnimationComplete LayoutAnimationComplete AnimationStart SetAxisTarget Unmount\".split(\" \"),FlatTree=function(){function FlatTree(){this.children=[];this.isDirty=!1}FlatTree.prototype.add=function(child){addUniqueItem(this.children,child);this.isDirty=!0};FlatTree.prototype.remove=function(child){var arr=this.children;child=arr.indexOf(child);-1<child&&arr.splice(child,1);this.isDirty=\n!0};FlatTree.prototype.forEach=function(callback){this.isDirty&&this.children.sort(compareByDepth);this.isDirty=!1;this.children.forEach(callback)};return FlatTree}(),visualElement=function(_a$jscomp$2){var _b=_a$jscomp$2.treeType,treeType=void 0===_b?\"\":_b,build=_a$jscomp$2.build,getBaseTarget=_a$jscomp$2.getBaseTarget,makeTargetAnimatable=_a$jscomp$2.makeTargetAnimatable,measureViewportBox=_a$jscomp$2.measureViewportBox,renderInstance=_a$jscomp$2.render,readValueFromInstance=_a$jscomp$2.readValueFromInstance,\nresetTransform=_a$jscomp$2.resetTransform,restoreTransform=_a$jscomp$2.restoreTransform,removeValueFromRenderState=_a$jscomp$2.removeValueFromRenderState,sortNodePosition=_a$jscomp$2.sortNodePosition,scrapeMotionValuesFromProps=_a$jscomp$2.scrapeMotionValuesFromProps;return function(_a$jscomp$1,options){function render(){instance&&(element.isProjectionReady()&&(applyBoxTransforms(leadProjection.targetFinal,leadProjection.target,leadLatestValues),updateBoxDelta(layoutState.deltaFinal,layoutState.layoutCorrected,\nleadProjection.targetFinal,latestValues)),triggerBuild(),renderInstance(instance,renderState))}function triggerBuild(){var valuesToRender=latestValues;if(crossfader&&crossfader.isActive()){var crossfadedValues=crossfader.getCrossfadeState(element);crossfadedValues&&(valuesToRender=crossfadedValues)}build(element,renderState,valuesToRender,leadProjection,layoutState,options,props)}function update(){lifecycles.notifyUpdate(latestValues)}function updateTreeLayoutProjection(){element.layoutTree.forEach(fireUpdateLayoutProjection)}\nfunction bindToMotionValue(key,value){var removeOnChange=value.onChange(function(latestValue){latestValues[key]=latestValue;props.onUpdate&&sync__default[\"default\"].update(update,!1,!0)}),removeOnRenderRequest=value.onRenderRequest(element.scheduleRender);valueSubscriptions.set(key,function(){removeOnChange();removeOnRenderRequest()})}var parent=_a$jscomp$1.parent,props=_a$jscomp$1.props,presenceId=_a$jscomp$1.presenceId,blockInitialAnimation=_a$jscomp$1.blockInitialAnimation;_a$jscomp$1=_a$jscomp$1.visualState;\nvoid 0===options&&(options={});var latestValues=_a$jscomp$1.latestValues,renderState=_a$jscomp$1.renderState,instance,lifecycles=createLifecycles(),projection={isEnabled:!1,isHydrated:!1,isTargetLocked:!1,target:axisBox(),targetFinal:axisBox()},projectionParent,leadProjection=projection,leadLatestValues=latestValues,unsubscribeFromLeadVisualElement,layoutState=createLayoutState(),crossfader,hasViewportBoxUpdated=!1,values=new Map,valueSubscriptions=new Map,prevMotionValues={},projectionTargetProgress,\nbaseTarget=tslib.__assign({},latestValues),removeFromVariantTree;_a$jscomp$1=scrapeMotionValuesFromProps(props);for(var key$jscomp$0 in _a$jscomp$1){var value$jscomp$0=_a$jscomp$1[key$jscomp$0];void 0!==latestValues[key$jscomp$0]&&isMotionValue(value$jscomp$0)&&value$jscomp$0.set(latestValues[key$jscomp$0],!1)}var isControllingVariants=checkIfControllingVariants(props),isVariantNode=checkIfVariantNode(props),element=tslib.__assign(tslib.__assign({treeType:treeType,current:null,depth:parent?parent.depth+\n1:0,parent:parent,children:new Set,path:parent?tslib.__spreadArray(tslib.__spreadArray([],tslib.__read(parent.path)),[parent]):[],layoutTree:parent?parent.layoutTree:new FlatTree,presenceId:presenceId,projection:projection,variantChildren:isVariantNode?new Set:void 0,isVisible:void 0,manuallyAnimateOnMount:!(null===parent||void 0===parent||!parent.isMounted()),blockInitialAnimation:blockInitialAnimation,isMounted:function(){return!!instance},mount:function(newInstance){instance=element.current=newInstance;\nelement.pointTo(element);isVariantNode&&parent&&!isControllingVariants&&(removeFromVariantTree=null===parent||void 0===parent?void 0:parent.addVariantChild(element));null===parent||void 0===parent?void 0:parent.children.add(element)},unmount:function(){sync.cancelSync.update(update);sync.cancelSync.render(render);sync.cancelSync.preRender(element.updateLayoutProjection);valueSubscriptions.forEach(function(remove){return remove()});element.stopLayoutAnimation();element.layoutTree.remove(element);null===\nremoveFromVariantTree||void 0===removeFromVariantTree?void 0:removeFromVariantTree();null===parent||void 0===parent?void 0:parent.children.delete(element);null===unsubscribeFromLeadVisualElement||void 0===unsubscribeFromLeadVisualElement?void 0:unsubscribeFromLeadVisualElement();lifecycles.clearAllListeners()},addVariantChild:function(child){var _a,closestVariantNode=element.getClosestVariantNode();if(closestVariantNode)return null===(_a=closestVariantNode.variantChildren)||void 0===_a?void 0:_a.add(child),\nfunction(){return closestVariantNode.variantChildren.delete(child)}},sortNodePosition:function(other){return sortNodePosition&&treeType===other.treeType?sortNodePosition(element.getInstance(),other.getInstance()):0},getClosestVariantNode:function(){return isVariantNode?element:null===parent||void 0===parent?void 0:parent.getClosestVariantNode()},scheduleUpdateLayoutProjection:parent?parent.scheduleUpdateLayoutProjection:function(){return sync__default[\"default\"].preRender(element.updateTreeLayoutProjection,\n!1,!0)},getLayoutId:function(){return props.layoutId},getInstance:function(){return instance},getStaticValue:function(key){return latestValues[key]},setStaticValue:function(key,value){return latestValues[key]=value},getLatestValues:function(){return latestValues},setVisibility:function(visibility){element.isVisible!==visibility&&(element.isVisible=visibility,element.scheduleRender())},makeTargetAnimatable:function(target,canMutate){void 0===canMutate&&(canMutate=!0);return makeTargetAnimatable(element,\ntarget,props,canMutate)},addValue:function(key,value){element.hasValue(key)&&element.removeValue(key);values.set(key,value);latestValues[key]=value.get();bindToMotionValue(key,value)},removeValue:function(key){var _a;values.delete(key);null===(_a=valueSubscriptions.get(key))||void 0===_a?void 0:_a();valueSubscriptions.delete(key);delete latestValues[key];removeValueFromRenderState(key,renderState)},hasValue:function(key){return values.has(key)},getValue:function(key,defaultValue){var value=values.get(key);\nvoid 0===value&&void 0!==defaultValue&&(value=motionValue(defaultValue),element.addValue(key,value));return value},forEachValue:function(callback){return values.forEach(callback)},readValue:function(key){var _a;return null!==(_a=latestValues[key])&&void 0!==_a?_a:readValueFromInstance(instance,key,options)},setBaseTarget:function(key,value){baseTarget[key]=value},getBaseTarget:function(key){if(getBaseTarget){var target=getBaseTarget(props,key);if(void 0!==target&&!isMotionValue(target))return target}return baseTarget[key]}},\nlifecycles),{build:function(){triggerBuild();return renderState},scheduleRender:function(){sync__default[\"default\"].render(render,!1,!0)},syncRender:render,setProps:function(newProps){props=newProps;lifecycles.updatePropListeners(newProps);newProps=element;var next=scrapeMotionValuesFromProps(props),prev=prevMotionValues,_a,key;for(key in next){var nextValue=next[key],prevValue=prev[key];isMotionValue(nextValue)?newProps.addValue(key,nextValue):isMotionValue(prevValue)?newProps.addValue(key,motionValue(nextValue)):\nprevValue!==nextValue&&(newProps.hasValue(key)?(prevValue=newProps.getValue(key),!prevValue.hasAnimated&&prevValue.set(nextValue)):newProps.addValue(key,motionValue(null!==(_a=newProps.getStaticValue(key))&&void 0!==_a?_a:nextValue)))}for(key in prev)void 0===next[key]&&newProps.removeValue(key);prevMotionValues=next},getProps:function(){return props},getVariant:function(name){var _a;return null===(_a=props.variants)||void 0===_a?void 0:_a[name]},getDefaultTransition:function(){return props.transition},\ngetVariantContext:function(startAtParent){void 0===startAtParent&&(startAtParent=!1);if(startAtParent)return null===parent||void 0===parent?void 0:parent.getVariantContext();if(!isControllingVariants)return startAtParent=(null===parent||void 0===parent?void 0:parent.getVariantContext())||{},void 0!==props.initial&&(startAtParent.initial=props.initial),startAtParent;startAtParent={};for(var i=0;i<numVariantProps;i++){var name_1=variantProps[i],prop=props[name_1];if(isVariantLabel(prop)||!1===prop)startAtParent[name_1]=\nprop}return startAtParent},enableLayoutProjection:function(){projection.isEnabled=!0;element.layoutTree.add(element)},lockProjectionTarget:function(){projection.isTargetLocked=!0},unlockProjectionTarget:function(){element.stopLayoutAnimation();projection.isTargetLocked=!1},getLayoutState:function(){return layoutState},setCrossfader:function(newCrossfader){crossfader=newCrossfader},isProjectionReady:function(){return projection.isEnabled&&projection.isHydrated&&layoutState.isHydrated},startLayoutAnimation:function(axis,\ntransition,isRelative){void 0===isRelative&&(isRelative=!1);var progress=element.getProjectionAnimationProgress()[axis],_a=isRelative?projection.relativeTarget[axis]:projection.target[axis],min=_a.min,length=_a.max-min;progress.clearListeners();progress.set(min);progress.set(min);progress.onChange(function(v){element.setProjectionTargetAxis(axis,v,v+length,isRelative)});return element.animateMotionValue(axis,progress,0,transition)},stopLayoutAnimation:function(){eachAxis(function(axis){return element.getProjectionAnimationProgress()[axis].stop()})},\nmeasureViewportBox:function(withTransform){void 0===withTransform&&(withTransform=!0);var viewportBox=measureViewportBox(instance,options);withTransform||removeBoxTransforms(viewportBox,latestValues);return viewportBox},getProjectionAnimationProgress:function(){projectionTargetProgress||(projectionTargetProgress={x:motionValue(0),y:motionValue(0)});return projectionTargetProgress},setProjectionTargetAxis:function(axis,min,max,isRelative){void 0===isRelative&&(isRelative=!1);isRelative?(projection.relativeTarget||\n(projection.relativeTarget=axisBox()),axis=projection.relativeTarget[axis]):(projection.relativeTarget=void 0,axis=projection.target[axis]);projection.isHydrated=!0;axis.min=min;axis.max=max;hasViewportBoxUpdated=!0;lifecycles.notifySetAxisTarget()},rebaseProjectionTarget:function(force,box){void 0===box&&(box=layoutState.layout);var _a$jscomp$0=element.getProjectionAnimationProgress(),x=_a$jscomp$0.x;_a$jscomp$0=_a$jscomp$0.y;x=!projection.relativeTarget&&!projection.isTargetLocked&&!x.isAnimating()&&\n!_a$jscomp$0.isAnimating();(force||x)&&eachAxis(function(axis){var _a=box[axis];element.setProjectionTargetAxis(axis,_a.min,_a.max)})},notifyLayoutReady:function(config){setCurrentViewportBox(element);element.notifyLayoutUpdate(layoutState.layout,element.prevViewportBox||layoutState.layout,config)},resetTransform:function(){return resetTransform(element,instance,props)},restoreTransform:function(){return restoreTransform(instance,renderState)},updateLayoutProjection:function(){if(element.isProjectionReady()){var delta=\nlayoutState.delta,treeScale=layoutState.treeScale,prevTreeScaleX=treeScale.x,prevTreeScaleY=treeScale.y,prevDeltaTransform=layoutState.deltaTransform,treePath=element.path,transformOrigin=latestValues,delta$jscomp$0=layoutState.delta,layoutCorrected=layoutState.layoutCorrected,treeScale$jscomp$0=layoutState.treeScale,target=leadProjection.target,originBox=layoutState.layout,axis=layoutCorrected.x,originAxis=originBox.x;axis.min=originAxis.min;axis.max=originAxis.max;axis=layoutCorrected.y;originBox=\noriginBox.y;axis.min=originBox.min;axis.max=originBox.max;if(originBox=treePath.length)for(treeScale$jscomp$0.x=treeScale$jscomp$0.y=1,originAxis=0;originAxis<originBox;originAxis++){axis=treePath[originAxis];var delta$jscomp$1=axis.getLayoutState().delta;treeScale$jscomp$0.x*=delta$jscomp$1.x.scale;treeScale$jscomp$0.y*=delta$jscomp$1.y.scale;var box=layoutCorrected,x=delta$jscomp$1.x;delta$jscomp$1=delta$jscomp$1.y;applyAxisDelta(box.x,x.translate,x.scale,x.originPoint);applyAxisDelta(box.y,delta$jscomp$1.translate,\ndelta$jscomp$1.scale,delta$jscomp$1.originPoint);isDraggable(axis)&&applyBoxTransforms(layoutCorrected,layoutCorrected,axis.getLatestValues())}updateBoxDelta(delta$jscomp$0,layoutCorrected,target,transformOrigin);hasViewportBoxUpdated&&element.notifyViewportBoxUpdate(leadProjection.target,delta);hasViewportBoxUpdated=!1;delta=buildLayoutProjectionTransform(delta,treeScale);delta===prevDeltaTransform&&prevTreeScaleX===treeScale.x&&prevTreeScaleY===treeScale.y||element.scheduleRender();layoutState.deltaTransform=\ndelta}},updateTreeLayoutProjection:function(){element.layoutTree.forEach(fireResolveRelativeTargetBox);sync__default[\"default\"].preRender(updateTreeLayoutProjection,!1,!0)},getProjectionParent:function(){if(void 0===projectionParent){for(var foundParent=!1,i=element.path.length-1;0<=i;i--){var ancestor=element.path[i];if(ancestor.projection.isEnabled){foundParent=ancestor;break}}projectionParent=foundParent}return projectionParent},resolveRelativeTargetBox:function(){var relativeParent=element.getProjectionParent();\nif(projection.relativeTarget&&relativeParent){var parentProjection=relativeParent.projection,target=projection.target.x,relative=projection.relativeTarget.x;target.min=parentProjection.target.x.min+relative.min;target.max=target.min+(relative.max-relative.min);target=projection.target.y;relative=projection.relativeTarget.y;target.min=parentProjection.target.y.min+relative.min;target.max=target.min+(relative.max-relative.min);isDraggable(relativeParent)&&(parentProjection=projection.target,applyBoxTransforms(parentProjection,\nparentProjection,relativeParent.getLatestValues()))}},shouldResetTransform:function(){return!!props._layoutResetTransform},pointTo:function(newLead){leadProjection=newLead.projection;leadLatestValues=newLead.getLatestValues();null===unsubscribeFromLeadVisualElement||void 0===unsubscribeFromLeadVisualElement?void 0:unsubscribeFromLeadVisualElement();unsubscribeFromLeadVisualElement=popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection),newLead.onLayoutAnimationComplete(function(){var _a;\nelement.isPresent?element.presence=Presence.Present:null===(_a=element.layoutSafeToRemove)||void 0===_a?void 0:_a.call(element)}))},isPresent:!0,presence:Presence.Entering});return element}},variantProps=tslib.__spreadArray([\"initial\"],tslib.__read(variantPriorityOrder)),numVariantProps=variantProps.length,positionalKeys=new Set(\"width height top left right bottom x y\".split(\" \")),isPositionalKey=function(key){return positionalKeys.has(key)},isNumOrPxType=function(v){return v===styleValueTypes.number||\nv===styleValueTypes.px},BoundingBoxDimension;(function(BoundingBoxDimension){BoundingBoxDimension.width=\"width\";BoundingBoxDimension.height=\"height\";BoundingBoxDimension.left=\"left\";BoundingBoxDimension.right=\"right\";BoundingBoxDimension.top=\"top\";BoundingBoxDimension.bottom=\"bottom\"})(BoundingBoxDimension||(BoundingBoxDimension={}));var getTranslateFromMatrix=function(pos2,pos3){return function(_bbox,_a){_bbox=_a.transform;return\"none\"!==_bbox&&_bbox?(_a=_bbox.match(/^matrix3d\\((.+)\\)$/))?parseFloat(_a[1].split(\", \")[pos3]):\n(_bbox=_bbox.match(/^matrix\\((.+)\\)$/))?parseFloat(_bbox[1].split(\", \")[pos2]):0:0}},transformKeys=new Set([\"x\",\"y\",\"z\"]),nonTranslationalTransformKeys=transformProps.filter(function(key){return!transformKeys.has(key)}),positionalValues={width:function(_a){_a=_a.x;return _a.max-_a.min},height:function(_a){_a=_a.y;return _a.max-_a.min},top:function(_bbox,_a){return parseFloat(_a.top)},left:function(_bbox,_a){return parseFloat(_a.left)},bottom:function(_a,_b){_a=_a.y;return parseFloat(_b.top)+(_a.max-\n_a.min)},right:function(_a,_b){_a=_a.x;return parseFloat(_b.left)+(_a.max-_a.min)},x:getTranslateFromMatrix(4,13),y:getTranslateFromMatrix(5,14)},convertChangedValueTypes=function(target,visualElement,changedKeys){var originBbox=visualElement.measureViewportBox(),element=visualElement.getInstance(),elementComputedStyle=getComputedStyle(element),originComputedStyle={top:elementComputedStyle.top,left:elementComputedStyle.left,bottom:elementComputedStyle.bottom,right:elementComputedStyle.right,transform:elementComputedStyle.transform};\n\"none\"===elementComputedStyle.display&&visualElement.setStaticValue(\"display\",target.display||\"block\");visualElement.syncRender();var targetBbox=visualElement.measureViewportBox();changedKeys.forEach(function(key){var value=visualElement.getValue(key),to=positionalValues[key](originBbox,originComputedStyle);value.set(to,!1);value.set(to);target[key]=positionalValues[key](targetBbox,elementComputedStyle)});return target},checkAndConvertChangedValueTypes=function(visualElement,target,origin,transitionEnd){void 0===\norigin&&(origin={});void 0===transitionEnd&&(transitionEnd={});target=tslib.__assign({},target);transitionEnd=tslib.__assign({},transitionEnd);var removedTransformValues=[],hasAttemptedToRemoveTransformValues=!1,changedValueTypeKeys=[];Object.keys(target).filter(isPositionalKey).forEach(function(key){var value=visualElement.getValue(key);if(visualElement.hasValue(key)){var from=origin[key],to=target[key],fromType=dimensionValueTypes.find(testValueType(from));if(Array.isArray(to))for(var numKeyframes=\nto.length,i=null===to[0]?1:0;i<numKeyframes;i++)if(toType)heyListen.invariant(dimensionValueTypes.find(testValueType(to[i]))===toType,\"All keyframes must be of the same type\");else{var toType=dimensionValueTypes.find(testValueType(to[i]));heyListen.invariant(toType===fromType||isNumOrPxType(fromType)&&isNumOrPxType(toType),\"Keyframes must be of the same dimension as the current value\")}else toType=dimensionValueTypes.find(testValueType(to));fromType!==toType&&(isNumOrPxType(fromType)&&isNumOrPxType(toType)?\n(from=value.get(),\"string\"===typeof from&&value.set(parseFloat(from)),\"string\"===typeof to?target[key]=parseFloat(to):Array.isArray(to)&&toType===styleValueTypes.px&&(target[key]=to.map(parseFloat))):(null===fromType||void 0===fromType?0:fromType.transform)&&(null===toType||void 0===toType?0:toType.transform)&&(0===from||0===to)?0===from?value.set(toType.transform(from)):target[key]=fromType.transform(to):(hasAttemptedToRemoveTransformValues||(removedTransformValues=removeNonTranslationalTransform(visualElement),\nhasAttemptedToRemoveTransformValues=!0),changedValueTypeKeys.push(key),transitionEnd[key]=void 0!==transitionEnd[key]?transitionEnd[key]:target[key],value.set(to,!1),value.set(to)))}});if(changedValueTypeKeys.length){var convertedTarget=convertChangedValueTypes(target,visualElement,changedValueTypeKeys);removedTransformValues.length&&removedTransformValues.forEach(function(_a){_a=tslib.__read(_a,2);var value=_a[1];visualElement.getValue(_a[0]).set(value)});visualElement.syncRender();return{target:convertedTarget,\ntransitionEnd:transitionEnd}}return{target:target,transitionEnd:transitionEnd}},htmlConfig={treeType:\"dom\",readValueFromInstance:function(domElement,key){if(transformPropSet.has(key))return(key=defaultValueTypes[key])?key.default||0:0;domElement=window.getComputedStyle(domElement);return(key.startsWith(\"--\")?domElement.getPropertyValue(key):domElement[key])||0},sortNodePosition:function(a,b){return a.compareDocumentPosition(b)&2?1:-1},getBaseTarget:function(props,key){var _a;return null===(_a=props.style)||\nvoid 0===_a?void 0:_a[key]},measureViewportBox:function(element,_a){return getBoundingBox(element,_a.transformPagePoint)},resetTransform:function(element,domElement,props){props=props.transformTemplate;domElement.style.transform=props?props({},\"\"):\"none\";element.scheduleRender()},restoreTransform:function(instance,mutableState){instance.style.transform=mutableState.style.transform},removeValueFromRenderState:function(key,_a){var style=_a.style;delete _a.vars[key];delete style[key]},makeTargetAnimatable:function(element,\n_a,_b,isMounted){var transformValues=_b.transformValues;void 0===isMounted&&(isMounted=!0);_b=_a.transition;var transitionEnd=_a.transitionEnd;_a=tslib.__rest(_a,[\"transition\",\"transitionEnd\"]);var origin=getOrigin(_a,_b||{},element);transformValues&&(transitionEnd&&(transitionEnd=transformValues(transitionEnd)),_a&&(_a=transformValues(_a)),origin&&(origin=transformValues(origin)));isMounted&&(checkTargetForNewValues(element,_a,origin),isMounted=origin,transformValues=resolveCSSVariables(element,\n_a,transitionEnd),transitionEnd=transformValues.target,transformValues=transformValues.transitionEnd,element=Object.keys(transitionEnd).some(isPositionalKey)?checkAndConvertChangedValueTypes(element,transitionEnd,isMounted,transformValues):{target:transitionEnd,transitionEnd:transformValues},transitionEnd=element.transitionEnd,_a=element.target);return tslib.__assign({transition:_b,transitionEnd:transitionEnd},_a)},scrapeMotionValuesFromProps:scrapeMotionValuesFromProps$1,build:function(element,renderState,\nlatestValues,projection,layoutState,options,props){void 0!==element.isVisible&&(renderState.style.visibility=element.isVisible?\"visible\":\"hidden\");element=projection.isEnabled&&layoutState.isHydrated;buildHTMLStyles(renderState,latestValues,projection,layoutState,options,props.transformTemplate,element?buildLayoutProjectionTransform:void 0,element?buildLayoutProjectionTransformOrigin:void 0)},render:renderHTML},htmlVisualElement=visualElement(htmlConfig),svgVisualElement=visualElement(tslib.__assign(tslib.__assign({},\nhtmlConfig),{getBaseTarget:function(props,key){return props[key]},readValueFromInstance:function(domElement,key){var _a;if(transformPropSet.has(key))return(null===(_a=defaultValueTypes[key])||void 0===_a?void 0:_a.default)||0;key=camelCaseAttributes.has(key)?key:key.replace(CAMEL_CASE_PATTERN,\"$1-$2\").toLowerCase();return domElement.getAttribute(key)},scrapeMotionValuesFromProps:scrapeMotionValuesFromProps,build:function(_element,renderState,latestValues,projection,layoutState,options,props){_element=\nprojection.isEnabled&&layoutState.isHydrated;buildSVGAttrs(renderState,latestValues,projection,layoutState,options,props.transformTemplate,_element?buildLayoutProjectionTransform:void 0,_element?buildLayoutProjectionTransformOrigin:void 0)},render:renderSVG})),createDomVisualElement=function(Component,options){return isSVGComponent(Component)?svgVisualElement(options,{enableHardwareAcceleration:!1}):htmlVisualElement(options,{enableHardwareAcceleration:!0})},featureBundle=tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({},\nanimations),gestureAnimations),drag),layoutAnimations),motion=createMotionProxy(function(Component,config){return createDomMotionConfig(Component,config,featureBundle,createDomVisualElement)}),m=createMotionProxy(createDomMotionConfig),presenceId=0,PresenceChild=function(_a){var children=_a.children,initial=_a.initial,isPresent=_a.isPresent,onExitComplete=_a.onExitComplete,custom=_a.custom;_a=_a.presenceAffectsLayout;var presenceChildren=useConstant(newChildrenMap),id=useConstant(getPresenceId);_a=\nReact.useMemo(function(){return{id:id,initial:initial,isPresent:isPresent,custom:custom,onExitComplete:function(childId){presenceChildren.set(childId,!0);var allComplete=!0;presenceChildren.forEach(function(isComplete){isComplete||(allComplete=!1)});allComplete&&(null===onExitComplete||void 0===onExitComplete?void 0:onExitComplete())},register:function(childId){presenceChildren.set(childId,!1);return function(){return presenceChildren.delete(childId)}}}},_a?void 0:[isPresent]);React.useMemo(function(){presenceChildren.forEach(function(_,\nkey){return presenceChildren.set(key,!1)})},[isPresent]);React__namespace.useEffect(function(){!isPresent&&!presenceChildren.size&&(null===onExitComplete||void 0===onExitComplete?void 0:onExitComplete())},[isPresent]);return React__namespace.createElement(PresenceContext.Provider,{value:_a},children)},easeCrossfadeIn=compress(0,.5,popmotion.circOut),easeCrossfadeOut=compress(.5,.95,popmotion.linear),borders=[\"TopLeft\",\"TopRight\",\"BottomLeft\",\"BottomRight\"],numBorders=borders.length,AnimateSharedLayout=\nfunction(_super){function AnimateSharedLayout(){var _this=null!==_super&&_super.apply(this,arguments)||this;_this.children=new Set;_this.stacks=new Map;_this.hasMounted=!1;_this.updateScheduled=!1;_this.renderScheduled=!1;_this.syncContext=tslib.__assign(tslib.__assign({},createBatcher()),{syncUpdate:function(force){return _this.scheduleUpdate(force)},forceUpdate:function(){_this.syncContext=tslib.__assign({},_this.syncContext);_this.scheduleUpdate(!0)},register:function(child){return _this.addChild(child)},\nremove:function(child){return _this.removeChild(child)}});return _this}tslib.__extends(AnimateSharedLayout,_super);AnimateSharedLayout.prototype.componentDidMount=function(){this.hasMounted=!0};AnimateSharedLayout.prototype.componentDidUpdate=function(){this.startLayoutAnimation()};AnimateSharedLayout.prototype.shouldComponentUpdate=function(){return this.renderScheduled=!0};AnimateSharedLayout.prototype.startLayoutAnimation=function(){var _this=this;this.renderScheduled=this.updateScheduled=!1;var type=\nthis.props.type;this.children.forEach(function(child){child.isPresent?child.presence!==Presence.Entering&&(child.presence=child.presence===Presence.Exiting?Presence.Entering:Presence.Present):child.presence=Presence.Exiting});this.updateStacks();var handler={layoutReady:function(child){void 0!==child.getLayoutId()?_this.getStack(child).animate(child,\"crossfade\"===type):child.notifyLayoutReady()},parent:this.context.visualElement};this.children.forEach(function(child){return _this.syncContext.add(child)});\nthis.syncContext.flush(handler);this.stacks.forEach(function(stack){return stack.clearSnapshot()})};AnimateSharedLayout.prototype.updateStacks=function(){this.stacks.forEach(function(stack){return stack.updateLeadAndFollow()})};AnimateSharedLayout.prototype.scheduleUpdate=function(force){void 0===force&&(force=!1);if(force||!this.updateScheduled)if(this.updateScheduled=!0,this.children.forEach(function(child){for(var hasRotate=!1,resetValues={},i=0;i<transformAxes.length;i++){var key=\"rotate\"+transformAxes[i];\nchild.hasValue(key)&&0!==child.getStaticValue(key)&&(hasRotate=!0,resetValues[key]=child.getStaticValue(key),child.setStaticValue(key,0))}if(hasRotate){child.syncRender();for(key in resetValues)child.setStaticValue(key,resetValues[key]);child.scheduleRender()}child.shouldResetTransform()&&child.resetTransform()}),this.children.forEach(snapshotViewportBox),this.stacks.forEach(function(stack){return stack.updateSnapshot()}),force||!this.renderScheduled)this.renderScheduled=!0,this.forceUpdate()};AnimateSharedLayout.prototype.addChild=\nfunction(child){this.children.add(child);this.addToStack(child);child.presence=this.hasMounted?Presence.Entering:Presence.Present};AnimateSharedLayout.prototype.removeChild=function(child){this.scheduleUpdate();this.children.delete(child);this.removeFromStack(child)};AnimateSharedLayout.prototype.addToStack=function(child){var stack=this.getStack(child);null===stack||void 0===stack?void 0:stack.add(child)};AnimateSharedLayout.prototype.removeFromStack=function(child){var stack=this.getStack(child);\nnull===stack||void 0===stack?void 0:stack.remove(child)};AnimateSharedLayout.prototype.getStack=function(child){child=child.getLayoutId();if(void 0!==child)return!this.stacks.has(child)&&this.stacks.set(child,layoutStack()),this.stacks.get(child)};AnimateSharedLayout.prototype.render=function(){return React__namespace.createElement(SharedLayoutContext.Provider,{value:this.syncContext},this.props.children)};AnimateSharedLayout.contextType=MotionContext;return AnimateSharedLayout}(React__namespace.Component),\ndomAnimation=tslib.__assign(tslib.__assign({renderer:createDomVisualElement},animations),gestureAnimations),domMax=tslib.__assign(tslib.__assign(tslib.__assign({},domAnimation),drag),layoutAnimations),getMixer=function(v){return\"object\"===typeof v&&v.mix?v.mix:void 0},getElementScrollOffsets=function(element){return function(){return{xOffset:element.scrollLeft,yOffset:element.scrollTop,xMaxOffset:element.scrollWidth-element.offsetWidth,yMaxOffset:element.scrollHeight-element.offsetHeight}}},viewportScrollValues,\nhasListeners=!1,prefersReducedMotion,DragControls=function(){function DragControls(){this.componentControls=new Set}DragControls.prototype.subscribe=function(controls){var _this=this;this.componentControls.add(controls);return function(){return _this.componentControls.delete(controls)}};DragControls.prototype.start=function(event,options){this.componentControls.forEach(function(controls){controls.start(event.nativeEvent||event,options)})};DragControls.prototype.updateConstraints=function(flush){void 0===\nflush&&(flush=!0);this.componentControls.forEach(function(controls){controls.updateConstraints()});flush&&flushLayout()};return DragControls}(),createDragControls=function(){return new DragControls},createObject=function(){return{}},stateVisualElement=visualElement({build:function(){},measureViewportBox:axisBox,resetTransform:function(){},restoreTransform:function(){},removeValueFromRenderState:function(){},render:function(){},scrapeMotionValuesFromProps:createObject,readValueFromInstance:function(_state,\nkey,options){return options.initialState[key]||0},makeTargetAnimatable:function(element,_a){var transition=_a.transition,transitionEnd=_a.transitionEnd;_a=tslib.__rest(_a,[\"transition\",\"transitionEnd\"]);var origin=getOrigin(_a,transition||{},element);checkTargetForNewValues(element,_a,origin);return tslib.__assign({transition:transition,transitionEnd:transitionEnd},_a)}}),useVisualState=makeUseVisualState({scrapeMotionValuesFromProps:createObject,createRenderState:createObject}),invertScale=function(scale){return.001<\nscale?1/scale:1E5},hasWarned=!1;exports.AnimatePresence=function(_a){var children=_a.children,custom=_a.custom,_b=_a.initial,initial=void 0===_b?!0:_b,onExitComplete=_a.onExitComplete;_b=_a.exitBeforeEnter;_a=_a.presenceAffectsLayout;var presenceAffectsLayout=void 0===_a?!0:_a,forceRender=useForceUpdate();_a=React.useContext(SharedLayoutContext);_a.forceUpdate&&(forceRender=_a.forceUpdate);_a=React.useRef(!0);var filteredChildren=onlyElements(children),presentChildren=React.useRef(filteredChildren),\nallChildren=React.useRef(new Map).current,exiting=React.useRef(new Set).current;updateChildLookup(filteredChildren,allChildren);if(_a.current)return _a.current=!1,React__namespace.createElement(React__namespace.Fragment,null,filteredChildren.map(function(child){return React__namespace.createElement(PresenceChild,{key:getChildKey(child),isPresent:!0,initial:initial?void 0:!1,presenceAffectsLayout:presenceAffectsLayout},child)}));var childrenToRender=tslib.__spreadArray([],tslib.__read(filteredChildren)),\npresentKeys=presentChildren.current.map(getChildKey),targetKeys=filteredChildren.map(getChildKey);children=presentKeys.length;for(_a=0;_a<children;_a++){var key$jscomp$0=presentKeys[_a];-1===targetKeys.indexOf(key$jscomp$0)?exiting.add(key$jscomp$0):exiting.delete(key$jscomp$0)}_b&&exiting.size&&(childrenToRender=[]);exiting.forEach(function(key){if(-1===targetKeys.indexOf(key)){var child=allChildren.get(key);if(child){var insertionIndex=presentKeys.indexOf(key);childrenToRender.splice(insertionIndex,\n0,React__namespace.createElement(PresenceChild,{key:getChildKey(child),isPresent:!1,onExitComplete:function(){allChildren.delete(key);exiting.delete(key);var removeIndex=presentChildren.current.findIndex(function(presentChild){return presentChild.key===key});presentChildren.current.splice(removeIndex,1);exiting.size||(presentChildren.current=filteredChildren,forceRender(),onExitComplete&&onExitComplete())},custom:custom,presenceAffectsLayout:presenceAffectsLayout},child))}}});childrenToRender=childrenToRender.map(function(child){return exiting.has(child.key)?\nchild:React__namespace.createElement(PresenceChild,{key:getChildKey(child),isPresent:!0,presenceAffectsLayout:presenceAffectsLayout},child)});presentChildren.current=childrenToRender;_b&&1<childrenToRender.length&&console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");return React__namespace.createElement(React__namespace.Fragment,null,exiting.size?childrenToRender:childrenToRender.map(function(child){return React.cloneElement(child)}))};\nexports.AnimateSharedLayout=AnimateSharedLayout;exports.DragControls=DragControls;exports.FlatTree=FlatTree;exports.FramerTreeLayoutContext=FramerTreeLayoutContext;exports.LayoutGroupContext=LayoutGroupContext;exports.LazyMotion=function(_a$jscomp$0){var children=_a$jscomp$0.children,features=_a$jscomp$0.features;_a$jscomp$0=_a$jscomp$0.strict;_a$jscomp$0=void 0===_a$jscomp$0?!1:_a$jscomp$0;var setIsLoaded=tslib.__read(React.useState(!isLazyBundle(features)),2)[1],loadedRenderer=React.useRef(void 0);\nif(!isLazyBundle(features)){var renderer=features.renderer,loadedFeatures=tslib.__rest(features,[\"renderer\"]);loadedRenderer.current=renderer;loadFeatures(loadedFeatures)}React.useEffect(function(){isLazyBundle(features)&&features().then(function(_a){var renderer=_a.renderer;_a=tslib.__rest(_a,[\"renderer\"]);loadFeatures(_a);loadedRenderer.current=renderer;setIsLoaded(!0)})},[]);return React__namespace.createElement(LazyContext.Provider,{value:{renderer:loadedRenderer.current,strict:_a$jscomp$0}},\nchildren)};exports.MotionConfig=function(_a){var children=_a.children,config=tslib.__rest(_a,[\"children\"]);config=tslib.__assign(tslib.__assign({},React.useContext(MotionConfigContext)),config);config.isStatic=useConstant(function(){return config.isStatic});_a=React.useMemo(function(){return config},[\"object\"===typeof config.transition?config.transition.toString():\"\",config.transformPagePoint]);return React__namespace.createElement(MotionConfigContext.Provider,{value:_a},children)};exports.MotionConfigContext=\nMotionConfigContext;exports.MotionValue=MotionValue;exports.PresenceContext=PresenceContext;exports.SharedLayoutContext=SharedLayoutContext;exports.addScaleCorrection=addScaleCorrection;exports.animate=animate$jscomp$0;exports.animateVisualElement=animateVisualElement;exports.animationControls=animationControls;exports.batchLayout=batchLayout;exports.createBatcher=createBatcher;exports.createCrossfader=createCrossfader;exports.createDomMotionComponent=function(key){return createMotionComponent(createDomMotionConfig(key,\n{forwardMotionProps:!1},featureBundle,createDomVisualElement))};exports.createMotionComponent=createMotionComponent;exports.domAnimation=domAnimation;exports.domMax=domMax;exports.flushLayout=flushLayout;exports.isValidMotionProp=isValidMotionProp;exports.m=m;exports.motion=motion;exports.motionValue=motionValue;exports.resolveMotionValue=resolveMotionValue;exports.snapshotViewportBox=snapshotViewportBox;exports.transform=transform$jscomp$0;exports.useAnimation=function(){var controls=useConstant(animationControls);\nReact.useEffect(controls.mount,[]);return controls};exports.useCycle=function(){for(var items=[],_i=0;_i<arguments.length;_i++)items[_i]=arguments[_i];var index=React.useRef(0);_i=tslib.__read(React.useState(items[index.current]),2);var setItem=_i[1];return[_i[0],function(next){index.current=\"number\"!==typeof next?popmotion.wrap(0,items.length,index.current+1):next;setItem(items[index.current])}]};exports.useDeprecatedAnimatedState=function(initialState){var _a=tslib.__read(React.useState(initialState),\n2),animationState=_a[0],setAnimationState=_a[1],visualState=useVisualState({},!1),element=useConstant(function(){return stateVisualElement({props:{},visualState:visualState},{initialState:initialState})});React.useEffect(function(){element.mount({});return element.unmount()},[]);React.useEffect(function(){element.setProps({onUpdate:function(v){return setAnimationState(tslib.__assign({},v))}})});_a=useConstant(function(){return function(animationDefinition){return animateVisualElement(element,animationDefinition)}});\nreturn[animationState,_a]};exports.useDeprecatedInvertedScale=function(scale){var parentScaleX=useMotionValue(1),parentScaleY=useMotionValue(1),visualElement=React.useContext(MotionContext).visualElement;heyListen.invariant(!(!scale&&!visualElement),\"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");heyListen.warning(hasWarned,\"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");hasWarned=!0;scale?(parentScaleX=\nscale.scaleX||parentScaleX,parentScaleY=scale.scaleY||parentScaleY):visualElement&&(parentScaleX=visualElement.getValue(\"scaleX\",1),parentScaleY=visualElement.getValue(\"scaleY\",1));scale=useTransform(parentScaleX,invertScale);parentScaleY=useTransform(parentScaleY,invertScale);return{scaleX:scale,scaleY:parentScaleY}};exports.useDomEvent=useDomEvent;exports.useDragControls=function(){return useConstant(createDragControls)};exports.useElementScroll=function(ref){var values=useConstant(createScrollMotionValues);\nuseIsomorphicLayoutEffect(function(){var element=ref.current;heyListen.invariant(!!element,\"ref provided to useScroll must be passed into a HTML element.\");if(element){var updateScrollValues=createScrollUpdater(values,getElementScrollOffsets(element)),scrollListener=addDomEvent(element,\"scroll\",updateScrollValues,{passive:!0}),resizeListener=addDomEvent(element,\"resize\",updateScrollValues);return function(){scrollListener&&scrollListener();resizeListener&&resizeListener()}}},[]);return values};exports.useIsPresent=\nfunction(){var context=React.useContext(PresenceContext);return null===context?!0:context.isPresent};exports.useMotionTemplate=function(fragments){for(var values=[],_i=1;_i<arguments.length;_i++)values[_i-1]=arguments[_i];var numFragments=fragments.length;return useCombineMotionValues(values,function(){for(var output=\"\",i=0;i<numFragments;i++)output+=fragments[i],values[i]&&(output+=values[i].get());return output})};exports.useMotionValue=useMotionValue;exports.usePresence=usePresence;exports.useReducedMotion=\nfunction(){!prefersReducedMotion&&initPrefersReducedMotion();var _a=tslib.__read(React.useState(prefersReducedMotion.get()),2),shouldReduceMotion=_a[0];useOnChange(prefersReducedMotion,_a[1]);return shouldReduceMotion};exports.useSpring=function(source,config){void 0===config&&(config={});var isStatic=React.useContext(MotionConfigContext).isStatic,activeSpringAnimation=React.useRef(null),value=useMotionValue(isMotionValue(source)?source.get():source);React.useMemo(function(){return value.attach(function(v,\nset){if(isStatic)return set(v);activeSpringAnimation.current&&activeSpringAnimation.current.stop();activeSpringAnimation.current=popmotion.animate(tslib.__assign(tslib.__assign({from:value.get(),to:v,velocity:value.getVelocity()},config),{onUpdate:set}));return value.get()})},Object.values(config));useOnChange(source,function(v){return value.set(parseFloat(v))});return value};exports.useTransform=useTransform;exports.useVelocity=function(value){var velocity=useMotionValue(value.getVelocity());React.useEffect(function(){return value.velocityUpdateSubscribers.add(function(newVelocity){velocity.set(newVelocity)})},\n[value]);return velocity};exports.useViewportScroll=function(){viewportScrollValues||(viewportScrollValues=createScrollMotionValues());useIsomorphicLayoutEffect(function(){if(!hasListeners&&(hasListeners=!0,\"undefined\"!==typeof window)){var updateScrollValues=createScrollUpdater(viewportScrollValues,getViewportScrollOffsets);addDomEvent(window,\"scroll\",updateScrollValues,{passive:!0});addDomEvent(window,\"resize\",updateScrollValues)}},[]);return viewportScrollValues};exports.visualElement=visualElement}","~:source","shadow$provide[\"module$node_modules$framer_motion$dist$framer_motion_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar React = require('react');\nvar heyListen = require('hey-listen');\nvar styleValueTypes = require('style-value-types');\nvar popmotion = require('popmotion');\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n['default'] = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nvar createDefinition = function (propNames) { return ({\n    isEnabled: function (props) { return propNames.some(function (name) { return !!props[name]; }); },\n}); };\nvar featureDefinitions = {\n    measureLayout: createDefinition([\n        \"layout\",\n        \"layoutId\",\n        \"drag\",\n        \"_layoutResetTransform\",\n    ]),\n    animation: createDefinition([\n        \"animate\",\n        \"exit\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ]),\n    exit: createDefinition([\"exit\"]),\n    drag: createDefinition([\"drag\", \"dragControls\"]),\n    focus: createDefinition([\"whileFocus\"]),\n    hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n    tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n    pan: createDefinition([\n        \"onPan\",\n        \"onPanStart\",\n        \"onPanSessionStart\",\n        \"onPanEnd\",\n    ]),\n    layoutAnimation: createDefinition([\"layout\", \"layoutId\"]),\n};\nfunction loadFeatures(features) {\n    for (var key in features) {\n        var Component = features[key];\n        if (Component !== null)\n            featureDefinitions[key].Component = Component;\n    }\n}\n\nvar LazyContext = React.createContext({ strict: false });\n\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n    var features = [];\n    var lazyContext = React.useContext(LazyContext);\n    if (!visualElement)\n        return null;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        lazyContext.strict) {\n        heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (var i = 0; i < numFeatures; i++) {\n        var name_1 = featureNames[i];\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\n        /**\n         * It might be possible in the future to use this moment to\n         * dynamically request functionality. In initial tests this\n         * was producing a lot of duplication amongst bundles.\n         */\n        if (isEnabled(props) && Component) {\n            features.push(React__namespace.createElement(Component, tslib.__assign({ key: name_1 }, props, { visualElement: visualElement })));\n        }\n    }\n    return features;\n}\n\n/**\n * @public\n */\nvar MotionConfigContext = React.createContext({\n    transformPagePoint: function (p) { return p; },\n    isStatic: false,\n});\n\nvar MotionContext = React.createContext({});\nfunction useVisualElementContext() {\n    return React.useContext(MotionContext).visualElement;\n}\n\n/**\n * @public\n */\nvar PresenceContext = React.createContext(null);\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n    var context = React.useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useOpaqueId when released in React\n    var id = useUniqueId();\n    React.useEffect(function () { return register(id); }, []);\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\nvar counter = 0;\nvar incrementId = function () { return counter++; };\nvar useUniqueId = function () { return useConstant(incrementId); };\n\n/**\n * @internal\n */\nvar LayoutGroupContext = React.createContext(null);\n\nvar isBrowser = typeof window !== \"undefined\";\n\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n\nfunction useLayoutId(_a) {\n    var layoutId = _a.layoutId;\n    var layoutGroupId = React.useContext(LayoutGroupContext);\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    var config = React.useContext(MotionConfigContext);\n    var lazyContext = React.useContext(LazyContext);\n    var parent = useVisualElementContext();\n    var presenceContext = React.useContext(PresenceContext);\n    var layoutId = useLayoutId(props);\n    var visualElementRef = React.useRef(undefined);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    if (!createVisualElement)\n        createVisualElement = lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState: visualState,\n            parent: parent,\n            props: tslib.__assign(tslib.__assign({}, props), { layoutId: layoutId }),\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\n        });\n    }\n    var visualElement = visualElementRef.current;\n    useIsomorphicLayoutEffect(function () {\n        if (!visualElement)\n            return;\n        visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), { layoutId: layoutId }));\n        visualElement.isPresent = isPresent(presenceContext);\n        visualElement.isPresenceRoot =\n            !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n        /**\n         * Fire a render to ensure the latest state is reflected on-screen.\n         */\n        visualElement.syncRender();\n    });\n    React.useEffect(function () {\n        var _a;\n        if (!visualElement)\n            return;\n        /**\n         * In a future refactor we can replace the features-as-components and\n         * have this loop through them all firing \"effect\" listeners\n         */\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n    });\n    useIsomorphicLayoutEffect(function () { return function () { return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount(); }; }, []);\n    return visualElement;\n}\n\nfunction isRefObject(ref) {\n    return (typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback(function (instance) {\n        var _a;\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n        if (visualElement) {\n            instance\n                ? visualElement.mount(instance)\n                : visualElement.unmount();\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n/**\n * Decides if the supplied variable is an array of variant labels\n */\nfunction isVariantLabels(v) {\n    return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    var current = {};\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity$1(visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\n    return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n    var _a;\n    if (currentValues === void 0) { currentValues = {}; }\n    if (currentVelocity === void 0) { currentVelocity = {}; }\n    if (typeof definition === \"string\") {\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n    }\n    return typeof definition === \"function\"\n        ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)\n        : definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    var props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n    var _a;\n    return (typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" ||\n        isVariantLabel(props.initial) ||\n        isVariantLabel(props.animate) ||\n        isVariantLabel(props.whileHover) ||\n        isVariantLabel(props.whileDrag) ||\n        isVariantLabel(props.whileTap) ||\n        isVariantLabel(props.whileFocus) ||\n        isVariantLabel(props.exit));\n}\nfunction checkIfVariantNode(props) {\n    return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\nfunction getCurrentTreeVariants(props, context) {\n    if (checkIfControllingVariants(props)) {\n        var initial = props.initial, animate = props.animate;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props, isStatic) {\n    var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)), initial = _a.initial, animate = _a.animate;\n    return React.useMemo(function () { return ({ initial: initial, animate: animate }); }, \n    /**\n     * Only break memoisation in static mode\n     */\n    isStatic\n        ? [\n            variantLabelsAsDependency(initial),\n            variantLabelsAsDependency(animate),\n        ]\n        : []);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var isStatic = React.useContext(MotionConfigContext).isStatic;\n        var features = null;\n        /**\n         * Create the tree context. This is memoized and will only trigger renders\n         * when the current tree variant changes in static mode.\n         */\n        var context = useCreateMotionContext(props, isStatic);\n        /**\n         *\n         */\n        var visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             *\n             * TODO: The intention is to move these away from a React-centric to a\n             * VisualElement-centric lifecycle scheme.\n             */\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (React__namespace.createElement(React__namespace.Fragment, null,\n            React__namespace.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\n            features));\n    }\n    return React.forwardRef(MotionComponent);\n}\n\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\nfunction createMotionProxy(createConfig) {\n    function custom(Component, customMotionComponentConfig) {\n        if (customMotionComponentConfig === void 0) { customMotionComponentConfig = {}; }\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    var componentCache = new Map();\n    return new Proxy(custom, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: function (_target, key) {\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, custom(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nvar lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nvar valueScaleCorrection = {};\n/**\n * @internal\n */\nfunction addScaleCorrection(correctors) {\n    for (var key in correctors) {\n        valueScaleCorrection[key] = correctors[key];\n    }\n}\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n    return transformAxes.forEach(function (axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nfunction isForcedMotionValue(key, _a) {\n    var layout = _a.layout, layoutId = _a.layoutId;\n    return (isTransformProp(key) ||\n        isTransformOriginProp(key) ||\n        ((layout || layoutId !== undefined) &&\n            (!!valueScaleCorrection[key] || key === \"opacity\")));\n}\n\nvar isMotionValue = function (value) {\n    return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n    var transform = _a.transform, transformKeys = _a.transformKeys;\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n    // The transform string we're going to build into.\n    var transformString = \"\";\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        if (key === \"z\")\n            transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    }\n    else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\nfunction buildTransformOrigin(_a) {\n    var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n    return originX + \" \" + originY + \" \" + originZ;\n}\n\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable$1(key) {\n    return key.startsWith(\"--\");\n}\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), { transform: Math.round });\n\nvar numberValueTypes = {\n    // Border props\n    borderWidth: styleValueTypes.px,\n    borderTopWidth: styleValueTypes.px,\n    borderRightWidth: styleValueTypes.px,\n    borderBottomWidth: styleValueTypes.px,\n    borderLeftWidth: styleValueTypes.px,\n    borderRadius: styleValueTypes.px,\n    radius: styleValueTypes.px,\n    borderTopLeftRadius: styleValueTypes.px,\n    borderTopRightRadius: styleValueTypes.px,\n    borderBottomRightRadius: styleValueTypes.px,\n    borderBottomLeftRadius: styleValueTypes.px,\n    // Positioning props\n    width: styleValueTypes.px,\n    maxWidth: styleValueTypes.px,\n    height: styleValueTypes.px,\n    maxHeight: styleValueTypes.px,\n    size: styleValueTypes.px,\n    top: styleValueTypes.px,\n    right: styleValueTypes.px,\n    bottom: styleValueTypes.px,\n    left: styleValueTypes.px,\n    // Spacing props\n    padding: styleValueTypes.px,\n    paddingTop: styleValueTypes.px,\n    paddingRight: styleValueTypes.px,\n    paddingBottom: styleValueTypes.px,\n    paddingLeft: styleValueTypes.px,\n    margin: styleValueTypes.px,\n    marginTop: styleValueTypes.px,\n    marginRight: styleValueTypes.px,\n    marginBottom: styleValueTypes.px,\n    marginLeft: styleValueTypes.px,\n    // Transform props\n    rotate: styleValueTypes.degrees,\n    rotateX: styleValueTypes.degrees,\n    rotateY: styleValueTypes.degrees,\n    rotateZ: styleValueTypes.degrees,\n    scale: styleValueTypes.scale,\n    scaleX: styleValueTypes.scale,\n    scaleY: styleValueTypes.scale,\n    scaleZ: styleValueTypes.scale,\n    skew: styleValueTypes.degrees,\n    skewX: styleValueTypes.degrees,\n    skewY: styleValueTypes.degrees,\n    distance: styleValueTypes.px,\n    translateX: styleValueTypes.px,\n    translateY: styleValueTypes.px,\n    translateZ: styleValueTypes.px,\n    x: styleValueTypes.px,\n    y: styleValueTypes.px,\n    z: styleValueTypes.px,\n    perspective: styleValueTypes.px,\n    transformPerspective: styleValueTypes.px,\n    opacity: styleValueTypes.alpha,\n    originX: styleValueTypes.progressPercentage,\n    originY: styleValueTypes.progressPercentage,\n    originZ: styleValueTypes.px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: styleValueTypes.alpha,\n    strokeOpacity: styleValueTypes.alpha,\n    numOctaves: int,\n};\n\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var _a;\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (var key in latestValues) {\n        var value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */\n        if (isCSSVariable$1(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = numberValueTypes[key];\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))\n                transformIsNone = false;\n        }\n        else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n        }\n        else {\n            /**\n             * If layout projection is on, and we need to perform scale correction for this\n             * value type, perform it.\n             */\n            if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) &&\n                (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) &&\n                valueScaleCorrection[key]) {\n                var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\n                /**\n                 * Scale-correctable values can define a number of other values to break\n                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n                 */\n                var applyTo = valueScaleCorrection[key].applyTo;\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        style[applyTo[i]] = correctedValue;\n                    }\n                }\n                else {\n                    style[key] = correctedValue;\n                }\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (layoutState &&\n        projection &&\n        buildProjectionTransform &&\n        buildProjectionTransformOrigin) {\n        style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\n        if (transformTemplate) {\n            style.transform = transformTemplate(transform, style.transform);\n        }\n        style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n    }\n    else {\n        if (hasTransform) {\n            style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n        }\n        if (hasTransformOrigin) {\n            style.transformOrigin = buildTransformOrigin(transformOrigin);\n        }\n    }\n}\n\nvar createHtmlRenderState = function () { return ({\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {},\n}); };\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (var key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n    var transformTemplate = _a.transformTemplate;\n    return React.useMemo(function () {\n        var state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, undefined, undefined, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n        var vars = state.vars, style = state.style;\n        return tslib.__assign(tslib.__assign({}, vars), style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    var styleProp = props.style || {};\n    var style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    if (props.transformValues) {\n        style = props.transformValues(style);\n    }\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {};\n    var style = useStyle(props, visualState, isStatic);\n    if (Boolean(props.drag)) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout =\n            \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"layout\",\n    \"layoutId\",\n    \"_layoutResetTransform\",\n    \"onLayoutAnimationComplete\",\n    \"onViewportBoxUpdate\",\n    \"onLayoutMeasure\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"_dragX\",\n    \"_dragY\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"whileDrag\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"whileFocus\",\n    \"whileTap\",\n    \"whileHover\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\n\nvar shouldForward = function (key) { return !isValidMotionProp(key); };\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n    shouldForward = function (key) {\n        // Handle events explicitly as Emotion validates them all as true\n        if (key.startsWith(\"on\")) {\n            return !isValidMotionProp(key);\n        }\n        else {\n            return emotionIsPropValid_1(key);\n        }\n    };\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    var filteredProps = {};\n    for (var key in props) {\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key))) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return pxOriginX + \" \" + pxOriginY;\n}\n\n// Convert a progress 0-1 to a pixels value based on the provided length\nvar progressToPixels = function (progress, length) {\n    return styleValueTypes.px.transform(progress * length);\n};\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) { spacing = 1; }\n    if (offset === void 0) { offset = 0; }\n    if (useDashCase === void 0) { useDashCase = true; }\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\n    // Build the dash array\n    var pathLength = progressToPixels(length, totalLength);\n    var pathSpacing = progressToPixels(spacing, totalLength);\n    attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = tslib.__rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been measured\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nvar createSvgRenderState = function () { return (tslib.__assign(tslib.__assign({}, createHtmlRenderState()), { attrs: {} })); };\n\nfunction useSVGProps(props, visualState) {\n    var visualProps = React.useMemo(function () {\n        var state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n        return tslib.__assign(tslib.__assign({}, state.attrs), { style: tslib.__assign({}, state.style) });\n    }, [visualState]);\n    if (props.style) {\n        var rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n    }\n    return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps) {\n    if (forwardMotionProps === void 0) { forwardMotionProps = false; }\n    var useRender = function (Component, props, ref, _a, isStatic) {\n        var latestValues = _a.latestValues;\n        var useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        var visualProps = useVisualProps(props, latestValues, isStatic);\n        var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), { ref: ref });\n        return React.createElement(Component, elementProps);\n    };\n    return useRender;\n}\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nfunction renderHTML(element, _a) {\n    var style = _a.style, vars = _a.vars;\n    // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n    Object.assign(element.style, style);\n    // Loop over any CSS variables and assign those.\n    for (var key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n]);\n\nfunction renderSVG(element, renderState) {\n    renderHTML(element, renderState);\n    for (var key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nfunction scrapeMotionValuesFromProps$1(props) {\n    var style = props.style;\n    var newValues = {};\n    for (var key in style) {\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props) {\n    var newValues = scrapeMotionValuesFromProps$1(props);\n    for (var key in props) {\n        if (isMotionValue(props[key])) {\n            var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\nvar isCustomValue = function (v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\nfunction resolveMotionValue(value) {\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\nfunction makeState(_a, props, context, presenceContext) {\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n    var state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onMount) {\n        state.mount = function (instance) { return onMount(props, instance, state); };\n    }\n    return state;\n}\nvar makeUseVisualState = function (config) { return function (props, isStatic) {\n    var context = React.useContext(MotionContext);\n    var presenceContext = React.useContext(PresenceContext);\n    return isStatic\n        ? makeState(config, props, context, presenceContext)\n        : useConstant(function () { return makeState(config, props, context, presenceContext); });\n}; };\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    var values = {};\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n    var motionValues = scrapeMotionValues(props);\n    for (var key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    var initial = props.initial, animate = props.animate;\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    if (context &&\n        isVariantNode &&\n        !isControllingVariants &&\n        props.inherit !== false) {\n        initial !== null && initial !== void 0 ? initial : (initial = context.initial);\n        animate !== null && animate !== void 0 ? animate : (animate = context.animate);\n    }\n    var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        list.forEach(function (definition) {\n            var resolved = resolveVariantFromProps(props, definition);\n            if (!resolved)\n                return;\n            var transitionEnd = resolved.transitionEnd; resolved.transition; var target = tslib.__rest(resolved, [\"transitionEnd\", \"transition\"]);\n            for (var key in target)\n                values[key] = target[key];\n            for (var key in transitionEnd)\n                values[key] = transitionEnd[key];\n        });\n    }\n    return values;\n}\n\nvar svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: function (props, instance, _a) {\n            var renderState = _a.renderState, latestValues = _a.latestValues;\n            try {\n                renderState.dimensions =\n                    typeof instance.getBBox ===\n                        \"function\"\n                        ? instance.getBBox()\n                        : instance.getBoundingClientRect();\n            }\n            catch (e) {\n                // Most likely trying to measure an unrendered element under Firefox\n                renderState.dimensions = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0,\n                };\n            }\n            if (isPath(instance)) {\n                renderState.totalPathLength = instance.getTotalLength();\n            }\n            buildSVGAttrs(renderState, latestValues, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n            // TODO: Replace with direct assignment\n            renderSVG(instance, renderState);\n        },\n    }),\n};\nfunction isPath(element) {\n    return element.tagName === \"path\";\n}\n\nvar htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n    var baseConfig = isSVGComponent(Component)\n        ? svgMotionConfig\n        : htmlMotionConfig;\n    return tslib.__assign(tslib.__assign({}, baseConfig), { preloadedFeatures: preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement: createVisualElement,\n        Component: Component });\n}\n\nvar AnimationType;\n(function (AnimationType) {\n    AnimationType[\"Animate\"] = \"animate\";\n    AnimationType[\"Hover\"] = \"whileHover\";\n    AnimationType[\"Tap\"] = \"whileTap\";\n    AnimationType[\"Drag\"] = \"whileDrag\";\n    AnimationType[\"Focus\"] = \"whileFocus\";\n    AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\nfunction addDomEvent(target, eventName, handler, options) {\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler, options); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    React.useEffect(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useFocusGesture(_a) {\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\n    var onFocus = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n    };\n    var onBlur = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\n\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nfunction getViewportPointFromEvent(event) {\n    return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    var listener = function (event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\",\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock)\n        return true;\n    openGestureLock();\n    return false;\n}\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function (event, info) {\n        var _a;\n        if (!isMouseEvent(event) || isDragActive())\n            return;\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n    };\n}\nfunction useHoverGesture(_a) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\n    usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover\n        ? createHoverEvent(visualElement, true, onHoverStart)\n        : undefined);\n    usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover\n        ? createHoverEvent(visualElement, false, onHoverEnd)\n        : undefined);\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nfunction useUnmountEffect(callback) {\n    return React.useEffect(function () { return function () { return callback(); }; }, []);\n}\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = React.useRef(false);\n    var cancelPointerEndListeners = React.useRef(null);\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.getInstance(), event.target)\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info)\n            : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n    useUnmountEffect(removePointerEndListener);\n}\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\n    hook(props);\n    return null;\n}; };\n\nvar gestureAnimations = {\n    tap: makeRenderlessComponent(useTapGesture),\n    focus: makeRenderlessComponent(useFocusGesture),\n    hover: makeRenderlessComponent(useHoverGesture),\n};\n\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (var i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar easingLookup = {\n    linear: popmotion.linear,\n    easeIn: popmotion.easeIn,\n    easeInOut: popmotion.easeInOut,\n    easeOut: popmotion.easeOut,\n    circIn: popmotion.circIn,\n    circInOut: popmotion.circInOut,\n    circOut: popmotion.circOut,\n    backIn: popmotion.backIn,\n    backInOut: popmotion.backInOut,\n    backOut: popmotion.backOut,\n    anticipate: popmotion.anticipate,\n    bounceIn: popmotion.bounceIn,\n    bounceInOut: popmotion.bounceInOut,\n    bounceOut: popmotion.bounceOut,\n};\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var _a = tslib.__read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return popmotion.cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nvar underDampedSpring = function () { return ({\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10,\n}); };\nvar criticallyDampedSpring = function (to) { return ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10,\n}); };\nvar linearTween = function () { return ({\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3,\n}); };\nvar keyframes = function (values) { return ({\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return tslib.__assign({ to: to }, transitionFactory(to));\n};\n\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), { \n    // Color props\n    color: styleValueTypes.color, backgroundColor: styleValueTypes.color, outlineColor: styleValueTypes.color, fill: styleValueTypes.color, stroke: styleValueTypes.color, \n    // Border props\n    borderColor: styleValueTypes.color, borderTopColor: styleValueTypes.color, borderRightColor: styleValueTypes.color, borderBottomColor: styleValueTypes.color, borderLeftColor: styleValueTypes.color, filter: styleValueTypes.filter, WebkitFilter: styleValueTypes.filter });\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n\nfunction getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== styleValueTypes.filter)\n        defaultValueType = styleValueTypes.complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = tslib.__rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = tslib.__rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n    var options = tslib.__assign({}, transition);\n    if (times)\n        options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */\n    if (ease) {\n        options[\"ease\"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === \"tween\")\n        options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        }\n        else if (loop) {\n            options.repeatType = \"loop\";\n        }\n        else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */\n    if (transition.type !== \"spring\")\n        options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = tslib.__spreadArray([], tslib.__read(options.to));\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function (v) { return value.set(v); },\n        };\n        return valueTransition.type === \"inertia\" ||\n            valueTransition.type === \"decay\"\n            ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition))\n            : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {\n                    var _a;\n                    options.onUpdate(v);\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n                }, onComplete: function () {\n                    var _a;\n                    options.onComplete();\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n                } }));\n    }\n    function set() {\n        var _a;\n        value.set(target);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n        return { stop: function () { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === \"string\" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(\" \") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\"\n        ? 0\n        : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\nfunction startAnimation(key, value, target, transition) {\n    if (transition === void 0) { transition = {}; }\n    return value.start(function (onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function () { return (controls = animation()); };\n        if (delay) {\n            delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return function () {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\n\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nvar SubscriptionManager = /** @class */ (function () {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function (handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function () { return removeItem(_this.subscriptions, handler); };\n    };\n    SubscriptionManager.prototype.notify = function (a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (var i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function () {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function () {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}());\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init) {\n        var _this = this;\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */\n        this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */\n        this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */\n        this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync__default['default'].postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return sync__default['default'].postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * @library\n     *\n     * ```jsx\n     * function MyComponent() {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <Frame x={x} />\n     * }\n     * ```\n     *\n     * @motion\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @internalremarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        return this.updateSubscribers.add(subscription);\n    };\n    MotionValue.prototype.clearListeners = function () {\n        this.updateSubscribers.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        // Render immediately\n        subscription(this.get());\n        return this.renderSubscribers.add(subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        return this.current;\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                popmotion.velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}());\n/**\n * @internal\n */\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\n\n/**\n * ValueType for \"auto\"\n */\nvar auto = {\n    test: function (v) { return v === \"auto\"; },\n    parse: function (v) { return v; },\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved\n        ? visualElement.makeTargetAnimatable(resolved, false)\n        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = tslib.__rest(_a, [\"transitionEnd\", \"transition\"]);\n    target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n    for (var key in target) {\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\n    reversedLabels.forEach(function (key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (var i = 0; i < numNewValues; i++) {\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" && isNumericalString(value)) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] =\n            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\n\n/**\n * @internal\n */\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) { options = {}; }\n    visualElement.notifyAnimationStart();\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function (variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        var resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function () {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getAnimation = resolved\n        ? function () { return animateTarget(visualElement, resolved, options); }\n        : function () { return Promise.resolve(); };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? function (forwardDelay) {\n            if (forwardDelay === void 0) { forwardDelay = 0; }\n            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : function () { return Promise.resolve(); };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    var when = transition.when;\n    if (when) {\n        var _c = tslib.__read(when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = tslib.__rest(_e, [\"transition\", \"transitionEnd\"]);\n    if (transitionOverride)\n        transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for (var key in target) {\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        var animation = startAnimation(key, value, valueTarget, tslib.__assign({ delay: delay }, transition));\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function () {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) { delayChildren = 0; }\n    if (staggerChildren === void 0) { staggerChildren = 0; }\n    if (staggerDirection === void 0) { staggerDirection = 1; }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1\n        ? function (i) {\n            if (i === void 0) { i = 0; }\n            return i * staggerChildren;\n        }\n        : function (i) {\n            if (i === void 0) { i = 0; }\n            return maxStaggerDuration - i * staggerChildren;\n        };\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach(function (child, i) {\n        animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function (value) { return value.stop(); });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nvar variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Focus,\n    AnimationType.Exit,\n];\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function (animations) {\n        return Promise.all(animations.map(function (_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    var buildResolvedTypeValues = function (acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = tslib.__rest(resolved, [\"transition\", \"transitionEnd\"]);\n            acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        var removedVariantIndex = Infinity;\n        var _loop_1 = function (i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            var definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function (key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (var key in allKeys) {\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev)) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) { return ({\n                    animation: animation,\n                    options: tslib.__assign({ type: type }, options),\n                }); }))));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (var i = 0; i < numAnimationTypes; i++) {\n            _loop_1(i);\n        }\n        allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function (key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation_1 });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        return animateChanges(options, type);\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function () { return state; },\n    };\n}\nfunction variantsHaveChanged(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) { isActive = false; }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {},\n        _a[AnimationType.Animate] = createTypeState(true),\n        _a[AnimationType.Hover] = createTypeState(),\n        _a[AnimationType.Tap] = createTypeState(),\n        _a[AnimationType.Drag] = createTypeState(),\n        _a[AnimationType.Focus] = createTypeState(),\n        _a[AnimationType.Exit] = createTypeState(),\n        _a;\n}\n\nvar animations = {\n    animation: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, animate = _a.animate;\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */\n        if (isAnimationControls(animate)) {\n            React.useEffect(function () { return animate.subscribe(visualElement); }, [animate]);\n        }\n    }),\n    exit: makeRenderlessComponent(function (props) {\n        var custom = props.custom, visualElement = props.visualElement;\n        var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], onExitComplete = _a[1];\n        var presenceContext = React.useContext(PresenceContext);\n        React.useEffect(function () {\n            var _a, _b;\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n        }, [isPresent]);\n    }),\n};\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = popmotion.distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = sync.getFrameData().timestamp;\n            _this.history.push(tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync__default['default'].update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = sync.getFrameData().timestamp;\n        this.history = [tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        sync.cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nfunction noop(any) {\n    return any;\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        bottom: y.max,\n        left: x.min,\n        right: x.max,\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    if (transformPoint === void 0) { transformPoint = noop; }\n    var topLeft = transformPoint({ x: left, y: top });\n    var bottomRight = transformPoint({ x: right, y: bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n/**\n * Create an empty axis box of zero size\n */\nfunction axisBox() {\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n}\nfunction copyAxisBox(box) {\n    return {\n        x: tslib.__assign({}, box.x),\n        y: tslib.__assign({}, box.y),\n    };\n}\n/**\n * Create an empty box delta\n */\nvar zeroDelta = {\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n};\nfunction delta() {\n    return {\n        x: tslib.__assign({}, zeroDelta),\n        y: tslib.__assign({}, zeroDelta),\n    };\n}\n\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\n\nvar clampProgress = function (v) { return popmotion.clamp(0, 1, v); };\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return popmotion.distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate =\n        popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n    return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n    // Calculate a min point for this axis and apply it to the current pointer\n    var min = point - length * progress;\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: layoutAxis.min + min,\n        max: layoutAxis.min + max,\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n    var axisLength = axis.max - axis.min;\n    var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\n    return { min: min, max: min + axisLength };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\nfunction getBoundingBox(element, transformPagePoint) {\n    var box = element.getBoundingClientRect();\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\nvar compareByDepth = function (a, b) {\n    return a.depth - b.depth;\n};\n\nfunction isProjecting(visualElement) {\n    var isEnabled = visualElement.projection.isEnabled;\n    return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n    if (ancestors === void 0) { ancestors = []; }\n    var parent = visualElement.parent;\n    if (parent)\n        collectProjectingAncestors(parent, ancestors);\n    if (isProjecting(visualElement))\n        ancestors.push(visualElement);\n    return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        if (isProjecting(child))\n            children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync__default['default'].update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction tweenAxis(target, prev, next, p) {\n    target.min = popmotion.mix(prev.min, next.min, p);\n    target.max = popmotion.mix(prev.max, next.max, p);\n}\nfunction calcRelativeOffsetAxis(parent, child) {\n    return {\n        min: child.min - parent.min,\n        max: child.max - parent.min,\n    };\n}\nfunction calcRelativeOffset(parent, child) {\n    return {\n        x: calcRelativeOffsetAxis(parent.x, child.x),\n        y: calcRelativeOffsetAxis(parent.y, child.y),\n    };\n}\nfunction checkIfParentHasChanged(prev, next) {\n    var prevId = prev.getLayoutId();\n    var nextId = next.getLayoutId();\n    return prevId !== nextId || (nextId === undefined && prev !== next);\n}\n\nfunction isDraggable(visualElement) {\n    var _a = visualElement.getProps(), drag = _a.drag, _dragX = _a._dragX;\n    return drag && !_dragX;\n}\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n    resetAxis(box.x, originBox.x);\n    resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    // Copy the current axis to the final axis before mutation\n    final.min = axis.min;\n    final.max = axis.max;\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (origin === void 0) { origin = 0.5; }\n    var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms) {\n    removeAxisTransforms(box.x, transforms, xKeys);\n    removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n    var treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for (var i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.getLayoutState().delta;\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\n        treeScale.x *= delta.x.scale;\n        treeScale.y *= delta.y.scale;\n        // Apply each ancestor's calculated delta into this component's recorded layout box\n        applyBoxDelta(box, delta);\n        // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n        if (isDraggable(node)) {\n            applyBoxTransforms(box, box, node.getLatestValues());\n        }\n    }\n}\n\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n    if (isLayoutDrag === void 0) { isLayoutDrag = true; }\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent)\n        return false;\n    var offset;\n    if (isLayoutDrag) {\n        offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n        removeBoxTransforms(offset, projectionParent.getLatestValues());\n    }\n    else {\n        offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    }\n    eachAxis(function (axis) {\n        return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n    });\n    return true;\n}\n\nvar unresolvedJobs = new Set();\nfunction pushJob(stack, job, pointer) {\n    if (!stack[pointer])\n        stack[pointer] = [];\n    stack[pointer].push(job);\n}\nfunction batchLayout(callback) {\n    unresolvedJobs.add(callback);\n    return function () { return unresolvedJobs.delete(callback); };\n}\nfunction flushLayout() {\n    if (!unresolvedJobs.size)\n        return;\n    var pointer = 0;\n    var reads = [[]];\n    var writes = [];\n    var setRead = function (job) { return pushJob(reads, job, pointer); };\n    var setWrite = function (job) {\n        pushJob(writes, job, pointer);\n        pointer++;\n    };\n    /**\n     * Resolve jobs into their array stacks\n     */\n    unresolvedJobs.forEach(function (callback) {\n        callback(setRead, setWrite);\n        pointer = 0;\n    });\n    unresolvedJobs.clear();\n    /**\n     * Execute jobs\n     */\n    var numStacks = writes.length;\n    for (var i = 0; i <= numStacks; i++) {\n        reads[i] && reads[i].forEach(executeJob);\n        writes[i] && writes[i].forEach(executeJob);\n    }\n}\nvar executeJob = function (job) { return job(); };\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         *\n         * @internal\n         */\n        this.elastic = axisBox();\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * @internal\n         */\n        this.hasMutatedConstraints = false;\n        /**\n         * Track the initial position of the cursor relative to the dragging element\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\n         *\n         * @internal\n         */\n        this.cursorProgress = {\n            x: 0.5,\n            y: 0.5,\n        };\n        // When updating _dragX, or _dragY instead of the VisualElement,\n        // persist their values between drag gestures.\n        this.originPoint = {};\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.visualElement = visualElement;\n        this.visualElement.enableLayoutProjection();\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Instantiate a PanSession for the drag gesture\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n        var onSessionStart = function (event) {\n            var _a;\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n            /**\n             * Save the initial point. We'll use this to calculate the pointer's position rather\n             * than the one we receive when the gesture actually starts. By then, the pointer will\n             * have already moved, and the perception will be of the pointer \"slipping\" across the element\n             */\n            var initialPoint = getViewportPointFromEvent(event).point;\n            (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n            _this.cancelLayout = batchLayout(function (read, write) {\n                var ancestors = collectProjectingAncestors(_this.visualElement);\n                var children = collectProjectingChildren(_this.visualElement);\n                var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\n                var hasManuallySetCursorOrigin = false;\n                /**\n                 * Apply a simple lock to the projection target. This ensures no animations\n                 * can run on the projection box while this lock is active.\n                 */\n                _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n                write(function () {\n                    tree.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    updateLayoutMeasurement(_this.visualElement);\n                    children.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    tree.forEach(function (element) { return element.restoreTransform(); });\n                    if (snapToCursor) {\n                        hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n                    }\n                });\n                read(function () {\n                    var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n                    if (!isRelativeDrag) {\n                        _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n                    }\n                    _this.visualElement.scheduleUpdateLayoutProjection();\n                    /**\n                     * When dragging starts, we want to find where the cursor is relative to the bounding box\n                     * of the element. Every frame, we calculate a new bounding box using this relative position\n                     * and let the visualElement renderer figure out how to reproject the element into this bounding\n                     * box.\n                     *\n                     * By doing it this way, rather than applying an x/y transform directly to the element,\n                     * we can ensure the component always visually sticks to the cursor as we'd expect, even\n                     * if the DOM element itself changes layout as a result of React updates the user might\n                     * make based on the drag position.\n                     */\n                    var projection = _this.visualElement.projection;\n                    eachAxis(function (axis) {\n                        if (!hasManuallySetCursorOrigin) {\n                            var _a = projection.target[axis], min = _a.min, max = _a.max;\n                            _this.cursorProgress[axis] = cursorProgress\n                                ? cursorProgress[axis]\n                                : popmotion.progress(min, max, initialPoint[axis]);\n                        }\n                        /**\n                         * If we have external drag MotionValues, record their origin point. On pointermove\n                         * we'll apply the pan gesture offset directly to this value.\n                         */\n                        var axisValue = _this.getAxisMotionValue(axis);\n                        if (axisValue) {\n                            _this.originPoint[axis] = axisValue.get();\n                        }\n                    });\n                });\n                write(function () {\n                    sync.flushSync.update();\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                    sync.flushSync.postRender();\n                });\n                read(function () { return _this.resolveDragConstraints(); });\n            });\n        };\n        var onStart = function (event, info) {\n            var _a, _b, _c;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            flushLayout();\n            // Set current drag status\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            // Fire onDragStart event\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            // Fire onDrag event\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n            // Update the last pointer event\n            lastPointerEvent = event;\n        };\n        var onSessionEnd = function (event, info) {\n            return _this.stop(event, info);\n        };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        var _this = this;\n        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = this.visualElement.getLayoutState().layoutCorrected;\n        if (dragConstraints) {\n            this.constraints = isRefObject(dragConstraints)\n                ? this.resolveRefConstraints(layout, dragConstraints)\n                : calcRelativeConstraints(layout, dragConstraints);\n        }\n        else {\n            this.constraints = false;\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = constraints.current;\n        heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        var _a, _b;\n        this.visualElement.unlockProjectionTarget();\n        (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a, _b, _c;\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var velocity = info.velocity;\n        this.animateDragEnd(velocity);\n        (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\n        var _this = this;\n        return eachAxis(function (axis) {\n            var drag = _this.props.drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var box = _this.visualElement.getLayoutState().layout;\n                var length_1 = box[axis].max - box[axis].min;\n                var center = box[axis].min + length_1 / 2;\n                var offset = point[axis] - center;\n                _this.originPoint[axis] = point[axis];\n                axisValue.set(offset);\n            }\n            else {\n                _this.cursorProgress[axis] = 0.5;\n                return true;\n            }\n        }).includes(true);\n    };\n    /**\n     * Update the specified axis with the latest pointer information.\n     */\n    VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n        var drag = this.props.drag;\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection))\n            return;\n        return this.getAxisMotionValue(axis)\n            ? this.updateAxisMotionValue(axis, offset)\n            : this.updateVisualElementAxis(axis, point);\n    };\n    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!offset || !axisValue)\n            return;\n        var nextValue = this.originPoint[axis] + offset[axis];\n        var update = this.constraints\n            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])\n            : nextValue;\n        axisValue.set(update);\n    };\n    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n        var _a;\n        // Get the actual layout bounding box of the element\n        var axisLayout = this.visualElement.getLayoutState().layout[axis];\n        // Calculate its current length. In the future we might want to lerp this to animate\n        // between lengths if the layout changes as we change the DOM\n        var axisLength = axisLayout.max - axisLayout.min;\n        // Get the initial progress that the pointer sat on this axis on gesture start.\n        var axisProgress = this.cursorProgress[axis];\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n        // Update the axis viewport target with this new min and the length\n        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n    };\n    VisualElementDragControls.prototype.setProps = function (_a) {\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = tslib.__rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = tslib.__assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - If the component will perform layout animations, we output the gesture to the component's\n     *      visual bounding box\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        if (this.props[dragKey]) {\n            return this.props[dragKey];\n        }\n        else if (!layout && layoutId === undefined) {\n            return this.visualElement.getValue(axis, 0);\n        }\n    };\n    VisualElementDragControls.prototype.isLayoutDrag = function () {\n        return !this.getAxisMotionValue(\"x\");\n    };\n    VisualElementDragControls.prototype.isExternalDrag = function () {\n        var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;\n        return _dragX || _dragY;\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n        /**\n         * Everything beyond the drag gesture should be performed with\n         * relative projection so children stay in sync with their parent element.\n         */\n        var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n        /**\n         * If we had previously resolved constraints relative to the viewport,\n         * we need to also convert those to a relative coordinate space for the animation\n         */\n        var constraints = this.constraints || {};\n        if (isRelative &&\n            Object.keys(constraints).length &&\n            this.isLayoutDrag()) {\n            var projectionParent = this.visualElement.getProjectionParent();\n            if (projectionParent) {\n                var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n                eachAxis(function (axis) {\n                    var _a = relativeConstraints_1[axis], min = _a.min, max = _a.max;\n                    constraints[axis] = {\n                        min: isNaN(min) ? undefined : min,\n                        max: isNaN(max) ? undefined : max,\n                    };\n                });\n            }\n        }\n        var momentumAnimations = eachAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = tslib.__assign(tslib.__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.getAxisMotionValue(axis)\n                ? _this.startAxisValueAnimation(axis, inertia)\n                : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        var _this = this;\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            axisValue\n                ? axisValue.stop()\n                : _this.visualElement.stopLayoutAnimation();\n        });\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!axisValue)\n            return;\n        var currentValue = axisValue.get();\n        axisValue.set(currentValue);\n        axisValue.set(currentValue); // Set twice to hard-reset velocity\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\n            return;\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\n        this.stopMotion();\n        // Record the relative progress of the targetBox relative to the constraintsBox\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n        });\n        /**\n         * For each axis, calculate the current progress of the layout axis within the constraints.\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\n         * proportionally within the constraints.\n         */\n        this.updateConstraints(function () {\n            eachAxis(function (axis) {\n                if (!shouldDrag(axis, drag, null))\n                    return;\n                // Calculate the position of the targetBox relative to the constraintsBox using the\n                // previously calculated progress\n                var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\n                _this.visualElement.setProjectionTargetAxis(axis, min, max);\n            });\n        });\n        /**\n         * If any other draggable components are queuing the same tasks synchronously\n         * this will wait until they've all been scheduled before flushing.\n         */\n        setTimeout(flushLayout, 1);\n    };\n    VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n        var _this = this;\n        this.cancelLayout = batchLayout(function (read, write) {\n            var ancestors = collectProjectingAncestors(_this.visualElement);\n            write(function () {\n                return ancestors.forEach(function (element) { return element.resetTransform(); });\n            });\n            read(function () { return updateLayoutMeasurement(_this.visualElement); });\n            write(function () {\n                return ancestors.forEach(function (element) { return element.restoreTransform(); });\n            });\n            read(function () {\n                _this.resolveDragConstraints();\n            });\n            if (onReady)\n                write(onReady);\n        });\n    };\n    VisualElementDragControls.prototype.mount = function (visualElement) {\n        var _this = this;\n        var element = visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            _this.scalePoint();\n        });\n        /**\n         * Ensure drag constraints are resolved correctly relative to the dragging element\n         * whenever its layout changes.\n         */\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n            if (_this.isDragging) {\n                _this.resolveDragConstraints();\n            }\n        });\n        /**\n         * If the previous component with this same layoutId was dragging at the time\n         * it was unmounted, we want to continue the same gesture on this component.\n         */\n        var prevDragCursor = visualElement.prevDragCursor;\n        if (prevDragCursor) {\n            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\n        }\n        /**\n         * Return a function that will teardown the drag gesture\n         */\n        return function () {\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props) {\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var dragControls = useConstant(function () {\n        return new VisualElementDragControls({\n            visualElement: visualElement,\n        });\n    });\n    dragControls.setProps(tslib.__assign(tslib.__assign({}, props), { transformPagePoint: transformPagePoint }));\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    React.useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\n    // Mount the drag controls with the visualElement\n    React.useEffect(function () { return dragControls.mount(visualElement); }, []);\n}\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = React.useRef(null);\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    React.useEffect(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\nvar drag = {\n    pan: makeRenderlessComponent(usePanGesture),\n    drag: makeRenderlessComponent(useDrag),\n};\n\n/**\n * @public\n */\nvar Presence;\n(function (Presence) {\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\nexports.VisibilityAction = void 0;\n(function (VisibilityAction) {\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\n\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var _a = tslib.__read(match, 3), token = _a[1], fallback = _a[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    heyListen.invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n    var _a = tslib.__read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = tslib.__rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof HTMLElement))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = tslib.__assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd)\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nfunction pixelsToPercent(pixels, axis) {\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n    var target = _a.target;\n    /**\n     * If latest is a string, if it's a percentage we can return immediately as it's\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n     */\n    if (typeof latest === \"string\") {\n        if (styleValueTypes.px.test(latest)) {\n            latest = parseFloat(latest);\n        }\n        else {\n            return latest;\n        }\n    }\n    /**\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n     * pixel value as a percentage of each axis\n     */\n    var x = pixelsToPercent(latest, target.x);\n    var y = pixelsToPercent(latest, target.y);\n    return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n    var delta = _a.delta, treeScale = _a.treeScale;\n    var original = latest;\n    /**\n     * We need to first strip and store CSS variables from the string.\n     */\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n    if (containsCSSVariables) {\n        latest = latest.replace(cssVariableRegex, function (match) {\n            cssVariables.push(match);\n            return varToken;\n        });\n    }\n    var shadow = styleValueTypes.complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5)\n        return original;\n    var template = styleValueTypes.complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    var xScale = delta.x.scale * treeScale.x;\n    var yScale = delta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    var averageScale = popmotion.mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\")\n        shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\")\n        shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n    if (containsCSSVariables) {\n        var i_1 = 0;\n        output = output.replace(varToken, function () {\n            var cssVariable = cssVariables[i_1];\n            i_1++;\n            return cssVariable;\n        });\n    }\n    return output;\n}\nvar borderCorrectionDefinition = {\n    process: correctBorderRadius,\n};\nvar defaultScaleCorrectors = {\n    borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: borderCorrectionDefinition,\n    borderTopRightRadius: borderCorrectionDefinition,\n    borderBottomLeftRadius: borderCorrectionDefinition,\n    borderBottomRightRadius: borderCorrectionDefinition,\n    boxShadow: {\n        process: correctBoxShadow,\n    },\n};\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    tslib.__extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable object that tracks the target viewport box\n         * for the current animation frame.\n         */\n        _this.frameTarget = axisBox();\n        /**\n         * The current animation target, we use this to check whether to start\n         * a new animation or continue the existing one.\n         */\n        _this.currentAnimationTarget = axisBox();\n        /**\n         * Track whether we're animating this axis.\n         */\n        _this.isAnimating = {\n            x: false,\n            y: false,\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.isAnimatingTree = false;\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = tslib.__rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Early return if we've been instructed not to animate this render.\n             */\n            if (shouldStackAnimate === false) {\n                _this.isAnimatingTree = false;\n                return _this.safeToRemove();\n            }\n            /**\n             * Prioritise tree animations\n             */\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n                return;\n            }\n            else if (shouldStackAnimate) {\n                _this.isAnimatingTree = true;\n            }\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            /**\n             * If this element has a projecting parent, there's an opportunity to animate\n             * it relatively to that parent rather than relatively to the viewport. This\n             * allows us to add orchestrated animations.\n             */\n            var isRelative = false;\n            var projectionParent = visualElement.getProjectionParent();\n            if (projectionParent) {\n                var prevParentViewportBox = projectionParent.prevViewportBox;\n                var parentLayout = projectionParent.getLayoutState().layout;\n                /**\n                 * If we're being provided a previous parent VisualElement by AnimateSharedLayout\n                 */\n                if (prevParent) {\n                    /**\n                     * If we've been provided an explicit target box it means we're animating back\n                     * to this previous parent. So we can make a relative box by comparing to the previous\n                     * parent's layout\n                     */\n                    if (targetBox) {\n                        parentLayout = prevParent.getLayoutState().layout;\n                    }\n                    /**\n                     * Likewise if we've been provided an explicit origin box it means we're\n                     * animating out from a different element. So we should figure out where that was\n                     * on screen relative to the new parent element.\n                     */\n                    if (originBox &&\n                        !checkIfParentHasChanged(prevParent, projectionParent) &&\n                        prevParent.prevViewportBox) {\n                        prevParentViewportBox = prevParent.prevViewportBox;\n                    }\n                }\n                if (prevParentViewportBox &&\n                    isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n                    isRelative = true;\n                    origin = calcRelativeOffset(prevParentViewportBox, origin);\n                    target = calcRelativeOffset(parentLayout, target);\n                }\n            }\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                var _a, _b;\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.projection.isTargetLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), { isRelative: isRelative }));\n                }\n                else {\n                    (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.syncRender();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                _this.isAnimatingTree = false;\n                onComplete && onComplete();\n                visualElement.notifyLayoutAnimationComplete();\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var _this = this;\n        var visualElement = this.props.visualElement;\n        visualElement.animateMotionValue = startAnimation;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\n        addScaleCorrection(defaultScaleCorrectors);\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _this = this;\n        var _b, _c;\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;\n        /**\n         * If we're not animating to a new target, don't run this animation\n         */\n        if (this.isAnimating[axis] &&\n            axisIsEqual(target, this.currentAnimationTarget[axis])) {\n            return;\n        }\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        this.isAnimating[axis] = true;\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        this.stopAxisAnimation[axis] = function () {\n            _this.isAnimating[axis] = false;\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        this.currentAnimationTarget[axis] = target;\n        var layoutTransition = transition ||\n            visualElement.getDefaultTransition() ||\n            defaultLayoutTransition;\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n        return animation;\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(React__namespace.Component));\nfunction AnimateLayoutContextProvider(props) {\n    var _a = tslib.__read(usePresence(), 2), safeToRemove = _a[1];\n    return React__namespace.createElement(Animate, tslib.__assign({}, props, { safeToRemove: safeToRemove }));\n}\nfunction hasMoved(a, b) {\n    return (!isZeroBox(a) &&\n        !isZeroBox(b) &&\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a) {\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n    return prevParent || (!prevParent && !(originBox || targetBox));\n}\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            batchLayout(function (read, write) {\n                var order = Array.from(queue).sort(compareByDepth);\n                var ancestors = parent\n                    ? collectProjectingAncestors(parent)\n                    : [];\n                write(function () {\n                    var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\n                    allElements.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    order.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\n                    order.forEach(layoutReady);\n                });\n                read(function () {\n                    /**\n                     * After all children have started animating, ensure any Entering components are set to Present.\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\n                     * are generated in AnimateSharedLayout as this relies on presence data\n                     */\n                    order.forEach(function (child) {\n                        if (child.isPresent)\n                            child.presence = Presence.Present;\n                    });\n                });\n                write(function () {\n                    /**\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n                     * we ensure there's no flash.\n                     */\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                });\n                read(function () {\n                    /**\n                     * Schedule a callback at the end of the following frame to assign the latest projection\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n                     * child attempts to calculate its previous relative position against a prevViewportBox\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\n                     * render.\n                     */\n                    sync__default['default'].postRender(function () {\n                        return order.forEach(assignProjectionToSnapshot);\n                    });\n                    queue.clear();\n                });\n            });\n            // TODO: Need to find a layout-synchronous way of flushing this\n            flushLayout();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nvar SharedLayoutContext = React.createContext(createBatcher());\n/**\n * @internal\n */\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\nfunction isSharedLayout(context) {\n    return !!context.forceUpdate;\n}\n\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\nvar Measure = /** @class */ (function (_super) {\n    tslib.__extends(Measure, _super);\n    function Measure() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * If this is a child of a SyncContext, register the VisualElement with it on mount.\n     */\n    Measure.prototype.componentDidMount = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement = _a.visualElement;\n        isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n        isSharedLayout(framerSyncLayout) &&\n            framerSyncLayout.register(visualElement);\n        visualElement.onUnmount(function () {\n            if (isSharedLayout(syncLayout)) {\n                syncLayout.remove(visualElement);\n            }\n            if (isSharedLayout(framerSyncLayout)) {\n                framerSyncLayout.remove(visualElement);\n            }\n        });\n    };\n    /**\n     * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n     * handle the snapshotting.\n     *\n     * If it is stand-alone component, add it to the batcher.\n     */\n    Measure.prototype.getSnapshotBeforeUpdate = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\n        if (isSharedLayout(syncLayout)) {\n            syncLayout.syncUpdate();\n        }\n        else {\n            snapshotViewportBox(visualElement);\n            syncLayout.add(visualElement);\n        }\n        return null;\n    };\n    Measure.prototype.componentDidUpdate = function () {\n        var syncLayout = this.props.syncLayout;\n        if (!isSharedLayout(syncLayout))\n            syncLayout.flush();\n    };\n    Measure.prototype.render = function () {\n        return null;\n    };\n    return Measure;\n}(React__default['default'].Component));\nfunction MeasureContextProvider(props) {\n    var syncLayout = React.useContext(SharedLayoutContext);\n    var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\n    return (React__default['default'].createElement(Measure, tslib.__assign({}, props, { syncLayout: syncLayout, framerSyncLayout: framerSyncLayout })));\n}\n\nvar layoutAnimations = {\n    measureLayout: MeasureContextProvider,\n    layoutAnimation: AnimateLayoutContextProvider,\n};\n\nvar createProjectionState = function () { return ({\n    isEnabled: false,\n    isHydrated: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox(),\n}); };\nfunction createLayoutState() {\n    return {\n        isHydrated: false,\n        layout: axisBox(),\n        layoutCorrected: axisBox(),\n        treeScale: { x: 1, y: 1 },\n        delta: delta(),\n        deltaFinal: delta(),\n        deltaTransform: \"\",\n    };\n}\nvar zeroLayout = createLayoutState();\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n    var x = _a.x, y = _a.y;\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = x.translate / treeScale.x;\n    var yTranslate = y.translate / treeScale.y;\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\" + rotate + \") \";\n        if (rotateX)\n            transform += \"rotateX(\" + rotateX + \") \";\n        if (rotateY)\n            transform += \"rotateY(\" + rotateY + \") \";\n    }\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n    var deltaFinal = _a.deltaFinal;\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\nvar names = [\n    \"LayoutMeasure\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutUpdate\",\n    \"ViewportBoxUpdate\",\n    \"Update\",\n    \"Render\",\n    \"AnimationComplete\",\n    \"LayoutAnimationComplete\",\n    \"AnimationStart\",\n    \"SetAxisTarget\",\n    \"Unmount\",\n];\nfunction createLifecycles() {\n    var managers = names.map(function () { return new SubscriptionManager(); });\n    var propSubscriptions = {};\n    var lifecycles = {\n        clearAllListeners: function () { return managers.forEach(function (manager) { return manager.clear(); }); },\n        updatePropListeners: function (props) {\n            return names.forEach(function (name) {\n                var _a;\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n                var on = \"on\" + name;\n                var propListener = props[on];\n                if (propListener) {\n                    propSubscriptions[name] = lifecycles[on](propListener);\n                }\n            });\n        },\n    };\n    managers.forEach(function (manager, i) {\n        lifecycles[\"on\" + names[i]] = function (handler) { return manager.add(handler); };\n        lifecycles[\"notify\" + names[i]] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\n        };\n    });\n    return lifecycles;\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    var _a;\n    for (var key in next) {\n        var nextValue = next[key];\n        var prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping to a new motion value, create a new motion value\n             * from that\n             */\n            element.addValue(key, motionValue(nextValue));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                var existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n            }\n        }\n    }\n    // Handle removed values\n    for (var key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n    var delta = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;\n    var target = _b.target;\n    /**\n     * Reset the corrected box with the latest values from box, as we're then going\n     * to perform mutative operations on it.\n     */\n    resetBox(layoutCorrected, layout);\n    /**\n     * Apply all the parent deltas to this box to produce the corrected box. This\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n     */\n    applyTreeDeltas(layoutCorrected, treeScale, treePath);\n    /**\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n     * to allow people to choose whether these styles are corrected based on just the\n     * layout reprojection or the final bounding box.\n     */\n    updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\n}\n\nvar FlatTree = /** @class */ (function () {\n    function FlatTree() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    FlatTree.prototype.add = function (child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.remove = function (child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.forEach = function (callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    };\n    return FlatTree;\n}());\n\nfunction setCurrentViewportBox(visualElement) {\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent) {\n        visualElement.rebaseProjectionTarget();\n        return;\n    }\n    var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    eachAxis(function (axis) {\n        visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n    });\n}\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\n        if (options === void 0) { options = {}; }\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender and onViewportBoxUpdate.\n         */\n        var lifecycles = createLifecycles();\n        /**\n         *\n         */\n        var projection = createProjectionState();\n        /**\n         * A reference to the nearest projecting parent. This is either\n         * undefined if we haven't looked for the nearest projecting parent,\n         * false if there is no parent performing layout projection, or a reference\n         * to the projecting parent.\n         */\n        var projectionParent;\n        /**\n         * This is a reference to the visual state of the \"lead\" visual element.\n         * Usually, this will be this visual element. But if it shares a layoutId\n         * with other visual elements, only one of them will be designated lead by\n         * AnimateSharedLayout. All the other visual elements will take on the visual\n         * appearance of the lead while they crossfade to it.\n         */\n        var leadProjection = projection;\n        var leadLatestValues = latestValues;\n        var unsubscribeFromLeadVisualElement;\n        /**\n         * The latest layout measurements and calculated projections. This\n         * is seperate from the target projection data in visualState as\n         * many visual elements might point to the same piece of visualState as\n         * a target, whereas they might each have different layouts and thus\n         * projection calculations needed to project into the same viewport box.\n         */\n        var layoutState = createLayoutState();\n        /**\n         *\n         */\n        var crossfader;\n        /**\n         * Keep track of whether the viewport box has been updated since the\n         * last time the layout projection was re-calculated.\n         */\n        var hasViewportBoxUpdated = false;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * x/y motion values that track the progress of initiated layout\n         * animations.\n         *\n         * TODO: Target for removal\n         */\n        var projectionTargetProgress;\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = tslib.__assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         *\n         */\n        function render() {\n            if (!instance)\n                return;\n            if (element.isProjectionReady()) {\n                /**\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n                 * This is the final box that we will then project into by calculating a transform delta and\n                 * applying it to the corrected box.\n                 */\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n                /**\n                 * Update the delta between the corrected box and the final target box, after\n                 * user-set transforms are applied to it. This will be used by the renderer to\n                 * create a transform style that will reproject the element from its actual layout\n                 * into the desired bounding box.\n                 */\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n            }\n            triggerBuild();\n            renderInstance(instance, renderState);\n        }\n        function triggerBuild() {\n            var valuesToRender = latestValues;\n            if (crossfader && crossfader.isActive()) {\n                var crossfadedValues = crossfader.getCrossfadeState(element);\n                if (crossfadedValues)\n                    valuesToRender = crossfadedValues;\n            }\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        function updateLayoutProjection() {\n            if (!element.isProjectionReady())\n                return;\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\n            var prevTreeScaleX = treeScale.x;\n            var prevTreeScaleY = treeScale.y;\n            var prevDeltaTransform = layoutState.deltaTransform;\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n            hasViewportBoxUpdated &&\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\n            hasViewportBoxUpdated = false;\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n            if (deltaTransform !== prevDeltaTransform ||\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\n                prevTreeScaleX !== treeScale.x ||\n                prevTreeScaleY !== treeScale.y) {\n                element.scheduleRender();\n            }\n            layoutState.deltaTransform = deltaTransform;\n        }\n        function updateTreeLayoutProjection() {\n            element.layoutTree.forEach(fireUpdateLayoutProjection);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync__default['default'].update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = tslib.__assign(tslib.__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             * An ancestor path back to the root visual element. This is used\n             * by layout projection to quickly recurse back up the tree.\n             */\n            path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), \n            /**\n             *\n             */\n            presenceId: presenceId,\n            projection: projection, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                instance = element.current = newInstance;\n                element.pointTo(element);\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n            },\n            /**\n             *\n             */\n            unmount: function () {\n                sync.cancelSync.update(update);\n                sync.cancelSync.render(render);\n                sync.cancelSync.preRender(element.updateLayoutProjection);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                element.stopLayoutAnimation();\n                element.layoutTree.remove(element);\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                lifecycles.clearAllListeners();\n            },\n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\n                }\n            },\n            sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * A method that schedules an update to layout projections throughout\n             * the tree. We inherit from the parent so there's only ever one\n             * job scheduled on the next frame - that of the root visual element.\n             */\n            scheduleUpdateLayoutProjection: parent\n                ? parent.scheduleUpdateLayoutProjection\n                : function () {\n                    return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\n                }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            },\n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            },\n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            },\n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            },\n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            },\n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                sync__default['default'].render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            },\n            // Layout projection ==============================\n            /**\n             * Enable layout projection for this visual element. Won't actually\n             * occur until we also have hydrated layout measurements.\n             */\n            enableLayoutProjection: function () {\n                projection.isEnabled = true;\n                element.layoutTree.add(element);\n            },\n            /**\n             * Lock the projection target, for instance when dragging, so\n             * nothing else can try and animate it.\n             */\n            lockProjectionTarget: function () {\n                projection.isTargetLocked = true;\n            },\n            unlockProjectionTarget: function () {\n                element.stopLayoutAnimation();\n                projection.isTargetLocked = false;\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\n                crossfader = newCrossfader;\n            }, isProjectionReady: function () {\n                return projection.isEnabled &&\n                    projection.isHydrated &&\n                    layoutState.isHydrated;\n            }, \n            /**\n             * Start a layout animation on a given axis.\n             */\n            startLayoutAnimation: function (axis, transition, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var progress = element.getProjectionAnimationProgress()[axis];\n                var _a = isRelative\n                    ? projection.relativeTarget[axis]\n                    : projection.target[axis], min = _a.min, max = _a.max;\n                var length = max - min;\n                progress.clearListeners();\n                progress.set(min);\n                progress.set(min); // Set twice to hard-reset velocity\n                progress.onChange(function (v) {\n                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n                });\n                return element.animateMotionValue(axis, progress, 0, transition);\n            },\n            /**\n             * Stop layout animations.\n             */\n            stopLayoutAnimation: function () {\n                eachAxis(function (axis) {\n                    return element.getProjectionAnimationProgress()[axis].stop();\n                });\n            },\n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function (withTransform) {\n                if (withTransform === void 0) { withTransform = true; }\n                var viewportBox = measureViewportBox(instance, options);\n                if (!withTransform)\n                    removeBoxTransforms(viewportBox, latestValues);\n                return viewportBox;\n            },\n            /**\n             * Get the motion values tracking the layout animations on each\n             * axis. Lazy init if not already created.\n             */\n            getProjectionAnimationProgress: function () {\n                projectionTargetProgress || (projectionTargetProgress = {\n                    x: motionValue(0),\n                    y: motionValue(0),\n                });\n                return projectionTargetProgress;\n            },\n            /**\n             * Update the projection of a single axis. Schedule an update to\n             * the tree layout projection.\n             */\n            setProjectionTargetAxis: function (axis, min, max, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var target;\n                if (isRelative) {\n                    if (!projection.relativeTarget) {\n                        projection.relativeTarget = axisBox();\n                    }\n                    target = projection.relativeTarget[axis];\n                }\n                else {\n                    projection.relativeTarget = undefined;\n                    target = projection.target[axis];\n                }\n                projection.isHydrated = true;\n                target.min = min;\n                target.max = max;\n                // Flag that we want to fire the onViewportBoxUpdate event handler\n                hasViewportBoxUpdated = true;\n                lifecycles.notifySetAxisTarget();\n            },\n            /**\n             * Rebase the projection target on top of the provided viewport box\n             * or the measured layout. This ensures that non-animating elements\n             * don't fall out of sync differences in measurements vs projections\n             * after a page scroll or other relayout.\n             */\n            rebaseProjectionTarget: function (force, box) {\n                if (box === void 0) { box = layoutState.layout; }\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\n                var shouldRebase = !projection.relativeTarget &&\n                    !projection.isTargetLocked &&\n                    !x.isAnimating() &&\n                    !y.isAnimating();\n                if (force || shouldRebase) {\n                    eachAxis(function (axis) {\n                        var _a = box[axis], min = _a.min, max = _a.max;\n                        element.setProjectionTargetAxis(axis, min, max);\n                    });\n                }\n            },\n            /**\n             * Notify the visual element that its layout is up-to-date.\n             * Currently Animate.tsx uses this to check whether a layout animation\n             * needs to be performed.\n             */\n            notifyLayoutReady: function (config) {\n                setCurrentViewportBox(element);\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n            }, \n            /**\n             * Temporarily reset the transform of the instance.\n             */\n            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,\n            updateTreeLayoutProjection: function () {\n                element.layoutTree.forEach(fireResolveRelativeTargetBox);\n                /**\n                 * Schedule the projection updates at the end of the current preRender\n                 * step. This will ensure that all layout trees will first resolve\n                 * relative projection boxes into viewport boxes, and *then*\n                 * update projections.\n                 */\n                sync__default['default'].preRender(updateTreeLayoutProjection, false, true);\n                // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n            },\n            getProjectionParent: function () {\n                if (projectionParent === undefined) {\n                    var foundParent = false;\n                    // Search backwards through the tree path\n                    for (var i = element.path.length - 1; i >= 0; i--) {\n                        var ancestor = element.path[i];\n                        if (ancestor.projection.isEnabled) {\n                            foundParent = ancestor;\n                            break;\n                        }\n                    }\n                    projectionParent = foundParent;\n                }\n                return projectionParent;\n            },\n            resolveRelativeTargetBox: function () {\n                var relativeParent = element.getProjectionParent();\n                if (!projection.relativeTarget || !relativeParent)\n                    return;\n                calcRelativeBox(projection, relativeParent.projection);\n                if (isDraggable(relativeParent)) {\n                    var target = projection.target;\n                    applyBoxTransforms(target, target, relativeParent.getLatestValues());\n                }\n            },\n            shouldResetTransform: function () {\n                return Boolean(props._layoutResetTransform);\n            },\n            /**\n             *\n             */\n            pointTo: function (newLead) {\n                leadProjection = newLead.projection;\n                leadLatestValues = newLead.getLatestValues();\n                /**\n                 * Subscribe to lead component's layout animations\n                 */\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n                    var _a;\n                    if (element.isPresent) {\n                        element.presence = Presence.Present;\n                    }\n                    else {\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n                    }\n                }));\n            }, \n            // TODO: Clean this up\n            isPresent: true, presence: Presence.Entering });\n        return element;\n    };\n};\nfunction fireResolveRelativeTargetBox(child) {\n    child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n    child.updateLayoutProjection();\n}\nvar variantProps = tslib.__spreadArray([\"initial\"], tslib.__read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\n\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === styleValueTypes.number || v === styleValueTypes.px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform)\n        return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n}; };\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a) {\n        var x = _a.x;\n        return x.max - x.min;\n    },\n    height: function (_a) {\n        var y = _a.y;\n        return y.max - y.min;\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = tslib.__assign({}, target);\n    transitionEnd = tslib.__assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var to = target[key];\n        var fromType = findDimensionValueType(from);\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    heyListen.invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === styleValueTypes.px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var _b = tslib.__read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance: function (domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            var computedStyle = getComputedStyle$1(domElement);\n            return ((isCSSVariable$1(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0);\n        }\n    },\n    sortNodePosition: function (a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function (props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function (element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return getBoundingBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform: function (element, domElement, props) {\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function (instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState: function (key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable: function (element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) { isMounted = true; }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return tslib.__assign({ transition: transition,\n            transitionEnd: transitionEnd }, target);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    },\n    render: renderHTML,\n};\nvar htmlVisualElement = visualElement(htmlConfig);\n\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), { getBaseTarget: function (props, key) {\n        return props[key];\n    },\n    readValueFromInstance: function (domElement, key) {\n        var _a;\n        if (isTransformProp(key)) {\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return domElement.getAttribute(key);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    }, render: renderSVG }));\n\nvar createDomVisualElement = function (Component, options) {\n    return isSVGComponent(Component)\n        ? svgVisualElement(options, { enableHardwareAcceleration: false })\n        : htmlVisualElement(options, { enableHardwareAcceleration: true });\n};\n\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/ createMotionProxy(function (Component, config) {\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\nfunction createDomMotionComponent(key) {\n    return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, featureBundle, createDomVisualElement));\n}\n\n/**\n * @public\n */\nvar m = createMotionProxy(createDomMotionConfig);\n\nfunction useForceUpdate() {\n    var unloadingRef = React.useRef(false);\n    var _a = tslib.__read(React.useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    useUnmountEffect(function () { return (unloadingRef.current = true); });\n    return React.useCallback(function () {\n        !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useConstant(getPresenceId);\n    var context = React.useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            presenceChildren.set(childId, true);\n            var allComplete = true;\n            presenceChildren.forEach(function (isComplete) {\n                if (!isComplete)\n                    allComplete = false;\n            });\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    React.useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React__namespace.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React__namespace.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    React.Children.forEach(children, function (child) {\n        if (React.isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = React.useContext(SharedLayoutContext);\n    if (isSharedLayout(layoutContext)) {\n        forceRender = layoutContext.forceUpdate;\n    }\n    var isInitialRender = React.useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = React.useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = React.useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = React.useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) { return (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren));\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React__namespace.createElement(React__namespace.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return React.cloneElement(child); })));\n};\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n    };\n}\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var prevOptions = tslib.__assign({}, options);\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = sync.getFrameData().timestamp;\n        };\n        transition = transition && getValueTransition(transition, \"crossfade\");\n        return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(target);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync__default['default'].read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = sync.getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = popmotion.mix(\n            /**\n             * If the follow child has been completely hidden we animate\n             * this opacity from its previous opacity, but otherwise from completely transparent.\n             */\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            var initialProgress = 0;\n            if (!options.prevValues && !options.follow) {\n                /**\n                 * If we're not coming from anywhere, start at the end of the animation.\n                 */\n                initialProgress = 1;\n            }\n            else if (prevOptions.lead === options.follow &&\n                prevOptions.follow === options.lead) {\n                /**\n                 * If we're swapping follow/lead we can reverse the progress\n                 */\n                initialProgress = 1 - progress.get();\n            }\n            progress.set(initialProgress);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            prevOptions = options;\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(popmotion.progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = tslib.__assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = tslib.__assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (\n            // Don't crossfade if we've just animated back from lead and switched the\n            // old follow to the new lead.\n            state.lead !== prevState.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            var _a;\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n                if (prevParent) {\n                    /**\n                     * We'll use this to determine if the element or its layoutId has been reparented.\n                     */\n                    config.prevParent = prevParent;\n                }\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nfunction resetRotate(child) {\n    // If there's no detected rotation values, we can early return without a forced render.\n    var hasRotate = false;\n    // Keep a record of all the values we've reset\n    var resetValues = {};\n    // Check the rotate value of all axes and reset to 0\n    for (var i = 0; i < transformAxes.length; i++) {\n        var axis = transformAxes[i];\n        var key = \"rotate\" + axis;\n        // If this rotation doesn't exist as a motion value, then we don't\n        // need to reset it\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\n            continue;\n        hasRotate = true;\n        // Record the rotation and then temporarily set it to 0\n        resetValues[key] = child.getStaticValue(key);\n        child.setStaticValue(key, 0);\n    }\n    // If there's no rotation values, we don't need to do any more.\n    if (!hasRotate)\n        return;\n    // Force a render of this element to apply the transform with all rotations\n    // set to 0.\n    child.syncRender();\n    // Put back all the values we reset\n    for (var key in resetValues) {\n        child.setStaticValue(key, resetValues[key]);\n    }\n    // Schedule a render for the next frame. This ensures we won't visually\n    // see the element with the reset rotate value applied.\n    child.scheduleRender();\n}\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    tslib.__extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = tslib.__assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React__namespace.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React__namespace.Component));\n\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction MotionConfig(_a) {\n    var children = _a.children, config = tslib.__rest(_a, [\"children\"]);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */\n    config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */\n    config.isStatic = useConstant(function () { return config.isStatic; });\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */\n    var transitionDependency = typeof config.transition === \"object\"\n        ? config.transition.toString()\n        : \"\";\n    var context = React.useMemo(function () { return config; }, [\n        transitionDependency,\n        config.transformPagePoint,\n    ]);\n    return (React__namespace.createElement(MotionConfigContext.Provider, { value: context }, children));\n}\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion(_a) {\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n    var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n    var loadedRenderer = React.useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */\n    if (!isLazyBundle(features)) {\n        var renderer = features.renderer, loadedFeatures = tslib.__rest(features, [\"renderer\"]);\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    React.useEffect(function () {\n        if (isLazyBundle(features)) {\n            features().then(function (_a) {\n                var renderer = _a.renderer, loadedFeatures = tslib.__rest(_a, [\"renderer\"]);\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return (React__namespace.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict: strict } }, children));\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\n\n/**\n * @public\n */\nvar domAnimation = tslib.__assign(tslib.__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);\n\n/**\n * @public\n */\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    var value = useConstant(function () { return motionValue(initial); });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = tslib.__read(React.useState(initial), 2), setLatest_1 = _a[1];\n        React.useEffect(function () { return value.onChange(setLatest_1); }, []);\n    }\n    return value;\n}\n\nfunction useOnChange(value, callback) {\n    React.useEffect(function () {\n        if (isMotionValue(value))\n            return value.onChange(callback);\n    }, [callback]);\n}\nfunction useMultiOnChange(values, handler) {\n    React.useEffect(function () {\n        var subscriptions = values.map(function (value) { return value.onChange(handler); });\n        return function () { return subscriptions.forEach(function (unsubscribe) { return unsubscribe(); }); };\n    });\n}\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    var value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    var updateValue = function () { return value.set(combineValues()); };\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useMultiOnChange(values, function () { return sync__default['default'].update(updateValue, false, true); });\n    return value;\n}\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    var numFragments = fragments.length;\n    function buildValue() {\n        var output = \"\";\n        for (var i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            var value = values[i];\n            if (value)\n                output += values[i].get();\n        }\n        return output;\n    }\n    return useCombineMotionValues(values, buildValue);\n}\n\nvar isCustomValueType = function (v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\nfunction transform() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({ mixer: getMixer(outputRange[0]) }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    var transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], function (_a) {\n            var _b = tslib.__read(_a, 1), latest = _b[0];\n            return transformer(latest);\n        });\n}\nfunction useListTransform(values, transformer) {\n    var latest = useConstant(function () { return []; });\n    return useCombineMotionValues(values, function () {\n        latest.length = 0;\n        var numValues = values.length;\n        for (var i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n    if (config === void 0) { config = {}; }\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var activeSpringAnimation = React.useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    React.useMemo(function () {\n        return value.attach(function (v, set) {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */\n            if (isStatic)\n                return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\n            return value.get();\n        });\n    }, Object.values(config));\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\n    return value;\n}\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\nfunction useVelocity(value) {\n    var velocity = useMotionValue(value.getVelocity());\n    React.useEffect(function () {\n        return value.velocityUpdateSubscribers.add(function (newVelocity) {\n            velocity.set(newVelocity);\n        });\n    }, [value]);\n    return velocity;\n}\n\nfunction createScrollMotionValues() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0),\n    };\n}\nfunction setProgress(offset, maxOffset, value) {\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n    var update = function () {\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\n        // Set absolute positions\n        values.scrollX.set(xOffset);\n        values.scrollY.set(yOffset);\n        // Set 0-1 progress\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n    };\n    update();\n    return update;\n}\n\nvar getElementScrollOffsets = function (element) { return function () {\n    return {\n        xOffset: element.scrollLeft,\n        yOffset: element.scrollTop,\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\n    };\n}; };\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction useElementScroll(ref) {\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function () {\n        var element = ref.current;\n        heyListen.invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n        if (!element)\n            return;\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n        return function () {\n            scrollListener && scrollListener();\n            resizeListener && resizeListener();\n        };\n    }, []);\n    return values;\n}\n\nvar viewportScrollValues;\nfunction getViewportScrollOffsets() {\n    return {\n        xOffset: window.pageXOffset,\n        yOffset: window.pageYOffset,\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\n    };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n    hasListeners = true;\n    if (typeof window === \"undefined\")\n        return;\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\n    addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\n * values as this breaks the browser's capability to accurately measure the page length.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\nfunction useViewportScroll() {\n    /**\n     * Lazy-initialise the viewport scroll values\n     */\n    if (!viewportScrollValues) {\n        viewportScrollValues = createScrollMotionValues();\n    }\n    useIsomorphicLayoutEffect(function () {\n        !hasListeners && addEventListeners();\n    }, []);\n    return viewportScrollValues;\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion;\nfunction initPrefersReducedMotion() {\n    prefersReducedMotion = motionValue(null);\n    if (typeof window === \"undefined\")\n        return;\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function () {\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.set(false);\n    }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */\n    !prefersReducedMotion && initPrefersReducedMotion();\n    var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\n    useOnChange(prefersReducedMotion, setShouldReduceMotion);\n    return shouldReduceMotion;\n}\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimation() {\n    var controls = useConstant(animationControls);\n    React.useEffect(controls.mount, []);\n    return controls;\n}\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    var index = React.useRef(0);\n    var _a = tslib.__read(React.useState(items[index.current]), 2), item = _a[0], setItem = _a[1];\n    return [\n        item,\n        function (next) {\n            index.current =\n                typeof next !== \"number\"\n                    ? popmotion.wrap(0, items.length, index.current + 1)\n                    : next;\n            setItem(items[index.current]);\n        },\n    ];\n}\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */ (function () {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    DragControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */\n    DragControls.prototype.start = function (event, options) {\n        this.componentControls.forEach(function (controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    DragControls.prototype.updateConstraints = function (flush) {\n        if (flush === void 0) { flush = true; }\n        this.componentControls.forEach(function (controls) {\n            controls.updateConstraints();\n        });\n        flush && flushLayout();\n    };\n    return DragControls;\n}());\nvar createDragControls = function () { return new DragControls(); };\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\nvar createObject = function () { return ({}); };\nvar stateVisualElement = visualElement({\n    build: function () { },\n    measureViewportBox: axisBox,\n    resetTransform: function () { },\n    restoreTransform: function () { },\n    removeValueFromRenderState: function () { },\n    render: function () { },\n    scrapeMotionValuesFromProps: createObject,\n    readValueFromInstance: function (_state, key, options) {\n        return options.initialState[key] || 0;\n    },\n    makeTargetAnimatable: function (element, _a) {\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        checkTargetForNewValues(element, target, origin);\n        return tslib.__assign({ transition: transition, transitionEnd: transitionEnd }, target);\n    },\n});\nvar useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject,\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\nfunction useAnimatedState(initialState) {\n    var _a = tslib.__read(React.useState(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\n    var visualState = useVisualState({}, false);\n    var element = useConstant(function () {\n        return stateVisualElement({ props: {}, visualState: visualState }, { initialState: initialState });\n    });\n    React.useEffect(function () {\n        element.mount({});\n        return element.unmount();\n    }, []);\n    React.useEffect(function () {\n        element.setProps({\n            onUpdate: function (v) { return setAnimationState(tslib.__assign({}, v)); },\n        });\n    });\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\n        return animateVisualElement(element, animationDefinition);\n    }; });\n    return [animationState, startAnimation];\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @deprecated\n * @internal\n */\nfunction useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useVisualElementContext();\n    heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX: scaleX, scaleY: scaleY };\n}\n\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SharedLayoutContext = SharedLayoutContext;\nexports.addScaleCorrection = addScaleCorrection;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.batchLayout = batchLayout;\nexports.createBatcher = createBatcher;\nexports.createCrossfader = createCrossfader;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.flushLayout = flushLayout;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.snapshotViewportBox = snapshotViewportBox;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useIsPresent = useIsPresent;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useSpring = useSpring;\nexports.useTransform = useTransform;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.visualElement = visualElement;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$tslib$tslib","~$module$node_modules$style_value_types$dist$valueTypes_cjs","~$module$node_modules$$emotion$is_prop_valid$dist$is_prop_valid_browser_cjs","~$module$node_modules$popmotion$dist$popmotion_cjs","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$hey_listen$dist$index","~$module$node_modules$framesync$dist$framesync_cjs"]],"~:properties",["^5",["transitionOverride","stop","removeValueFromRenderState","SharedLayoutContext","resolveMotionValue","originX","backgroundColor","timeConstant","stacks","layoutAnimation","animateMotionValue","updateLeadAndFollow","setOptions","z","repeatType","animateVisualElement","rotateZ","addScaleCorrection","transformPagePoint","backOut","presenceId","isDirty","AnimatePresence","isActive","yOffset","easeIn","onSessionStart","marginBottom","values","domAnimation","attrs","updateAndNotify","min","visualState","blockInitialAnimation","stopLayoutAnimation","dragConstraints","isAnimatingTree","width","updateLayoutProjection","pointercancel","renderer","origin","prevProp","right","readValueFromInstance","useElementScroll","passive","dragPropagation","forEach","deltaFinal","isDragging","addVariantChild","useDomEvent","top","relativeTarget","touchAction","resolve","renderState","enableHardwareAcceleration","measureViewportBox","rotateX","stiffness","WebkitTouchCallout","custom","currentDirection","onChange","xOffset","borderLeftWidth","getLayoutState","restDelta","circOut","totalPathLength","borderBottomColor","offset","getVelocity","translate","getDefaultTransition","prevDragCursor","layoutCorrected","getAxisMotionValue","originZ","height","fromLead","margin","numOctaves","preserveFollowOpacity","pointermove","PresenceContext","enableLayoutProjection","scale","createVisualElement","onUpdate","scrollYProgress","useReducedMotion","originY","transitionEnd","targetFinal","useAnimation","pageX","handlers","layoutTree","hasValue","constraints","onStart","setStaticValue","safeToRemove","useVisualState","animateChanges","createMotionComponent","scrollY","domMax","borderBottomRightRadius","ease","lastUpdated","isPresent","pointerdown","visualElement","isStatic","cancelDrag","resolveRefConstraints","translateY","passiveEffect","stopMotion","delta","snapshotViewportBox","cancelLayout","isLayoutDrag","treeScale","key","repeat","circIn","parent","removeListeners","process","children","getVariant","pointerleave","x","getLead","focus","__esModule","syncUpdate","lead","protectedKeys","pointTo","updateVisualElementAxis","max","radius","crossfadeOpacity","marginTop","path","startEvent","padding","useDeprecatedInvertedScale","xMaxOffset","isValidMotionProp","deltaTransform","isAnimated","userSelect","id","latestValues","flush","circInOut","timestamp","componentControls","removeValue","transform","bounceOut","layoutSafeToRemove","dragDirectionLock","stopAxisAnimation","makeTargetAnimatable","maxHeight","reset","pointerover","skewY","dragMomentum","AnimateSharedLayout","createRenderState","borderBottomWidth","needsAnimating","updateSubscribers","resolveDragConstraints","getVariantContext","onExitComplete","pan","animationControls","updateScheduled","updateTreeLayoutProjection","batchLayout","sortNodePosition","prevViewportBox","FlatTree","treeType","onRenderRequest","getValue","handlePointerMove","borderRightWidth","restSpeed","scheduleUpdateLayoutProjection","visibility","updatePoint","originPoint","setProps","constraintsBox","useTransform","scaleX","cursorProgress","motionValue","restoreTransform","borderWidth","useCycle","bounceIn","drag","onEnd","getState","setProjectionTargetAxis","applyTo","getStack","animate","framerSyncLayout","stroke","style","unlockProjectionTarget","attach","velocityUpdateSubscribers","animation","backInOut","getSnapshotBeforeUpdate","value","originBox","prevResolvedValues","dimensions","presenceAffectsLayout","addChild","destroy","updateAxisMotionValue","elastic","scrollXProgress","enumerable","getProjectionAnimationProgress","removeFromStack","linear","stopAnimation","initial","onMount","getInstance","MotionConfigContext","readValue","getClosestVariantNode","setBaseTarget","clearAllListeners","yMaxOffset","start","componentDidUpdate","prev","build","useRender","fill","borderBottomLeftRadius","bounceInOut","remove","currentAnimationTarget","layout","marginLeft","borderRadius","borderLeftColor","targetBox","distance","current","animationState","strokeOpacity","layoutId","isHydrated","getCrossfadeState","filter","isRelative","createBatcher","useDeprecatedAnimatedState","scaleY","register","setAnimateFunction","translateX","transformOrigin","variantChildren","pointerup","draggable","isExternalDrag","scalePoint","length","contextType","onComplete","snapToCursor","toLead","useMotionValue","componentDidMount","borderColor","props","isPresenceRoot","scheduleUpdate","prevParent","useSpring","onSessionEnd","flushLayout","lockProjectionTarget","duration","delay","FramerTreeLayoutContext","forwardMotionProps","history","shouldComponentUpdate","boxShadow","type","rebaseProjectionTarget","bounceDamping","pointerout","render","pageY","projection","presence","y","updateStacks","isProjectionReady","hasMounted","animateDragEnd","syncContext","hasMutatedConstraints","outlineColor","isVisible","ref","depth","zIndex","updatePropListeners","preloadedFeatures","onMove","from","bounceStiffness","target","scaleZ","pointerenter","DragControls","leadIsExiting","perspective","skewX","borderTopWidth","renderScheduled","unmount","getLayoutId","parse","initialState","exit","resolveRelativeTargetBox","startLayoutAnimation","Component","easeInOut","getProjectionParent","clearSnapshot","scrollX","lastMoveEventInfo","add","fillOpacity","componentWillUnmount","skew","bottom","createDomMotionComponent","set","strict","WebkitUserSelect","renderSubscribers","LazyMotion","follow","scrapeMotionValuesFromProps","updateHandlers","isTargetLocked","handlePointerUp","lastMoveEvent","frameTarget","maxWidth","size","borderRightColor","dragElastic","notify","easeOut","updateAxis","useMotionTemplate","repeatDelay","clear","addValue","mount","motion","forEachValue","getProps","getBaseTarget","setActive","startAxisValueAnimation","setVisibility","hover","updateConstraints","usePresence","MotionValue","syncLayout","notifyLayoutReady","useDragControls","syncRender","rotateY","translateZ","damping","removeChild","options","to","getPrevious","updateSnapshot","getStaticValue","scheduleRender","isMounted","unsubLayoutReady","transition","clearListeners","useViewportScroll","LayoutGroupContext","transformKeys","paddingLeft","prevValues","getLatestValues","forceUpdate","borderTopRightRadius","getSize","m","timeDelta","scheduleVelocityCheck","subscribe","get","borderTopLeftRadius","rotate","createCrossfader","tap","velocityCheck","color","addToStack","default","layoutReady","useIsPresent","useVelocity","backIn","anticipate","array","WebkitFilter","measureLayout","clearAnimation","resetTransform","opacity","end","point","left","manuallyAnimateOnMount","isAnimating","transformPerspective","VisibilityAction","canTrackVelocity","animateAxis","test","borderTopColor","shouldResetTransform","isEnabled","velocity","subscriptions","paddingBottom","paddingRight","MotionConfig","vars","setCrossfader","marginRight","openGlobalLock","mixer","hasAnimated","paddingTop","panSession"]],"~:compiled-at",1635155865367,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$framer_motion$dist$framer_motion_cjs.js\",\n\"lineCount\":285,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/framer-motion/dist/framer-motion.cjs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$framer_motion$dist$framer_motion_cjs\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar tslib = require('tslib');\\nvar React = require('react');\\nvar heyListen = require('hey-listen');\\nvar styleValueTypes = require('style-value-types');\\nvar popmotion = require('popmotion');\\nvar sync = require('framesync');\\n\\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\\n\\nfunction _interopNamespace(e) {\\n    if (e && e.__esModule) return e;\\n    var n = Object.create(null);\\n    if (e) {\\n        Object.keys(e).forEach(function (k) {\\n            if (k !== 'default') {\\n                var d = Object.getOwnPropertyDescriptor(e, k);\\n                Object.defineProperty(n, k, d.get ? d : {\\n                    enumerable: true,\\n                    get: function () {\\n                        return e[k];\\n                    }\\n                });\\n            }\\n        });\\n    }\\n    n['default'] = e;\\n    return Object.freeze(n);\\n}\\n\\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\\n\\nvar createDefinition = function (propNames) { return ({\\n    isEnabled: function (props) { return propNames.some(function (name) { return !!props[name]; }); },\\n}); };\\nvar featureDefinitions = {\\n    measureLayout: createDefinition([\\n        \\\"layout\\\",\\n        \\\"layoutId\\\",\\n        \\\"drag\\\",\\n        \\\"_layoutResetTransform\\\",\\n    ]),\\n    animation: createDefinition([\\n        \\\"animate\\\",\\n        \\\"exit\\\",\\n        \\\"variants\\\",\\n        \\\"whileHover\\\",\\n        \\\"whileTap\\\",\\n        \\\"whileFocus\\\",\\n        \\\"whileDrag\\\",\\n    ]),\\n    exit: createDefinition([\\\"exit\\\"]),\\n    drag: createDefinition([\\\"drag\\\", \\\"dragControls\\\"]),\\n    focus: createDefinition([\\\"whileFocus\\\"]),\\n    hover: createDefinition([\\\"whileHover\\\", \\\"onHoverStart\\\", \\\"onHoverEnd\\\"]),\\n    tap: createDefinition([\\\"whileTap\\\", \\\"onTap\\\", \\\"onTapStart\\\", \\\"onTapCancel\\\"]),\\n    pan: createDefinition([\\n        \\\"onPan\\\",\\n        \\\"onPanStart\\\",\\n        \\\"onPanSessionStart\\\",\\n        \\\"onPanEnd\\\",\\n    ]),\\n    layoutAnimation: createDefinition([\\\"layout\\\", \\\"layoutId\\\"]),\\n};\\nfunction loadFeatures(features) {\\n    for (var key in features) {\\n        var Component = features[key];\\n        if (Component !== null)\\n            featureDefinitions[key].Component = Component;\\n    }\\n}\\n\\nvar LazyContext = React.createContext({ strict: false });\\n\\nvar featureNames = Object.keys(featureDefinitions);\\nvar numFeatures = featureNames.length;\\n/**\\n * Load features via renderless components based on the provided MotionProps.\\n */\\nfunction useFeatures(props, visualElement, preloadedFeatures) {\\n    var features = [];\\n    var lazyContext = React.useContext(LazyContext);\\n    if (!visualElement)\\n        return null;\\n    /**\\n     * If we're in development mode, check to make sure we're not rendering a motion component\\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\\n     */\\n    if (process.env.NODE_ENV !== \\\"production\\\" &&\\n        preloadedFeatures &&\\n        lazyContext.strict) {\\n        heyListen.invariant(false, \\\"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\\\");\\n    }\\n    for (var i = 0; i < numFeatures; i++) {\\n        var name_1 = featureNames[i];\\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\\n        /**\\n         * It might be possible in the future to use this moment to\\n         * dynamically request functionality. In initial tests this\\n         * was producing a lot of duplication amongst bundles.\\n         */\\n        if (isEnabled(props) && Component) {\\n            features.push(React__namespace.createElement(Component, tslib.__assign({ key: name_1 }, props, { visualElement: visualElement })));\\n        }\\n    }\\n    return features;\\n}\\n\\n/**\\n * @public\\n */\\nvar MotionConfigContext = React.createContext({\\n    transformPagePoint: function (p) { return p; },\\n    isStatic: false,\\n});\\n\\nvar MotionContext = React.createContext({});\\nfunction useVisualElementContext() {\\n    return React.useContext(MotionContext).visualElement;\\n}\\n\\n/**\\n * @public\\n */\\nvar PresenceContext = React.createContext(null);\\n\\n/**\\n * Creates a constant value over the lifecycle of a component.\\n *\\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\\n * you can ensure that initialisers don't execute twice or more.\\n */\\nfunction useConstant(init) {\\n    var ref = React.useRef(null);\\n    if (ref.current === null) {\\n        ref.current = init();\\n    }\\n    return ref.current;\\n}\\n\\n/**\\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\\n * to access information about whether it's still present in the React tree.\\n *\\n * ```jsx\\n * import { usePresence } from \\\"framer-motion\\\"\\n *\\n * export const Component = () => {\\n *   const [isPresent, safeToRemove] = usePresence()\\n *\\n *   useEffect(() => {\\n *     !isPresent && setTimeout(safeToRemove, 1000)\\n *   }, [isPresent])\\n *\\n *   return <div />\\n * }\\n * ```\\n *\\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\\n *\\n * @public\\n */\\nfunction usePresence() {\\n    var context = React.useContext(PresenceContext);\\n    if (context === null)\\n        return [true, null];\\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\\n    // either be null or non-null for the lifespan of the component.\\n    // Replace with useOpaqueId when released in React\\n    var id = useUniqueId();\\n    React.useEffect(function () { return register(id); }, []);\\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\\n}\\n/**\\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\\n * There is no `safeToRemove` function.\\n *\\n * ```jsx\\n * import { useIsPresent } from \\\"framer-motion\\\"\\n *\\n * export const Component = () => {\\n *   const isPresent = useIsPresent()\\n *\\n *   useEffect(() => {\\n *     !isPresent && console.log(\\\"I've been removed!\\\")\\n *   }, [isPresent])\\n *\\n *   return <div />\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction useIsPresent() {\\n    return isPresent(React.useContext(PresenceContext));\\n}\\nfunction isPresent(context) {\\n    return context === null ? true : context.isPresent;\\n}\\nvar counter = 0;\\nvar incrementId = function () { return counter++; };\\nvar useUniqueId = function () { return useConstant(incrementId); };\\n\\n/**\\n * @internal\\n */\\nvar LayoutGroupContext = React.createContext(null);\\n\\nvar isBrowser = typeof window !== \\\"undefined\\\";\\n\\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\\n\\nfunction useLayoutId(_a) {\\n    var layoutId = _a.layoutId;\\n    var layoutGroupId = React.useContext(LayoutGroupContext);\\n    return layoutGroupId && layoutId !== undefined\\n        ? layoutGroupId + \\\"-\\\" + layoutId\\n        : layoutId;\\n}\\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\\n    var config = React.useContext(MotionConfigContext);\\n    var lazyContext = React.useContext(LazyContext);\\n    var parent = useVisualElementContext();\\n    var presenceContext = React.useContext(PresenceContext);\\n    var layoutId = useLayoutId(props);\\n    var visualElementRef = React.useRef(undefined);\\n    /**\\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\\n     */\\n    if (!createVisualElement)\\n        createVisualElement = lazyContext.renderer;\\n    if (!visualElementRef.current && createVisualElement) {\\n        visualElementRef.current = createVisualElement(Component, {\\n            visualState: visualState,\\n            parent: parent,\\n            props: tslib.__assign(tslib.__assign({}, props), { layoutId: layoutId }),\\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\\n        });\\n    }\\n    var visualElement = visualElementRef.current;\\n    useIsomorphicLayoutEffect(function () {\\n        if (!visualElement)\\n            return;\\n        visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), { layoutId: layoutId }));\\n        visualElement.isPresent = isPresent(presenceContext);\\n        visualElement.isPresenceRoot =\\n            !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\\n        /**\\n         * Fire a render to ensure the latest state is reflected on-screen.\\n         */\\n        visualElement.syncRender();\\n    });\\n    React.useEffect(function () {\\n        var _a;\\n        if (!visualElement)\\n            return;\\n        /**\\n         * In a future refactor we can replace the features-as-components and\\n         * have this loop through them all firing \\\"effect\\\" listeners\\n         */\\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\\n    });\\n    useIsomorphicLayoutEffect(function () { return function () { return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount(); }; }, []);\\n    return visualElement;\\n}\\n\\nfunction isRefObject(ref) {\\n    return (typeof ref === \\\"object\\\" &&\\n        Object.prototype.hasOwnProperty.call(ref, \\\"current\\\"));\\n}\\n\\n/**\\n * Creates a ref function that, when called, hydrates the provided\\n * external ref and VisualElement.\\n */\\nfunction useMotionRef(visualState, visualElement, externalRef) {\\n    return React.useCallback(function (instance) {\\n        var _a;\\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\\n        if (visualElement) {\\n            instance\\n                ? visualElement.mount(instance)\\n                : visualElement.unmount();\\n        }\\n        if (externalRef) {\\n            if (typeof externalRef === \\\"function\\\") {\\n                externalRef(instance);\\n            }\\n            else if (isRefObject(externalRef)) {\\n                externalRef.current = instance;\\n            }\\n        }\\n    }, \\n    /**\\n     * Only pass a new ref callback to React if we've received a visual element\\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\\n     * or other dependencies change.\\n     */\\n    [visualElement]);\\n}\\n\\n/**\\n * Decides if the supplied variable is an array of variant labels\\n */\\nfunction isVariantLabels(v) {\\n    return Array.isArray(v);\\n}\\n/**\\n * Decides if the supplied variable is variant label\\n */\\nfunction isVariantLabel(v) {\\n    return typeof v === \\\"string\\\" || isVariantLabels(v);\\n}\\n/**\\n * Creates an object containing the latest state of every MotionValue on a VisualElement\\n */\\nfunction getCurrent(visualElement) {\\n    var current = {};\\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\\n    return current;\\n}\\n/**\\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\\n */\\nfunction getVelocity$1(visualElement) {\\n    var velocity = {};\\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\\n    return velocity;\\n}\\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\\n    var _a;\\n    if (currentValues === void 0) { currentValues = {}; }\\n    if (currentVelocity === void 0) { currentVelocity = {}; }\\n    if (typeof definition === \\\"string\\\") {\\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\\n    }\\n    return typeof definition === \\\"function\\\"\\n        ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)\\n        : definition;\\n}\\nfunction resolveVariant(visualElement, definition, custom) {\\n    var props = visualElement.getProps();\\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\\n}\\nfunction checkIfControllingVariants(props) {\\n    var _a;\\n    return (typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \\\"function\\\" ||\\n        isVariantLabel(props.initial) ||\\n        isVariantLabel(props.animate) ||\\n        isVariantLabel(props.whileHover) ||\\n        isVariantLabel(props.whileDrag) ||\\n        isVariantLabel(props.whileTap) ||\\n        isVariantLabel(props.whileFocus) ||\\n        isVariantLabel(props.exit));\\n}\\nfunction checkIfVariantNode(props) {\\n    return Boolean(checkIfControllingVariants(props) || props.variants);\\n}\\n\\nfunction getCurrentTreeVariants(props, context) {\\n    if (checkIfControllingVariants(props)) {\\n        var initial = props.initial, animate = props.animate;\\n        return {\\n            initial: initial === false || isVariantLabel(initial)\\n                ? initial\\n                : undefined,\\n            animate: isVariantLabel(animate) ? animate : undefined,\\n        };\\n    }\\n    return props.inherit !== false ? context : {};\\n}\\n\\nfunction useCreateMotionContext(props, isStatic) {\\n    var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)), initial = _a.initial, animate = _a.animate;\\n    return React.useMemo(function () { return ({ initial: initial, animate: animate }); }, \\n    /**\\n     * Only break memoisation in static mode\\n     */\\n    isStatic\\n        ? [\\n            variantLabelsAsDependency(initial),\\n            variantLabelsAsDependency(animate),\\n        ]\\n        : []);\\n}\\nfunction variantLabelsAsDependency(prop) {\\n    return Array.isArray(prop) ? prop.join(\\\" \\\") : prop;\\n}\\n\\n/**\\n * Create a `motion` component.\\n *\\n * This function accepts a Component argument, which can be either a string (ie \\\"div\\\"\\n * for `motion.div`), or an actual React component.\\n *\\n * Alongside this is a config option which provides a way of rendering the provided\\n * component \\\"offline\\\", or outside the React render cycle.\\n *\\n * @internal\\n */\\nfunction createMotionComponent(_a) {\\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\\n    preloadedFeatures && loadFeatures(preloadedFeatures);\\n    function MotionComponent(props, externalRef) {\\n        /**\\n         * If we're rendering in a static environment, we only visually update the component\\n         * as a result of a React-rerender rather than interactions or animations. This\\n         * means we don't need to load additional memory structures like VisualElement,\\n         * or any gesture/animation features.\\n         */\\n        var isStatic = React.useContext(MotionConfigContext).isStatic;\\n        var features = null;\\n        /**\\n         * Create the tree context. This is memoized and will only trigger renders\\n         * when the current tree variant changes in static mode.\\n         */\\n        var context = useCreateMotionContext(props, isStatic);\\n        /**\\n         *\\n         */\\n        var visualState = useVisualState(props, isStatic);\\n        if (!isStatic && isBrowser) {\\n            /**\\n             * Create a VisualElement for this component. A VisualElement provides a common\\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\\n             * providing a way of rendering to these APIs outside of the React render loop\\n             * for more performant animations and interactions\\n             */\\n            context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\\n            /**\\n             * Load Motion gesture and animation features. These are rendered as renderless\\n             * components so each feature can optionally make use of React lifecycle methods.\\n             *\\n             * TODO: The intention is to move these away from a React-centric to a\\n             * VisualElement-centric lifecycle scheme.\\n             */\\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\\n        }\\n        /**\\n         * The mount order and hierarchy is specific to ensure our element ref\\n         * is hydrated by the time features fire their effects.\\n         */\\n        return (React__namespace.createElement(React__namespace.Fragment, null,\\n            React__namespace.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\\n            features));\\n    }\\n    return React.forwardRef(MotionComponent);\\n}\\n\\n/**\\n * Convert any React component into a `motion` component. The provided component\\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\\n *\\n * ```jsx\\n * const Component = React.forwardRef((props, ref) => {\\n *   return <div ref={ref} />\\n * })\\n *\\n * const MotionComponent = motion(Component)\\n * ```\\n *\\n * @public\\n */\\nfunction createMotionProxy(createConfig) {\\n    function custom(Component, customMotionComponentConfig) {\\n        if (customMotionComponentConfig === void 0) { customMotionComponentConfig = {}; }\\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\\n    }\\n    /**\\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\\n     * Rather than generating them anew every render.\\n     */\\n    var componentCache = new Map();\\n    return new Proxy(custom, {\\n        /**\\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\\n         * DOM component with that name.\\n         */\\n        get: function (_target, key) {\\n            /**\\n             * If this element doesn't exist in the component cache, create it and cache.\\n             */\\n            if (!componentCache.has(key)) {\\n                componentCache.set(key, custom(key));\\n            }\\n            return componentCache.get(key);\\n        },\\n    });\\n}\\n\\n/**\\n * We keep these listed seperately as we use the lowercase tag names as part\\n * of the runtime bundle to detect SVG components\\n */\\nvar lowercaseSVGElements = [\\n    \\\"animate\\\",\\n    \\\"circle\\\",\\n    \\\"defs\\\",\\n    \\\"desc\\\",\\n    \\\"ellipse\\\",\\n    \\\"g\\\",\\n    \\\"image\\\",\\n    \\\"line\\\",\\n    \\\"filter\\\",\\n    \\\"marker\\\",\\n    \\\"mask\\\",\\n    \\\"metadata\\\",\\n    \\\"path\\\",\\n    \\\"pattern\\\",\\n    \\\"polygon\\\",\\n    \\\"polyline\\\",\\n    \\\"rect\\\",\\n    \\\"stop\\\",\\n    \\\"svg\\\",\\n    \\\"switch\\\",\\n    \\\"symbol\\\",\\n    \\\"text\\\",\\n    \\\"tspan\\\",\\n    \\\"use\\\",\\n    \\\"view\\\",\\n];\\n\\nfunction isSVGComponent(Component) {\\n    if (\\n    /**\\n     * If it's not a string, it's a custom React component. Currently we only support\\n     * HTML custom React components.\\n     */\\n    typeof Component !== \\\"string\\\" ||\\n        /**\\n         * If it contains a dash, the element is a custom HTML webcomponent.\\n         */\\n        Component.includes(\\\"-\\\")) {\\n        return false;\\n    }\\n    else if (\\n    /**\\n     * If it's in our list of lowercase SVG tags, it's an SVG component\\n     */\\n    lowercaseSVGElements.indexOf(Component) > -1 ||\\n        /**\\n         * If it contains a capital letter, it's an SVG component\\n         */\\n        /[A-Z]/.test(Component)) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\nvar valueScaleCorrection = {};\\n/**\\n * @internal\\n */\\nfunction addScaleCorrection(correctors) {\\n    for (var key in correctors) {\\n        valueScaleCorrection[key] = correctors[key];\\n    }\\n}\\n\\n/**\\n * A list of all transformable axes. We'll use this list to generated a version\\n * of each axes for each transform.\\n */\\nvar transformAxes = [\\\"\\\", \\\"X\\\", \\\"Y\\\", \\\"Z\\\"];\\n/**\\n * An ordered array of each transformable value. By default, transform values\\n * will be sorted to this order.\\n */\\nvar order = [\\\"translate\\\", \\\"scale\\\", \\\"rotate\\\", \\\"skew\\\"];\\n/**\\n * Generate a list of every possible transform key.\\n */\\nvar transformProps = [\\\"transformPerspective\\\", \\\"x\\\", \\\"y\\\", \\\"z\\\"];\\norder.forEach(function (operationKey) {\\n    return transformAxes.forEach(function (axesKey) {\\n        return transformProps.push(operationKey + axesKey);\\n    });\\n});\\n/**\\n * A function to use with Array.sort to sort transform keys by their default order.\\n */\\nfunction sortTransformProps(a, b) {\\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\\n}\\n/**\\n * A quick lookup for transform props.\\n */\\nvar transformPropSet = new Set(transformProps);\\nfunction isTransformProp(key) {\\n    return transformPropSet.has(key);\\n}\\n/**\\n * A quick lookup for transform origin props\\n */\\nvar transformOriginProps = new Set([\\\"originX\\\", \\\"originY\\\", \\\"originZ\\\"]);\\nfunction isTransformOriginProp(key) {\\n    return transformOriginProps.has(key);\\n}\\n\\nfunction isForcedMotionValue(key, _a) {\\n    var layout = _a.layout, layoutId = _a.layoutId;\\n    return (isTransformProp(key) ||\\n        isTransformOriginProp(key) ||\\n        ((layout || layoutId !== undefined) &&\\n            (!!valueScaleCorrection[key] || key === \\\"opacity\\\")));\\n}\\n\\nvar isMotionValue = function (value) {\\n    return value !== null && typeof value === \\\"object\\\" && value.getVelocity;\\n};\\n\\nvar translateAlias = {\\n    x: \\\"translateX\\\",\\n    y: \\\"translateY\\\",\\n    z: \\\"translateZ\\\",\\n    transformPerspective: \\\"perspective\\\",\\n};\\n/**\\n * Build a CSS transform style from individual x/y/scale etc properties.\\n *\\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\\n * providing a transformTemplate function.\\n */\\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\\n    var transform = _a.transform, transformKeys = _a.transformKeys;\\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\\n    // The transform string we're going to build into.\\n    var transformString = \\\"\\\";\\n    // Transform keys into their default order - this will determine the output order.\\n    transformKeys.sort(sortTransformProps);\\n    // Track whether the defined transform has a defined z so we don't add a\\n    // second to enable hardware acceleration\\n    var transformHasZ = false;\\n    // Loop over each transform and build them into transformString\\n    var numTransformKeys = transformKeys.length;\\n    for (var i = 0; i < numTransformKeys; i++) {\\n        var key = transformKeys[i];\\n        transformString += (translateAlias[key] || key) + \\\"(\\\" + transform[key] + \\\") \\\";\\n        if (key === \\\"z\\\")\\n            transformHasZ = true;\\n    }\\n    if (!transformHasZ && enableHardwareAcceleration) {\\n        transformString += \\\"translateZ(0)\\\";\\n    }\\n    else {\\n        transformString = transformString.trim();\\n    }\\n    // If we have a custom `transform` template, pass our transform values and\\n    // generated transformString to that before returning\\n    if (transformTemplate) {\\n        transformString = transformTemplate(transform, transformIsDefault ? \\\"\\\" : transformString);\\n    }\\n    else if (allowTransformNone && transformIsDefault) {\\n        transformString = \\\"none\\\";\\n    }\\n    return transformString;\\n}\\n/**\\n * Build a transformOrigin style. Uses the same defaults as the browser for\\n * undefined origins.\\n */\\nfunction buildTransformOrigin(_a) {\\n    var _b = _a.originX, originX = _b === void 0 ? \\\"50%\\\" : _b, _c = _a.originY, originY = _c === void 0 ? \\\"50%\\\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\\n    return originX + \\\" \\\" + originY + \\\" \\\" + originZ;\\n}\\n\\n/**\\n * Returns true if the provided key is a CSS variable\\n */\\nfunction isCSSVariable$1(key) {\\n    return key.startsWith(\\\"--\\\");\\n}\\n\\n/**\\n * Provided a value and a ValueType, returns the value as that value type.\\n */\\nvar getValueAsType = function (value, type) {\\n    return type && typeof value === \\\"number\\\"\\n        ? type.transform(value)\\n        : value;\\n};\\n\\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), { transform: Math.round });\\n\\nvar numberValueTypes = {\\n    // Border props\\n    borderWidth: styleValueTypes.px,\\n    borderTopWidth: styleValueTypes.px,\\n    borderRightWidth: styleValueTypes.px,\\n    borderBottomWidth: styleValueTypes.px,\\n    borderLeftWidth: styleValueTypes.px,\\n    borderRadius: styleValueTypes.px,\\n    radius: styleValueTypes.px,\\n    borderTopLeftRadius: styleValueTypes.px,\\n    borderTopRightRadius: styleValueTypes.px,\\n    borderBottomRightRadius: styleValueTypes.px,\\n    borderBottomLeftRadius: styleValueTypes.px,\\n    // Positioning props\\n    width: styleValueTypes.px,\\n    maxWidth: styleValueTypes.px,\\n    height: styleValueTypes.px,\\n    maxHeight: styleValueTypes.px,\\n    size: styleValueTypes.px,\\n    top: styleValueTypes.px,\\n    right: styleValueTypes.px,\\n    bottom: styleValueTypes.px,\\n    left: styleValueTypes.px,\\n    // Spacing props\\n    padding: styleValueTypes.px,\\n    paddingTop: styleValueTypes.px,\\n    paddingRight: styleValueTypes.px,\\n    paddingBottom: styleValueTypes.px,\\n    paddingLeft: styleValueTypes.px,\\n    margin: styleValueTypes.px,\\n    marginTop: styleValueTypes.px,\\n    marginRight: styleValueTypes.px,\\n    marginBottom: styleValueTypes.px,\\n    marginLeft: styleValueTypes.px,\\n    // Transform props\\n    rotate: styleValueTypes.degrees,\\n    rotateX: styleValueTypes.degrees,\\n    rotateY: styleValueTypes.degrees,\\n    rotateZ: styleValueTypes.degrees,\\n    scale: styleValueTypes.scale,\\n    scaleX: styleValueTypes.scale,\\n    scaleY: styleValueTypes.scale,\\n    scaleZ: styleValueTypes.scale,\\n    skew: styleValueTypes.degrees,\\n    skewX: styleValueTypes.degrees,\\n    skewY: styleValueTypes.degrees,\\n    distance: styleValueTypes.px,\\n    translateX: styleValueTypes.px,\\n    translateY: styleValueTypes.px,\\n    translateZ: styleValueTypes.px,\\n    x: styleValueTypes.px,\\n    y: styleValueTypes.px,\\n    z: styleValueTypes.px,\\n    perspective: styleValueTypes.px,\\n    transformPerspective: styleValueTypes.px,\\n    opacity: styleValueTypes.alpha,\\n    originX: styleValueTypes.progressPercentage,\\n    originY: styleValueTypes.progressPercentage,\\n    originZ: styleValueTypes.px,\\n    // Misc\\n    zIndex: int,\\n    // SVG\\n    fillOpacity: styleValueTypes.alpha,\\n    strokeOpacity: styleValueTypes.alpha,\\n    numOctaves: int,\\n};\\n\\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\\n    var _a;\\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\\n    // Empty the transformKeys array. As we're throwing out refs to its items\\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\\n    // with a manual incrementation would be better.\\n    transformKeys.length = 0;\\n    // Track whether we encounter any transform or transformOrigin values.\\n    var hasTransform = false;\\n    var hasTransformOrigin = false;\\n    // Does the calculated transform essentially equal \\\"none\\\"?\\n    var transformIsNone = true;\\n    /**\\n     * Loop over all our latest animated values and decide whether to handle them\\n     * as a style or CSS variable.\\n     *\\n     * Transforms and transform origins are kept seperately for further processing.\\n     */\\n    for (var key in latestValues) {\\n        var value = latestValues[key];\\n        /**\\n         * If this is a CSS variable we don't do any further processing.\\n         */\\n        if (isCSSVariable$1(key)) {\\n            vars[key] = value;\\n            continue;\\n        }\\n        // Convert the value to its default value type, ie 0 -> \\\"0px\\\"\\n        var valueType = numberValueTypes[key];\\n        var valueAsType = getValueAsType(value, valueType);\\n        if (isTransformProp(key)) {\\n            // If this is a transform, flag to enable further transform processing\\n            hasTransform = true;\\n            transform[key] = valueAsType;\\n            transformKeys.push(key);\\n            // If we already know we have a non-default transform, early return\\n            if (!transformIsNone)\\n                continue;\\n            // Otherwise check to see if this is a default transform\\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))\\n                transformIsNone = false;\\n        }\\n        else if (isTransformOriginProp(key)) {\\n            transformOrigin[key] = valueAsType;\\n            // If this is a transform origin, flag and enable further transform-origin processing\\n            hasTransformOrigin = true;\\n        }\\n        else {\\n            /**\\n             * If layout projection is on, and we need to perform scale correction for this\\n             * value type, perform it.\\n             */\\n            if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) &&\\n                (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) &&\\n                valueScaleCorrection[key]) {\\n                var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\\n                /**\\n                 * Scale-correctable values can define a number of other values to break\\n                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\\n                 */\\n                var applyTo = valueScaleCorrection[key].applyTo;\\n                if (applyTo) {\\n                    var num = applyTo.length;\\n                    for (var i = 0; i < num; i++) {\\n                        style[applyTo[i]] = correctedValue;\\n                    }\\n                }\\n                else {\\n                    style[key] = correctedValue;\\n                }\\n            }\\n            else {\\n                style[key] = valueAsType;\\n            }\\n        }\\n    }\\n    if (layoutState &&\\n        projection &&\\n        buildProjectionTransform &&\\n        buildProjectionTransformOrigin) {\\n        style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\\n        if (transformTemplate) {\\n            style.transform = transformTemplate(transform, style.transform);\\n        }\\n        style.transformOrigin = buildProjectionTransformOrigin(layoutState);\\n    }\\n    else {\\n        if (hasTransform) {\\n            style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\\n        }\\n        if (hasTransformOrigin) {\\n            style.transformOrigin = buildTransformOrigin(transformOrigin);\\n        }\\n    }\\n}\\n\\nvar createHtmlRenderState = function () { return ({\\n    style: {},\\n    transform: {},\\n    transformKeys: [],\\n    transformOrigin: {},\\n    vars: {},\\n}); };\\n\\nfunction copyRawValuesOnly(target, source, props) {\\n    for (var key in source) {\\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\\n            target[key] = source[key];\\n        }\\n    }\\n}\\nfunction useInitialMotionValues(_a, visualState, isStatic) {\\n    var transformTemplate = _a.transformTemplate;\\n    return React.useMemo(function () {\\n        var state = createHtmlRenderState();\\n        buildHTMLStyles(state, visualState, undefined, undefined, { enableHardwareAcceleration: !isStatic }, transformTemplate);\\n        var vars = state.vars, style = state.style;\\n        return tslib.__assign(tslib.__assign({}, vars), style);\\n    }, [visualState]);\\n}\\nfunction useStyle(props, visualState, isStatic) {\\n    var styleProp = props.style || {};\\n    var style = {};\\n    /**\\n     * Copy non-Motion Values straight into style\\n     */\\n    copyRawValuesOnly(style, styleProp, props);\\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\\n    if (props.transformValues) {\\n        style = props.transformValues(style);\\n    }\\n    return style;\\n}\\nfunction useHTMLProps(props, visualState, isStatic) {\\n    // The `any` isn't ideal but it is the type of createElement props argument\\n    var htmlProps = {};\\n    var style = useStyle(props, visualState, isStatic);\\n    if (Boolean(props.drag)) {\\n        // Disable the ghost element when a user drags\\n        htmlProps.draggable = false;\\n        // Disable text selection\\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout =\\n            \\\"none\\\";\\n        // Disable scrolling on the draggable direction\\n        style.touchAction =\\n            props.drag === true\\n                ? \\\"none\\\"\\n                : \\\"pan-\\\" + (props.drag === \\\"x\\\" ? \\\"y\\\" : \\\"x\\\");\\n    }\\n    htmlProps.style = style;\\n    return htmlProps;\\n}\\n\\n/**\\n * A list of all valid MotionProps.\\n *\\n * @internalremarks\\n * This doesn't throw if a `MotionProp` name is missing - it should.\\n */\\nvar validMotionProps = new Set([\\n    \\\"initial\\\",\\n    \\\"animate\\\",\\n    \\\"exit\\\",\\n    \\\"style\\\",\\n    \\\"variants\\\",\\n    \\\"transition\\\",\\n    \\\"transformTemplate\\\",\\n    \\\"transformValues\\\",\\n    \\\"custom\\\",\\n    \\\"inherit\\\",\\n    \\\"layout\\\",\\n    \\\"layoutId\\\",\\n    \\\"_layoutResetTransform\\\",\\n    \\\"onLayoutAnimationComplete\\\",\\n    \\\"onViewportBoxUpdate\\\",\\n    \\\"onLayoutMeasure\\\",\\n    \\\"onBeforeLayoutMeasure\\\",\\n    \\\"onAnimationStart\\\",\\n    \\\"onAnimationComplete\\\",\\n    \\\"onUpdate\\\",\\n    \\\"onDragStart\\\",\\n    \\\"onDrag\\\",\\n    \\\"onDragEnd\\\",\\n    \\\"onMeasureDragConstraints\\\",\\n    \\\"onDirectionLock\\\",\\n    \\\"onDragTransitionEnd\\\",\\n    \\\"drag\\\",\\n    \\\"dragControls\\\",\\n    \\\"dragListener\\\",\\n    \\\"dragConstraints\\\",\\n    \\\"dragDirectionLock\\\",\\n    \\\"_dragX\\\",\\n    \\\"_dragY\\\",\\n    \\\"dragElastic\\\",\\n    \\\"dragMomentum\\\",\\n    \\\"dragPropagation\\\",\\n    \\\"dragTransition\\\",\\n    \\\"whileDrag\\\",\\n    \\\"onPan\\\",\\n    \\\"onPanStart\\\",\\n    \\\"onPanEnd\\\",\\n    \\\"onPanSessionStart\\\",\\n    \\\"onTap\\\",\\n    \\\"onTapStart\\\",\\n    \\\"onTapCancel\\\",\\n    \\\"onHoverStart\\\",\\n    \\\"onHoverEnd\\\",\\n    \\\"whileFocus\\\",\\n    \\\"whileTap\\\",\\n    \\\"whileHover\\\",\\n]);\\n/**\\n * Check whether a prop name is a valid `MotionProp` key.\\n *\\n * @param key - Name of the property to check\\n * @returns `true` is key is a valid `MotionProp`.\\n *\\n * @public\\n */\\nfunction isValidMotionProp(key) {\\n    return validMotionProps.has(key);\\n}\\n\\nvar shouldForward = function (key) { return !isValidMotionProp(key); };\\n/**\\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\\n * of these should be passed to the underlying DOM node.\\n *\\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\\n *\\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\\n * actually required.\\n */\\ntry {\\n    var emotionIsPropValid_1 = require(\\\"@emotion/is-prop-valid\\\").default;\\n    shouldForward = function (key) {\\n        // Handle events explicitly as Emotion validates them all as true\\n        if (key.startsWith(\\\"on\\\")) {\\n            return !isValidMotionProp(key);\\n        }\\n        else {\\n            return emotionIsPropValid_1(key);\\n        }\\n    };\\n}\\ncatch (_a) {\\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\\n}\\nfunction filterProps(props, isDom, forwardMotionProps) {\\n    var filteredProps = {};\\n    for (var key in props) {\\n        if (shouldForward(key) ||\\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\\n            (!isDom && !isValidMotionProp(key))) {\\n            filteredProps[key] = props[key];\\n        }\\n    }\\n    return filteredProps;\\n}\\n\\nfunction calcOrigin$1(origin, offset, size) {\\n    return typeof origin === \\\"string\\\"\\n        ? origin\\n        : styleValueTypes.px.transform(offset + size * origin);\\n}\\n/**\\n * The SVG transform origin defaults are different to CSS and is less intuitive,\\n * so we use the measured dimensions of the SVG to reconcile these.\\n */\\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\\n    return pxOriginX + \\\" \\\" + pxOriginY;\\n}\\n\\n// Convert a progress 0-1 to a pixels value based on the provided length\\nvar progressToPixels = function (progress, length) {\\n    return styleValueTypes.px.transform(progress * length);\\n};\\nvar dashKeys = {\\n    offset: \\\"stroke-dashoffset\\\",\\n    array: \\\"stroke-dasharray\\\",\\n};\\nvar camelKeys = {\\n    offset: \\\"strokeDashoffset\\\",\\n    array: \\\"strokeDasharray\\\",\\n};\\n/**\\n * Build SVG path properties. Uses the path's measured length to convert\\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\\n * and stroke-dasharray attributes.\\n *\\n * This function is mutative to reduce per-frame GC.\\n */\\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\\n    if (spacing === void 0) { spacing = 1; }\\n    if (offset === void 0) { offset = 0; }\\n    if (useDashCase === void 0) { useDashCase = true; }\\n    // We use dash case when setting attributes directly to the DOM node and camel case\\n    // when defining props on a React component.\\n    var keys = useDashCase ? dashKeys : camelKeys;\\n    // Build the dash offset\\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\\n    // Build the dash array\\n    var pathLength = progressToPixels(length, totalLength);\\n    var pathSpacing = progressToPixels(spacing, totalLength);\\n    attrs[keys.array] = pathLength + \\\" \\\" + pathSpacing;\\n}\\n\\n/**\\n * Build SVG visual attrbutes, like cx and style.transform\\n */\\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \\n    // This is object creation, which we try to avoid per-frame.\\n    latest = tslib.__rest(_a, [\\\"attrX\\\", \\\"attrY\\\", \\\"originX\\\", \\\"originY\\\", \\\"pathLength\\\", \\\"pathSpacing\\\", \\\"pathOffset\\\"]);\\n    buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\\n    state.attrs = state.style;\\n    state.style = {};\\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;\\n    /**\\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\\n     * and copy it into style.\\n     */\\n    if (attrs.transform) {\\n        if (dimensions)\\n            style.transform = attrs.transform;\\n        delete attrs.transform;\\n    }\\n    // Parse transformOrigin\\n    if (dimensions &&\\n        (originX !== undefined || originY !== undefined || style.transform)) {\\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\\n    }\\n    // Treat x/y not as shortcuts but as actual attributes\\n    if (attrX !== undefined)\\n        attrs.x = attrX;\\n    if (attrY !== undefined)\\n        attrs.y = attrY;\\n    // Build SVG path if one has been measured\\n    if (totalPathLength !== undefined && pathLength !== undefined) {\\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\\n    }\\n}\\n\\nvar createSvgRenderState = function () { return (tslib.__assign(tslib.__assign({}, createHtmlRenderState()), { attrs: {} })); };\\n\\nfunction useSVGProps(props, visualState) {\\n    var visualProps = React.useMemo(function () {\\n        var state = createSvgRenderState();\\n        buildSVGAttrs(state, visualState, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\\n        return tslib.__assign(tslib.__assign({}, state.attrs), { style: tslib.__assign({}, state.style) });\\n    }, [visualState]);\\n    if (props.style) {\\n        var rawStyles = {};\\n        copyRawValuesOnly(rawStyles, props.style, props);\\n        visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\\n    }\\n    return visualProps;\\n}\\n\\nfunction createUseRender(forwardMotionProps) {\\n    if (forwardMotionProps === void 0) { forwardMotionProps = false; }\\n    var useRender = function (Component, props, ref, _a, isStatic) {\\n        var latestValues = _a.latestValues;\\n        var useVisualProps = isSVGComponent(Component)\\n            ? useSVGProps\\n            : useHTMLProps;\\n        var visualProps = useVisualProps(props, latestValues, isStatic);\\n        var filteredProps = filterProps(props, typeof Component === \\\"string\\\", forwardMotionProps);\\n        var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), { ref: ref });\\n        return React.createElement(Component, elementProps);\\n    };\\n    return useRender;\\n}\\n\\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\\nvar REPLACE_TEMPLATE = \\\"$1-$2\\\";\\n/**\\n * Convert camelCase to dash-case properties.\\n */\\nvar camelToDash = function (str) {\\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\\n};\\n\\nfunction renderHTML(element, _a) {\\n    var style = _a.style, vars = _a.vars;\\n    // Directly assign style into the Element's style prop. In tests Object.assign is the\\n    // fastest way to assign styles.\\n    Object.assign(element.style, style);\\n    // Loop over any CSS variables and assign those.\\n    for (var key in vars) {\\n        element.style.setProperty(key, vars[key]);\\n    }\\n}\\n\\n/**\\n * A set of attribute names that are always read/written as camel case.\\n */\\nvar camelCaseAttributes = new Set([\\n    \\\"baseFrequency\\\",\\n    \\\"diffuseConstant\\\",\\n    \\\"kernelMatrix\\\",\\n    \\\"kernelUnitLength\\\",\\n    \\\"keySplines\\\",\\n    \\\"keyTimes\\\",\\n    \\\"limitingConeAngle\\\",\\n    \\\"markerHeight\\\",\\n    \\\"markerWidth\\\",\\n    \\\"numOctaves\\\",\\n    \\\"targetX\\\",\\n    \\\"targetY\\\",\\n    \\\"surfaceScale\\\",\\n    \\\"specularConstant\\\",\\n    \\\"specularExponent\\\",\\n    \\\"stdDeviation\\\",\\n    \\\"tableValues\\\",\\n    \\\"viewBox\\\",\\n    \\\"gradientTransform\\\",\\n]);\\n\\nfunction renderSVG(element, renderState) {\\n    renderHTML(element, renderState);\\n    for (var key in renderState.attrs) {\\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\\n    }\\n}\\n\\nfunction scrapeMotionValuesFromProps$1(props) {\\n    var style = props.style;\\n    var newValues = {};\\n    for (var key in style) {\\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\\n            newValues[key] = style[key];\\n        }\\n    }\\n    return newValues;\\n}\\n\\nfunction scrapeMotionValuesFromProps(props) {\\n    var newValues = scrapeMotionValuesFromProps$1(props);\\n    for (var key in props) {\\n        if (isMotionValue(props[key])) {\\n            var targetKey = key === \\\"x\\\" || key === \\\"y\\\" ? \\\"attr\\\" + key.toUpperCase() : key;\\n            newValues[targetKey] = props[key];\\n        }\\n    }\\n    return newValues;\\n}\\n\\nfunction isAnimationControls(v) {\\n    return typeof v === \\\"object\\\" && typeof v.start === \\\"function\\\";\\n}\\n\\nvar isKeyframesTarget = function (v) {\\n    return Array.isArray(v);\\n};\\n\\nvar isCustomValue = function (v) {\\n    return Boolean(v && typeof v === \\\"object\\\" && v.mix && v.toValue);\\n};\\nvar resolveFinalValueInKeyframes = function (v) {\\n    // TODO maybe throw if v.length - 1 is placeholder token?\\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\\n};\\n\\n/**\\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\\n *\\n * TODO: Remove and move to library\\n *\\n * @internal\\n */\\nfunction resolveMotionValue(value) {\\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\\n    return isCustomValue(unwrappedValue)\\n        ? unwrappedValue.toValue()\\n        : unwrappedValue;\\n}\\n\\nfunction makeState(_a, props, context, presenceContext) {\\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\\n    var state = {\\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\\n        renderState: createRenderState(),\\n    };\\n    if (onMount) {\\n        state.mount = function (instance) { return onMount(props, instance, state); };\\n    }\\n    return state;\\n}\\nvar makeUseVisualState = function (config) { return function (props, isStatic) {\\n    var context = React.useContext(MotionContext);\\n    var presenceContext = React.useContext(PresenceContext);\\n    return isStatic\\n        ? makeState(config, props, context, presenceContext)\\n        : useConstant(function () { return makeState(config, props, context, presenceContext); });\\n}; };\\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\\n    var values = {};\\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\\n    var motionValues = scrapeMotionValues(props);\\n    for (var key in motionValues) {\\n        values[key] = resolveMotionValue(motionValues[key]);\\n    }\\n    var initial = props.initial, animate = props.animate;\\n    var isControllingVariants = checkIfControllingVariants(props);\\n    var isVariantNode = checkIfVariantNode(props);\\n    if (context &&\\n        isVariantNode &&\\n        !isControllingVariants &&\\n        props.inherit !== false) {\\n        initial !== null && initial !== void 0 ? initial : (initial = context.initial);\\n        animate !== null && animate !== void 0 ? animate : (animate = context.animate);\\n    }\\n    var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\\n    if (variantToSet &&\\n        typeof variantToSet !== \\\"boolean\\\" &&\\n        !isAnimationControls(variantToSet)) {\\n        var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\\n        list.forEach(function (definition) {\\n            var resolved = resolveVariantFromProps(props, definition);\\n            if (!resolved)\\n                return;\\n            var transitionEnd = resolved.transitionEnd; resolved.transition; var target = tslib.__rest(resolved, [\\\"transitionEnd\\\", \\\"transition\\\"]);\\n            for (var key in target)\\n                values[key] = target[key];\\n            for (var key in transitionEnd)\\n                values[key] = transitionEnd[key];\\n        });\\n    }\\n    return values;\\n}\\n\\nvar svgMotionConfig = {\\n    useVisualState: makeUseVisualState({\\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\\n        createRenderState: createSvgRenderState,\\n        onMount: function (props, instance, _a) {\\n            var renderState = _a.renderState, latestValues = _a.latestValues;\\n            try {\\n                renderState.dimensions =\\n                    typeof instance.getBBox ===\\n                        \\\"function\\\"\\n                        ? instance.getBBox()\\n                        : instance.getBoundingClientRect();\\n            }\\n            catch (e) {\\n                // Most likely trying to measure an unrendered element under Firefox\\n                renderState.dimensions = {\\n                    x: 0,\\n                    y: 0,\\n                    width: 0,\\n                    height: 0,\\n                };\\n            }\\n            if (isPath(instance)) {\\n                renderState.totalPathLength = instance.getTotalLength();\\n            }\\n            buildSVGAttrs(renderState, latestValues, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\\n            // TODO: Replace with direct assignment\\n            renderSVG(instance, renderState);\\n        },\\n    }),\\n};\\nfunction isPath(element) {\\n    return element.tagName === \\\"path\\\";\\n}\\n\\nvar htmlMotionConfig = {\\n    useVisualState: makeUseVisualState({\\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\\n        createRenderState: createHtmlRenderState,\\n    }),\\n};\\n\\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\\n    var baseConfig = isSVGComponent(Component)\\n        ? svgMotionConfig\\n        : htmlMotionConfig;\\n    return tslib.__assign(tslib.__assign({}, baseConfig), { preloadedFeatures: preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement: createVisualElement,\\n        Component: Component });\\n}\\n\\nvar AnimationType;\\n(function (AnimationType) {\\n    AnimationType[\\\"Animate\\\"] = \\\"animate\\\";\\n    AnimationType[\\\"Hover\\\"] = \\\"whileHover\\\";\\n    AnimationType[\\\"Tap\\\"] = \\\"whileTap\\\";\\n    AnimationType[\\\"Drag\\\"] = \\\"whileDrag\\\";\\n    AnimationType[\\\"Focus\\\"] = \\\"whileFocus\\\";\\n    AnimationType[\\\"Exit\\\"] = \\\"exit\\\";\\n})(AnimationType || (AnimationType = {}));\\n\\nfunction addDomEvent(target, eventName, handler, options) {\\n    target.addEventListener(eventName, handler, options);\\n    return function () { return target.removeEventListener(eventName, handler, options); };\\n}\\n/**\\n * Attaches an event listener directly to the provided DOM element.\\n *\\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\\n * event handlers.\\n *\\n * ```jsx\\n * const ref = useRef(null)\\n *\\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\\n *\\n * return <div ref={ref} />\\n * ```\\n *\\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\\n * @param eventName - Name of the event you want listen for.\\n * @param handler - Function to fire when receiving the event.\\n * @param options - Options to pass to `Event.addEventListener`.\\n *\\n * @public\\n */\\nfunction useDomEvent(ref, eventName, handler, options) {\\n    React.useEffect(function () {\\n        var element = ref.current;\\n        if (handler && element) {\\n            return addDomEvent(element, eventName, handler, options);\\n        }\\n    }, [ref, eventName, handler, options]);\\n}\\n\\n/**\\n *\\n * @param props\\n * @param ref\\n * @internal\\n */\\nfunction useFocusGesture(_a) {\\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\\n    var onFocus = function () {\\n        var _a;\\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\\n    };\\n    var onBlur = function () {\\n        var _a;\\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\\n    };\\n    useDomEvent(visualElement, \\\"focus\\\", whileFocus ? onFocus : undefined);\\n    useDomEvent(visualElement, \\\"blur\\\", whileFocus ? onBlur : undefined);\\n}\\n\\nfunction isMouseEvent(event) {\\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\\n    if (typeof PointerEvent !== \\\"undefined\\\" && event instanceof PointerEvent) {\\n        return !!(event.pointerType === \\\"mouse\\\");\\n    }\\n    return event instanceof MouseEvent;\\n}\\nfunction isTouchEvent(event) {\\n    var hasTouches = !!event.touches;\\n    return hasTouches;\\n}\\n\\n/**\\n * Filters out events not attached to the primary pointer (currently left mouse button)\\n * @param eventHandler\\n */\\nfunction filterPrimaryPointer(eventHandler) {\\n    return function (event) {\\n        var isMouseEvent = event instanceof MouseEvent;\\n        var isPrimaryPointer = !isMouseEvent ||\\n            (isMouseEvent && event.button === 0);\\n        if (isPrimaryPointer) {\\n            eventHandler(event);\\n        }\\n    };\\n}\\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\\nfunction pointFromTouch(e, pointType) {\\n    if (pointType === void 0) { pointType = \\\"page\\\"; }\\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\\n    var point = primaryTouch || defaultPagePoint;\\n    return {\\n        x: point[pointType + \\\"X\\\"],\\n        y: point[pointType + \\\"Y\\\"],\\n    };\\n}\\nfunction pointFromMouse(point, pointType) {\\n    if (pointType === void 0) { pointType = \\\"page\\\"; }\\n    return {\\n        x: point[pointType + \\\"X\\\"],\\n        y: point[pointType + \\\"Y\\\"],\\n    };\\n}\\nfunction extractEventInfo(event, pointType) {\\n    if (pointType === void 0) { pointType = \\\"page\\\"; }\\n    return {\\n        point: isTouchEvent(event)\\n            ? pointFromTouch(event, pointType)\\n            : pointFromMouse(event, pointType),\\n    };\\n}\\nfunction getViewportPointFromEvent(event) {\\n    return extractEventInfo(event, \\\"client\\\");\\n}\\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\\n    var listener = function (event) {\\n        return handler(event, extractEventInfo(event));\\n    };\\n    return shouldFilterPrimaryPointer\\n        ? filterPrimaryPointer(listener)\\n        : listener;\\n};\\n\\n// We check for event support via functions in case they've been mocked by a testing suite.\\nvar supportsPointerEvents = function () {\\n    return isBrowser && window.onpointerdown === null;\\n};\\nvar supportsTouchEvents = function () {\\n    return isBrowser && window.ontouchstart === null;\\n};\\nvar supportsMouseEvents = function () {\\n    return isBrowser && window.onmousedown === null;\\n};\\n\\nvar mouseEventNames = {\\n    pointerdown: \\\"mousedown\\\",\\n    pointermove: \\\"mousemove\\\",\\n    pointerup: \\\"mouseup\\\",\\n    pointercancel: \\\"mousecancel\\\",\\n    pointerover: \\\"mouseover\\\",\\n    pointerout: \\\"mouseout\\\",\\n    pointerenter: \\\"mouseenter\\\",\\n    pointerleave: \\\"mouseleave\\\",\\n};\\nvar touchEventNames = {\\n    pointerdown: \\\"touchstart\\\",\\n    pointermove: \\\"touchmove\\\",\\n    pointerup: \\\"touchend\\\",\\n    pointercancel: \\\"touchcancel\\\",\\n};\\nfunction getPointerEventName(name) {\\n    if (supportsPointerEvents()) {\\n        return name;\\n    }\\n    else if (supportsTouchEvents()) {\\n        return touchEventNames[name];\\n    }\\n    else if (supportsMouseEvents()) {\\n        return mouseEventNames[name];\\n    }\\n    return name;\\n}\\nfunction addPointerEvent(target, eventName, handler, options) {\\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \\\"pointerdown\\\"), options);\\n}\\nfunction usePointerEvent(ref, eventName, handler, options) {\\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \\\"pointerdown\\\"), options);\\n}\\n\\nfunction createLock(name) {\\n    var lock = null;\\n    return function () {\\n        var openLock = function () {\\n            lock = null;\\n        };\\n        if (lock === null) {\\n            lock = name;\\n            return openLock;\\n        }\\n        return false;\\n    };\\n}\\nvar globalHorizontalLock = createLock(\\\"dragHorizontal\\\");\\nvar globalVerticalLock = createLock(\\\"dragVertical\\\");\\nfunction getGlobalLock(drag) {\\n    var lock = false;\\n    if (drag === \\\"y\\\") {\\n        lock = globalVerticalLock();\\n    }\\n    else if (drag === \\\"x\\\") {\\n        lock = globalHorizontalLock();\\n    }\\n    else {\\n        var openHorizontal_1 = globalHorizontalLock();\\n        var openVertical_1 = globalVerticalLock();\\n        if (openHorizontal_1 && openVertical_1) {\\n            lock = function () {\\n                openHorizontal_1();\\n                openVertical_1();\\n            };\\n        }\\n        else {\\n            // Release the locks because we don't use them\\n            if (openHorizontal_1)\\n                openHorizontal_1();\\n            if (openVertical_1)\\n                openVertical_1();\\n        }\\n    }\\n    return lock;\\n}\\nfunction isDragActive() {\\n    // Check the gesture lock - if we get it, it means no drag gesture is active\\n    // and we can safely fire the tap gesture.\\n    var openGestureLock = getGlobalLock(true);\\n    if (!openGestureLock)\\n        return true;\\n    openGestureLock();\\n    return false;\\n}\\n\\nfunction createHoverEvent(visualElement, isActive, callback) {\\n    return function (event, info) {\\n        var _a;\\n        if (!isMouseEvent(event) || isDragActive())\\n            return;\\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\\n    };\\n}\\nfunction useHoverGesture(_a) {\\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\\n    usePointerEvent(visualElement, \\\"pointerenter\\\", onHoverStart || whileHover\\n        ? createHoverEvent(visualElement, true, onHoverStart)\\n        : undefined);\\n    usePointerEvent(visualElement, \\\"pointerleave\\\", onHoverEnd || whileHover\\n        ? createHoverEvent(visualElement, false, onHoverEnd)\\n        : undefined);\\n}\\n\\n/**\\n * Recursively traverse up the tree to check whether the provided child node\\n * is the parent or a descendant of it.\\n *\\n * @param parent - Element to find\\n * @param child - Element to test against parent\\n */\\nvar isNodeOrChild = function (parent, child) {\\n    if (!child) {\\n        return false;\\n    }\\n    else if (parent === child) {\\n        return true;\\n    }\\n    else {\\n        return isNodeOrChild(parent, child.parentElement);\\n    }\\n};\\n\\nfunction useUnmountEffect(callback) {\\n    return React.useEffect(function () { return function () { return callback(); }; }, []);\\n}\\n\\n/**\\n * @param handlers -\\n * @internal\\n */\\nfunction useTapGesture(_a) {\\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\\n    var isPressing = React.useRef(false);\\n    var cancelPointerEndListeners = React.useRef(null);\\n    function removePointerEndListener() {\\n        var _a;\\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\\n        cancelPointerEndListeners.current = null;\\n    }\\n    function checkPointerEnd() {\\n        var _a;\\n        removePointerEndListener();\\n        isPressing.current = false;\\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\\n        return !isDragActive();\\n    }\\n    function onPointerUp(event, info) {\\n        if (!checkPointerEnd())\\n            return;\\n        /**\\n         * We only count this as a tap gesture if the event.target is the same\\n         * as, or a child of, this component's element\\n         */\\n        !isNodeOrChild(visualElement.getInstance(), event.target)\\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info)\\n            : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\\n    }\\n    function onPointerCancel(event, info) {\\n        if (!checkPointerEnd())\\n            return;\\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\\n    }\\n    function onPointerDown(event, info) {\\n        var _a;\\n        removePointerEndListener();\\n        if (isPressing.current)\\n            return;\\n        isPressing.current = true;\\n        cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \\\"pointerup\\\", onPointerUp), addPointerEvent(window, \\\"pointercancel\\\", onPointerCancel));\\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\\n    }\\n    usePointerEvent(visualElement, \\\"pointerdown\\\", hasPressListeners ? onPointerDown : undefined);\\n    useUnmountEffect(removePointerEndListener);\\n}\\n\\nvar makeRenderlessComponent = function (hook) { return function (props) {\\n    hook(props);\\n    return null;\\n}; };\\n\\nvar gestureAnimations = {\\n    tap: makeRenderlessComponent(useTapGesture),\\n    focus: makeRenderlessComponent(useFocusGesture),\\n    hover: makeRenderlessComponent(useHoverGesture),\\n};\\n\\nfunction shallowCompare(next, prev) {\\n    if (!Array.isArray(prev))\\n        return false;\\n    var prevLength = prev.length;\\n    if (prevLength !== next.length)\\n        return false;\\n    for (var i = 0; i < prevLength; i++) {\\n        if (prev[i] !== next[i])\\n            return false;\\n    }\\n    return true;\\n}\\n\\n/**\\n * Converts seconds to milliseconds\\n *\\n * @param seconds - Time in seconds.\\n * @return milliseconds - Converted time in milliseconds.\\n */\\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\\n\\nvar easingLookup = {\\n    linear: popmotion.linear,\\n    easeIn: popmotion.easeIn,\\n    easeInOut: popmotion.easeInOut,\\n    easeOut: popmotion.easeOut,\\n    circIn: popmotion.circIn,\\n    circInOut: popmotion.circInOut,\\n    circOut: popmotion.circOut,\\n    backIn: popmotion.backIn,\\n    backInOut: popmotion.backInOut,\\n    backOut: popmotion.backOut,\\n    anticipate: popmotion.anticipate,\\n    bounceIn: popmotion.bounceIn,\\n    bounceInOut: popmotion.bounceInOut,\\n    bounceOut: popmotion.bounceOut,\\n};\\nvar easingDefinitionToFunction = function (definition) {\\n    if (Array.isArray(definition)) {\\n        // If cubic bezier definition, create bezier curve\\n        heyListen.invariant(definition.length === 4, \\\"Cubic bezier arrays must contain four numerical values.\\\");\\n        var _a = tslib.__read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\\n        return popmotion.cubicBezier(x1, y1, x2, y2);\\n    }\\n    else if (typeof definition === \\\"string\\\") {\\n        // Else lookup from table\\n        heyListen.invariant(easingLookup[definition] !== undefined, \\\"Invalid easing type '\\\" + definition + \\\"'\\\");\\n        return easingLookup[definition];\\n    }\\n    return definition;\\n};\\nvar isEasingArray = function (ease) {\\n    return Array.isArray(ease) && typeof ease[0] !== \\\"number\\\";\\n};\\n\\n/**\\n * Check if a value is animatable. Examples:\\n *\\n * \\u2705: 100, \\\"100px\\\", \\\"#fff\\\"\\n * \\u274c: \\\"block\\\", \\\"url(2.jpg)\\\"\\n * @param value\\n *\\n * @internal\\n */\\nvar isAnimatable = function (key, value) {\\n    // If the list of keys tat might be non-animatable grows, replace with Set\\n    if (key === \\\"zIndex\\\")\\n        return false;\\n    // If it's a number or a keyframes array, we can animate it. We might at some point\\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\\n    // but for now lets leave it like this for performance reasons\\n    if (typeof value === \\\"number\\\" || Array.isArray(value))\\n        return true;\\n    if (typeof value === \\\"string\\\" && // It's animatable if we have a string\\n        styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\\n        !value.startsWith(\\\"url(\\\") // Unless it starts with \\\"url(\\\"\\n    ) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nvar underDampedSpring = function () { return ({\\n    type: \\\"spring\\\",\\n    stiffness: 500,\\n    damping: 25,\\n    restDelta: 0.5,\\n    restSpeed: 10,\\n}); };\\nvar criticallyDampedSpring = function (to) { return ({\\n    type: \\\"spring\\\",\\n    stiffness: 550,\\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\\n    restDelta: 0.01,\\n    restSpeed: 10,\\n}); };\\nvar linearTween = function () { return ({\\n    type: \\\"keyframes\\\",\\n    ease: \\\"linear\\\",\\n    duration: 0.3,\\n}); };\\nvar keyframes = function (values) { return ({\\n    type: \\\"keyframes\\\",\\n    duration: 0.8,\\n    values: values,\\n}); };\\nvar defaultTransitions = {\\n    x: underDampedSpring,\\n    y: underDampedSpring,\\n    z: underDampedSpring,\\n    rotate: underDampedSpring,\\n    rotateX: underDampedSpring,\\n    rotateY: underDampedSpring,\\n    rotateZ: underDampedSpring,\\n    scaleX: criticallyDampedSpring,\\n    scaleY: criticallyDampedSpring,\\n    scale: criticallyDampedSpring,\\n    opacity: linearTween,\\n    backgroundColor: linearTween,\\n    color: linearTween,\\n    default: criticallyDampedSpring,\\n};\\nvar getDefaultTransition = function (valueKey, to) {\\n    var transitionFactory;\\n    if (isKeyframesTarget(to)) {\\n        transitionFactory = keyframes;\\n    }\\n    else {\\n        transitionFactory =\\n            defaultTransitions[valueKey] || defaultTransitions.default;\\n    }\\n    return tslib.__assign({ to: to }, transitionFactory(to));\\n};\\n\\n/**\\n * A map of default value types for common values\\n */\\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), { \\n    // Color props\\n    color: styleValueTypes.color, backgroundColor: styleValueTypes.color, outlineColor: styleValueTypes.color, fill: styleValueTypes.color, stroke: styleValueTypes.color, \\n    // Border props\\n    borderColor: styleValueTypes.color, borderTopColor: styleValueTypes.color, borderRightColor: styleValueTypes.color, borderBottomColor: styleValueTypes.color, borderLeftColor: styleValueTypes.color, filter: styleValueTypes.filter, WebkitFilter: styleValueTypes.filter });\\n/**\\n * Gets the default ValueType for the provided value key\\n */\\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\\n\\nfunction getAnimatableNone(key, value) {\\n    var _a;\\n    var defaultValueType = getDefaultValueType(key);\\n    if (defaultValueType !== styleValueTypes.filter)\\n        defaultValueType = styleValueTypes.complex;\\n    // If value is not recognised as animatable, ie \\\"none\\\", create an animatable version origin based on the target\\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\\n}\\n\\n/**\\n * Decide whether a transition is defined on a given Transition.\\n * This filters out orchestration options and returns true\\n * if any options are left.\\n */\\nfunction isTransitionDefined(_a) {\\n    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = tslib.__rest(_a, [\\\"when\\\", \\\"delay\\\", \\\"delayChildren\\\", \\\"staggerChildren\\\", \\\"staggerDirection\\\", \\\"repeat\\\", \\\"repeatType\\\", \\\"repeatDelay\\\", \\\"from\\\"]);\\n    return !!Object.keys(transition).length;\\n}\\nvar legacyRepeatWarning = false;\\n/**\\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\\n */\\nfunction convertTransitionToAnimationOptions(_a) {\\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = tslib.__rest(_a, [\\\"ease\\\", \\\"times\\\", \\\"yoyo\\\", \\\"flip\\\", \\\"loop\\\"]);\\n    var options = tslib.__assign({}, transition);\\n    if (times)\\n        options[\\\"offset\\\"] = times;\\n    /**\\n     * Convert any existing durations from seconds to milliseconds\\n     */\\n    if (transition.duration)\\n        options[\\\"duration\\\"] = secondsToMilliseconds(transition.duration);\\n    if (transition.repeatDelay)\\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\\n    /**\\n     * Map easing names to Popmotion's easing functions\\n     */\\n    if (ease) {\\n        options[\\\"ease\\\"] = isEasingArray(ease)\\n            ? ease.map(easingDefinitionToFunction)\\n            : easingDefinitionToFunction(ease);\\n    }\\n    /**\\n     * Support legacy transition API\\n     */\\n    if (transition.type === \\\"tween\\\")\\n        options.type = \\\"keyframes\\\";\\n    /**\\n     * TODO: These options are officially removed from the API.\\n     */\\n    if (yoyo || loop || flip) {\\n        heyListen.warning(!legacyRepeatWarning, \\\"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\\\");\\n        legacyRepeatWarning = true;\\n        if (yoyo) {\\n            options.repeatType = \\\"reverse\\\";\\n        }\\n        else if (loop) {\\n            options.repeatType = \\\"loop\\\";\\n        }\\n        else if (flip) {\\n            options.repeatType = \\\"mirror\\\";\\n        }\\n        options.repeat = loop || yoyo || flip || transition.repeat;\\n    }\\n    /**\\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\\n     * It'd be good to introduce a similar thing here.\\n     */\\n    if (transition.type !== \\\"spring\\\")\\n        options.type = \\\"keyframes\\\";\\n    return options;\\n}\\n/**\\n * Get the delay for a value by checking Transition with decreasing specificity.\\n */\\nfunction getDelayFromTransition(transition, key) {\\n    var _a;\\n    var valueTransition = getValueTransition(transition, key) || {};\\n    return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\\n}\\nfunction hydrateKeyframes(options) {\\n    if (Array.isArray(options.to) && options.to[0] === null) {\\n        options.to = tslib.__spreadArray([], tslib.__read(options.to));\\n        options.to[0] = options.from;\\n    }\\n    return options;\\n}\\nfunction getPopmotionAnimationOptions(transition, options, key) {\\n    var _a;\\n    if (Array.isArray(options.to)) {\\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\\n    }\\n    hydrateKeyframes(options);\\n    /**\\n     * Get a default transition if none is determined to be defined.\\n     */\\n    if (!isTransitionDefined(transition)) {\\n        transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\\n    }\\n    return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\\n}\\n/**\\n *\\n */\\nfunction getAnimation(key, value, target, transition, onComplete) {\\n    var _a;\\n    var valueTransition = getValueTransition(transition, key);\\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\\n    var isTargetAnimatable = isAnimatable(key, target);\\n    if (origin === \\\"none\\\" && isTargetAnimatable && typeof target === \\\"string\\\") {\\n        /**\\n         * If we're trying to animate from \\\"none\\\", try and get an animatable version\\n         * of the target. This could be improved to work both ways.\\n         */\\n        origin = getAnimatableNone(key, target);\\n    }\\n    else if (isZero(origin) && typeof target === \\\"string\\\") {\\n        origin = getZeroUnit(target);\\n    }\\n    else if (!Array.isArray(target) &&\\n        isZero(target) &&\\n        typeof origin === \\\"string\\\") {\\n        target = getZeroUnit(origin);\\n    }\\n    var isOriginAnimatable = isAnimatable(key, origin);\\n    heyListen.warning(isOriginAnimatable === isTargetAnimatable, \\\"You are trying to animate \\\" + key + \\\" from \\\\\\\"\\\" + origin + \\\"\\\\\\\" to \\\\\\\"\\\" + target + \\\"\\\\\\\". \\\" + origin + \\\" is not an animatable value - to enable this animation set \\\" + origin + \\\" to a value animatable to \\\" + target + \\\" via the `style` property.\\\");\\n    function start() {\\n        var options = {\\n            from: origin,\\n            to: target,\\n            velocity: value.getVelocity(),\\n            onComplete: onComplete,\\n            onUpdate: function (v) { return value.set(v); },\\n        };\\n        return valueTransition.type === \\\"inertia\\\" ||\\n            valueTransition.type === \\\"decay\\\"\\n            ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition))\\n            : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {\\n                    var _a;\\n                    options.onUpdate(v);\\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\\n                }, onComplete: function () {\\n                    var _a;\\n                    options.onComplete();\\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\\n                } }));\\n    }\\n    function set() {\\n        var _a;\\n        value.set(target);\\n        onComplete();\\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\\n        return { stop: function () { } };\\n    }\\n    return !isOriginAnimatable ||\\n        !isTargetAnimatable ||\\n        valueTransition.type === false\\n        ? set\\n        : start;\\n}\\nfunction isZero(value) {\\n    return (value === 0 ||\\n        (typeof value === \\\"string\\\" &&\\n            parseFloat(value) === 0 &&\\n            value.indexOf(\\\" \\\") === -1));\\n}\\nfunction getZeroUnit(potentialUnitType) {\\n    return typeof potentialUnitType === \\\"number\\\"\\n        ? 0\\n        : getAnimatableNone(\\\"\\\", potentialUnitType);\\n}\\nfunction getValueTransition(transition, key) {\\n    return transition[key] || transition[\\\"default\\\"] || transition;\\n}\\n/**\\n * Start animation on a MotionValue. This function is an interface between\\n * Framer Motion and Popmotion\\n *\\n * @internal\\n */\\nfunction startAnimation(key, value, target, transition) {\\n    if (transition === void 0) { transition = {}; }\\n    return value.start(function (onComplete) {\\n        var delayTimer;\\n        var controls;\\n        var animation = getAnimation(key, value, target, transition, onComplete);\\n        var delay = getDelayFromTransition(transition, key);\\n        var start = function () { return (controls = animation()); };\\n        if (delay) {\\n            delayTimer = setTimeout(start, secondsToMilliseconds(delay));\\n        }\\n        else {\\n            start();\\n        }\\n        return function () {\\n            clearTimeout(delayTimer);\\n            controls === null || controls === void 0 ? void 0 : controls.stop();\\n        };\\n    });\\n}\\n\\n/**\\n * Check if value is a numerical string, ie a string that is purely a number eg \\\"100\\\" or \\\"-100.1\\\"\\n */\\nvar isNumericalString = function (v) { return /^\\\\-?\\\\d*\\\\.?\\\\d+$/.test(v); };\\n\\nfunction addUniqueItem(arr, item) {\\n    arr.indexOf(item) === -1 && arr.push(item);\\n}\\nfunction removeItem(arr, item) {\\n    var index = arr.indexOf(item);\\n    index > -1 && arr.splice(index, 1);\\n}\\n\\nvar SubscriptionManager = /** @class */ (function () {\\n    function SubscriptionManager() {\\n        this.subscriptions = [];\\n    }\\n    SubscriptionManager.prototype.add = function (handler) {\\n        var _this = this;\\n        addUniqueItem(this.subscriptions, handler);\\n        return function () { return removeItem(_this.subscriptions, handler); };\\n    };\\n    SubscriptionManager.prototype.notify = function (a, b, c) {\\n        var numSubscriptions = this.subscriptions.length;\\n        if (!numSubscriptions)\\n            return;\\n        if (numSubscriptions === 1) {\\n            /**\\n             * If there's only a single handler we can just call it without invoking a loop.\\n             */\\n            this.subscriptions[0](a, b, c);\\n        }\\n        else {\\n            for (var i = 0; i < numSubscriptions; i++) {\\n                /**\\n                 * Check whether the handler exists before firing as it's possible\\n                 * the subscriptions were modified during this loop running.\\n                 */\\n                var handler = this.subscriptions[i];\\n                handler && handler(a, b, c);\\n            }\\n        }\\n    };\\n    SubscriptionManager.prototype.getSize = function () {\\n        return this.subscriptions.length;\\n    };\\n    SubscriptionManager.prototype.clear = function () {\\n        this.subscriptions.length = 0;\\n    };\\n    return SubscriptionManager;\\n}());\\n\\nvar isFloat = function (value) {\\n    return !isNaN(parseFloat(value));\\n};\\n/**\\n * `MotionValue` is used to track the state and velocity of motion values.\\n *\\n * @public\\n */\\nvar MotionValue = /** @class */ (function () {\\n    /**\\n     * @param init - The initiating value\\n     * @param config - Optional configuration options\\n     *\\n     * -  `transformer`: A function to transform incoming values with.\\n     *\\n     * @internal\\n     */\\n    function MotionValue(init) {\\n        var _this = this;\\n        /**\\n         * Duration, in milliseconds, since last updating frame.\\n         *\\n         * @internal\\n         */\\n        this.timeDelta = 0;\\n        /**\\n         * Timestamp of the last time this `MotionValue` was updated.\\n         *\\n         * @internal\\n         */\\n        this.lastUpdated = 0;\\n        /**\\n         * Functions to notify when the `MotionValue` updates.\\n         *\\n         * @internal\\n         */\\n        this.updateSubscribers = new SubscriptionManager();\\n        /**\\n         * Functions to notify when the velocity updates.\\n         *\\n         * @internal\\n         */\\n        this.velocityUpdateSubscribers = new SubscriptionManager();\\n        /**\\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\\n         *\\n         * @internal\\n         */\\n        this.renderSubscribers = new SubscriptionManager();\\n        /**\\n         * Tracks whether this value can output a velocity. Currently this is only true\\n         * if the value is numerical, but we might be able to widen the scope here and support\\n         * other value types.\\n         *\\n         * @internal\\n         */\\n        this.canTrackVelocity = false;\\n        this.updateAndNotify = function (v, render) {\\n            if (render === void 0) { render = true; }\\n            _this.prev = _this.current;\\n            _this.current = v;\\n            // Update timestamp\\n            var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\\n            if (_this.lastUpdated !== timestamp) {\\n                _this.timeDelta = delta;\\n                _this.lastUpdated = timestamp;\\n                sync__default['default'].postRender(_this.scheduleVelocityCheck);\\n            }\\n            // Update update subscribers\\n            if (_this.prev !== _this.current) {\\n                _this.updateSubscribers.notify(_this.current);\\n            }\\n            // Update velocity subscribers\\n            if (_this.velocityUpdateSubscribers.getSize()) {\\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\\n            }\\n            // Update render subscribers\\n            if (render) {\\n                _this.renderSubscribers.notify(_this.current);\\n            }\\n        };\\n        /**\\n         * Schedule a velocity check for the next frame.\\n         *\\n         * This is an instanced and bound function to prevent generating a new\\n         * function once per frame.\\n         *\\n         * @internal\\n         */\\n        this.scheduleVelocityCheck = function () { return sync__default['default'].postRender(_this.velocityCheck); };\\n        /**\\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\\n         * This ensures velocity calculations return `0`.\\n         *\\n         * This is an instanced and bound function to prevent generating a new\\n         * function once per frame.\\n         *\\n         * @internal\\n         */\\n        this.velocityCheck = function (_a) {\\n            var timestamp = _a.timestamp;\\n            if (timestamp !== _this.lastUpdated) {\\n                _this.prev = _this.current;\\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\\n            }\\n        };\\n        this.hasAnimated = false;\\n        this.prev = this.current = init;\\n        this.canTrackVelocity = isFloat(this.current);\\n    }\\n    /**\\n     * Adds a function that will be notified when the `MotionValue` is updated.\\n     *\\n     * It returns a function that, when called, will cancel the subscription.\\n     *\\n     * When calling `onChange` inside a React component, it should be wrapped with the\\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\\n     *\\n     * @library\\n     *\\n     * ```jsx\\n     * function MyComponent() {\\n     *   const x = useMotionValue(0)\\n     *   const y = useMotionValue(0)\\n     *   const opacity = useMotionValue(1)\\n     *\\n     *   useEffect(() => {\\n     *     function updateOpacity() {\\n     *       const maxXY = Math.max(x.get(), y.get())\\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\\n     *       opacity.set(newOpacity)\\n     *     }\\n     *\\n     *     const unsubscribeX = x.onChange(updateOpacity)\\n     *     const unsubscribeY = y.onChange(updateOpacity)\\n     *\\n     *     return () => {\\n     *       unsubscribeX()\\n     *       unsubscribeY()\\n     *     }\\n     *   }, [])\\n     *\\n     *   return <Frame x={x} />\\n     * }\\n     * ```\\n     *\\n     * @motion\\n     *\\n     * ```jsx\\n     * export const MyComponent = () => {\\n     *   const x = useMotionValue(0)\\n     *   const y = useMotionValue(0)\\n     *   const opacity = useMotionValue(1)\\n     *\\n     *   useEffect(() => {\\n     *     function updateOpacity() {\\n     *       const maxXY = Math.max(x.get(), y.get())\\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\\n     *       opacity.set(newOpacity)\\n     *     }\\n     *\\n     *     const unsubscribeX = x.onChange(updateOpacity)\\n     *     const unsubscribeY = y.onChange(updateOpacity)\\n     *\\n     *     return () => {\\n     *       unsubscribeX()\\n     *       unsubscribeY()\\n     *     }\\n     *   }, [])\\n     *\\n     *   return <motion.div style={{ x }} />\\n     * }\\n     * ```\\n     *\\n     * @internalremarks\\n     *\\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\\n     *\\n     * ```jsx\\n     * useOnChange(x, () => {})\\n     * ```\\n     *\\n     * @param subscriber - A function that receives the latest value.\\n     * @returns A function that, when called, will cancel this subscription.\\n     *\\n     * @public\\n     */\\n    MotionValue.prototype.onChange = function (subscription) {\\n        return this.updateSubscribers.add(subscription);\\n    };\\n    MotionValue.prototype.clearListeners = function () {\\n        this.updateSubscribers.clear();\\n    };\\n    /**\\n     * Adds a function that will be notified when the `MotionValue` requests a render.\\n     *\\n     * @param subscriber - A function that's provided the latest value.\\n     * @returns A function that, when called, will cancel this subscription.\\n     *\\n     * @internal\\n     */\\n    MotionValue.prototype.onRenderRequest = function (subscription) {\\n        // Render immediately\\n        subscription(this.get());\\n        return this.renderSubscribers.add(subscription);\\n    };\\n    /**\\n     * Attaches a passive effect to the `MotionValue`.\\n     *\\n     * @internal\\n     */\\n    MotionValue.prototype.attach = function (passiveEffect) {\\n        this.passiveEffect = passiveEffect;\\n    };\\n    /**\\n     * Sets the state of the `MotionValue`.\\n     *\\n     * @remarks\\n     *\\n     * ```jsx\\n     * const x = useMotionValue(0)\\n     * x.set(10)\\n     * ```\\n     *\\n     * @param latest - Latest value to set.\\n     * @param render - Whether to notify render subscribers. Defaults to `true`\\n     *\\n     * @public\\n     */\\n    MotionValue.prototype.set = function (v, render) {\\n        if (render === void 0) { render = true; }\\n        if (!render || !this.passiveEffect) {\\n            this.updateAndNotify(v, render);\\n        }\\n        else {\\n            this.passiveEffect(v, this.updateAndNotify);\\n        }\\n    };\\n    /**\\n     * Returns the latest state of `MotionValue`\\n     *\\n     * @returns - The latest state of `MotionValue`\\n     *\\n     * @public\\n     */\\n    MotionValue.prototype.get = function () {\\n        return this.current;\\n    };\\n    /**\\n     * @public\\n     */\\n    MotionValue.prototype.getPrevious = function () {\\n        return this.prev;\\n    };\\n    /**\\n     * Returns the latest velocity of `MotionValue`\\n     *\\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\\n     *\\n     * @public\\n     */\\n    MotionValue.prototype.getVelocity = function () {\\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\\n        return this.canTrackVelocity\\n            ? // These casts could be avoided if parseFloat would be typed better\\n                popmotion.velocityPerSecond(parseFloat(this.current) -\\n                    parseFloat(this.prev), this.timeDelta)\\n            : 0;\\n    };\\n    /**\\n     * Registers a new animation to control this `MotionValue`. Only one\\n     * animation can drive a `MotionValue` at one time.\\n     *\\n     * ```jsx\\n     * value.start()\\n     * ```\\n     *\\n     * @param animation - A function that starts the provided animation\\n     *\\n     * @internal\\n     */\\n    MotionValue.prototype.start = function (animation) {\\n        var _this = this;\\n        this.stop();\\n        return new Promise(function (resolve) {\\n            _this.hasAnimated = true;\\n            _this.stopAnimation = animation(resolve);\\n        }).then(function () { return _this.clearAnimation(); });\\n    };\\n    /**\\n     * Stop the currently active animation.\\n     *\\n     * @public\\n     */\\n    MotionValue.prototype.stop = function () {\\n        if (this.stopAnimation)\\n            this.stopAnimation();\\n        this.clearAnimation();\\n    };\\n    /**\\n     * Returns `true` if this value is currently animating.\\n     *\\n     * @public\\n     */\\n    MotionValue.prototype.isAnimating = function () {\\n        return !!this.stopAnimation;\\n    };\\n    MotionValue.prototype.clearAnimation = function () {\\n        this.stopAnimation = null;\\n    };\\n    /**\\n     * Destroy and clean up subscribers to this `MotionValue`.\\n     *\\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\\n     * created a `MotionValue` via the `motionValue` function.\\n     *\\n     * @public\\n     */\\n    MotionValue.prototype.destroy = function () {\\n        this.updateSubscribers.clear();\\n        this.renderSubscribers.clear();\\n        this.stop();\\n    };\\n    return MotionValue;\\n}());\\n/**\\n * @internal\\n */\\nfunction motionValue(init) {\\n    return new MotionValue(init);\\n}\\n\\n/**\\n * Tests a provided value against a ValueType\\n */\\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\\n\\n/**\\n * ValueType for \\\"auto\\\"\\n */\\nvar auto = {\\n    test: function (v) { return v === \\\"auto\\\"; },\\n    parse: function (v) { return v; },\\n};\\n\\n/**\\n * A list of value types commonly used for dimensions\\n */\\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\\n/**\\n * Tests a dimensional value against the list of dimension ValueTypes\\n */\\nvar findDimensionValueType = function (v) {\\n    return dimensionValueTypes.find(testValueType(v));\\n};\\n\\n/**\\n * A list of all ValueTypes\\n */\\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\\n/**\\n * Tests a value against the list of ValueTypes\\n */\\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\\n\\n/**\\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\\n * it doesn't exist.\\n */\\nfunction setMotionValue(visualElement, key, value) {\\n    if (visualElement.hasValue(key)) {\\n        visualElement.getValue(key).set(value);\\n    }\\n    else {\\n        visualElement.addValue(key, motionValue(value));\\n    }\\n}\\nfunction setTarget(visualElement, definition) {\\n    var resolved = resolveVariant(visualElement, definition);\\n    var _a = resolved\\n        ? visualElement.makeTargetAnimatable(resolved, false)\\n        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = tslib.__rest(_a, [\\\"transitionEnd\\\", \\\"transition\\\"]);\\n    target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\\n    for (var key in target) {\\n        var value = resolveFinalValueInKeyframes(target[key]);\\n        setMotionValue(visualElement, key, value);\\n    }\\n}\\nfunction setVariants(visualElement, variantLabels) {\\n    var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\\n    reversedLabels.forEach(function (key) {\\n        var _a;\\n        var variant = visualElement.getVariant(key);\\n        variant && setTarget(visualElement, variant);\\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\\n            setVariants(child, variantLabels);\\n        });\\n    });\\n}\\nfunction setValues(visualElement, definition) {\\n    if (Array.isArray(definition)) {\\n        return setVariants(visualElement, definition);\\n    }\\n    else if (typeof definition === \\\"string\\\") {\\n        return setVariants(visualElement, [definition]);\\n    }\\n    else {\\n        setTarget(visualElement, definition);\\n    }\\n}\\nfunction checkTargetForNewValues(visualElement, target, origin) {\\n    var _a, _b, _c;\\n    var _d;\\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\\n    var numNewValues = newValueKeys.length;\\n    if (!numNewValues)\\n        return;\\n    for (var i = 0; i < numNewValues; i++) {\\n        var key = newValueKeys[i];\\n        var targetValue = target[key];\\n        var value = null;\\n        /**\\n         * If the target is a series of keyframes, we can use the first value\\n         * in the array. If this first value is null, we'll still need to read from the DOM.\\n         */\\n        if (Array.isArray(targetValue)) {\\n            value = targetValue[0];\\n        }\\n        /**\\n         * If the target isn't keyframes, or the first keyframe was null, we need to\\n         * first check if an origin value was explicitly defined in the transition as \\\"from\\\",\\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\\n         */\\n        if (value === null) {\\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\\n        }\\n        /**\\n         * If value is still undefined or null, ignore it. Preferably this would throw,\\n         * but this was causing issues in Framer.\\n         */\\n        if (value === undefined || value === null)\\n            continue;\\n        if (typeof value === \\\"string\\\" && isNumericalString(value)) {\\n            // If this is a number read as a string, ie \\\"0\\\" or \\\"200\\\", convert it to a number\\n            value = parseFloat(value);\\n        }\\n        else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\\n            value = getAnimatableNone(key, targetValue);\\n        }\\n        visualElement.addValue(key, motionValue(value));\\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\\n        visualElement.setBaseTarget(key, value);\\n    }\\n}\\nfunction getOriginFromTransition(key, transition) {\\n    if (!transition)\\n        return;\\n    var valueTransition = transition[key] || transition[\\\"default\\\"] || transition;\\n    return valueTransition.from;\\n}\\nfunction getOrigin(target, transition, visualElement) {\\n    var _a, _b;\\n    var origin = {};\\n    for (var key in target) {\\n        origin[key] =\\n            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\\n    }\\n    return origin;\\n}\\n\\n/**\\n * @internal\\n */\\nfunction animateVisualElement(visualElement, definition, options) {\\n    if (options === void 0) { options = {}; }\\n    visualElement.notifyAnimationStart();\\n    var animation;\\n    if (Array.isArray(definition)) {\\n        var animations = definition.map(function (variant) {\\n            return animateVariant(visualElement, variant, options);\\n        });\\n        animation = Promise.all(animations);\\n    }\\n    else if (typeof definition === \\\"string\\\") {\\n        animation = animateVariant(visualElement, definition, options);\\n    }\\n    else {\\n        var resolvedDefinition = typeof definition === \\\"function\\\"\\n            ? resolveVariant(visualElement, definition, options.custom)\\n            : definition;\\n        animation = animateTarget(visualElement, resolvedDefinition, options);\\n    }\\n    return animation.then(function () {\\n        return visualElement.notifyAnimationComplete(definition);\\n    });\\n}\\nfunction animateVariant(visualElement, variant, options) {\\n    var _a;\\n    if (options === void 0) { options = {}; }\\n    var resolved = resolveVariant(visualElement, variant, options.custom);\\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\\n    if (options.transitionOverride) {\\n        transition = options.transitionOverride;\\n    }\\n    /**\\n     * If we have a variant, create a callback that runs it as an animation.\\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\\n     */\\n    var getAnimation = resolved\\n        ? function () { return animateTarget(visualElement, resolved, options); }\\n        : function () { return Promise.resolve(); };\\n    /**\\n     * If we have children, create a callback that runs all their animations.\\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\\n     */\\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\\n        ? function (forwardDelay) {\\n            if (forwardDelay === void 0) { forwardDelay = 0; }\\n            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\\n        }\\n        : function () { return Promise.resolve(); };\\n    /**\\n     * If the transition explicitly defines a \\\"when\\\" option, we need to resolve either\\n     * this animation or all children animations before playing the other.\\n     */\\n    var when = transition.when;\\n    if (when) {\\n        var _c = tslib.__read(when === \\\"beforeChildren\\\"\\n            ? [getAnimation, getChildAnimations]\\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\\n        return first().then(last);\\n    }\\n    else {\\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\\n    }\\n}\\n/**\\n * @internal\\n */\\nfunction animateTarget(visualElement, definition, _a) {\\n    var _b;\\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = tslib.__rest(_e, [\\\"transition\\\", \\\"transitionEnd\\\"]);\\n    if (transitionOverride)\\n        transition = transitionOverride;\\n    var animations = [];\\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\\n    for (var key in target) {\\n        var value = visualElement.getValue(key);\\n        var valueTarget = target[key];\\n        if (!value ||\\n            valueTarget === undefined ||\\n            (animationTypeState &&\\n                shouldBlockAnimation(animationTypeState, key))) {\\n            continue;\\n        }\\n        var animation = startAnimation(key, value, valueTarget, tslib.__assign({ delay: delay }, transition));\\n        animations.push(animation);\\n    }\\n    return Promise.all(animations).then(function () {\\n        transitionEnd && setTarget(visualElement, transitionEnd);\\n    });\\n}\\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\\n    if (delayChildren === void 0) { delayChildren = 0; }\\n    if (staggerChildren === void 0) { staggerChildren = 0; }\\n    if (staggerDirection === void 0) { staggerDirection = 1; }\\n    var animations = [];\\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\\n    var generateStaggerDuration = staggerDirection === 1\\n        ? function (i) {\\n            if (i === void 0) { i = 0; }\\n            return i * staggerChildren;\\n        }\\n        : function (i) {\\n            if (i === void 0) { i = 0; }\\n            return maxStaggerDuration - i * staggerChildren;\\n        };\\n    Array.from(visualElement.variantChildren)\\n        .sort(sortByTreeOrder)\\n        .forEach(function (child, i) {\\n        animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\\n    });\\n    return Promise.all(animations);\\n}\\nfunction stopAnimation(visualElement) {\\n    visualElement.forEachValue(function (value) { return value.stop(); });\\n}\\nfunction sortByTreeOrder(a, b) {\\n    return a.sortNodePosition(b);\\n}\\n/**\\n * Decide whether we should block this animation. Previously, we achieved this\\n * just by checking whether the key was listed in protectedKeys, but this\\n * posed problems if an animation was triggered by afterChildren and protectedKeys\\n * had been set to true in the meantime.\\n */\\nfunction shouldBlockAnimation(_a, key) {\\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\\n    needsAnimating[key] = false;\\n    return shouldBlock;\\n}\\n\\nvar variantPriorityOrder = [\\n    AnimationType.Animate,\\n    AnimationType.Hover,\\n    AnimationType.Tap,\\n    AnimationType.Drag,\\n    AnimationType.Focus,\\n    AnimationType.Exit,\\n];\\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\\nvar numAnimationTypes = variantPriorityOrder.length;\\nfunction animateList(visualElement) {\\n    return function (animations) {\\n        return Promise.all(animations.map(function (_a) {\\n            var animation = _a.animation, options = _a.options;\\n            return animateVisualElement(visualElement, animation, options);\\n        }));\\n    };\\n}\\nfunction createAnimationState(visualElement) {\\n    var animate = animateList(visualElement);\\n    var state = createState();\\n    var allAnimatedKeys = {};\\n    var isInitialRender = true;\\n    /**\\n     * This function will be used to reduce the animation definitions for\\n     * each active animation type into an object of resolved values for it.\\n     */\\n    var buildResolvedTypeValues = function (acc, definition) {\\n        var resolved = resolveVariant(visualElement, definition);\\n        if (resolved) {\\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = tslib.__rest(resolved, [\\\"transition\\\", \\\"transitionEnd\\\"]);\\n            acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\\n        }\\n        return acc;\\n    };\\n    function isAnimated(key) {\\n        return allAnimatedKeys[key] !== undefined;\\n    }\\n    /**\\n     * This just allows us to inject mocked animation functions\\n     * @internal\\n     */\\n    function setAnimateFunction(makeAnimator) {\\n        animate = makeAnimator(visualElement);\\n    }\\n    /**\\n     * When we receive new props, we need to:\\n     * 1. Create a list of protected keys for each type. This is a directory of\\n     *    value keys that are currently being \\\"handled\\\" by types of a higher priority\\n     *    so that whenever an animation is played of a given type, these values are\\n     *    protected from being animated.\\n     * 2. Determine if an animation type needs animating.\\n     * 3. Determine if any values have been removed from a type and figure out\\n     *    what to animate those to.\\n     */\\n    function animateChanges(options, changedActiveType) {\\n        var _a;\\n        var props = visualElement.getProps();\\n        var context = visualElement.getVariantContext(true) || {};\\n        /**\\n         * A list of animations that we'll build into as we iterate through the animation\\n         * types. This will get executed at the end of the function.\\n         */\\n        var animations = [];\\n        /**\\n         * Keep track of which values have been removed. Then, as we hit lower priority\\n         * animation types, we can check if they contain removed values and animate to that.\\n         */\\n        var removedKeys = new Set();\\n        /**\\n         * A dictionary of all encountered keys. This is an object to let us build into and\\n         * copy it without iteration. Each time we hit an animation type we set its protected\\n         * keys - the keys its not allowed to animate - to the latest version of this object.\\n         */\\n        var encounteredKeys = {};\\n        /**\\n         * If a variant has been removed at a given index, and this component is controlling\\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\\n         */\\n        var removedVariantIndex = Infinity;\\n        var _loop_1 = function (i) {\\n            var type = reversePriorityOrder[i];\\n            var typeState = state[type];\\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\\n            var propIsVariant = isVariantLabel(prop);\\n            /**\\n             * If this type has *just* changed isActive status, set activeDelta\\n             * to that status. Otherwise set to null.\\n             */\\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\\n            if (activeDelta === false)\\n                removedVariantIndex = i;\\n            /**\\n             * If this prop is an inherited variant, rather than been set directly on the\\n             * component itself, we want to make sure we allow the parent to trigger animations.\\n             *\\n             * TODO: Can probably change this to a !isControllingVariants check\\n             */\\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\\n            /**\\n             *\\n             */\\n            if (isInherited &&\\n                isInitialRender &&\\n                visualElement.manuallyAnimateOnMount) {\\n                isInherited = false;\\n            }\\n            /**\\n             * Set all encountered keys so far as the protected keys for this type. This will\\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\\n             */\\n            typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\\n            // Check if we can skip analysing this prop early\\n            if (\\n            // If it isn't active and hasn't *just* been set as inactive\\n            (!typeState.isActive && activeDelta === null) ||\\n                // If we didn't and don't have any defined prop for this animation type\\n                (!prop && !typeState.prevProp) ||\\n                // Or if the prop doesn't define an animation\\n                isAnimationControls(prop) ||\\n                typeof prop === \\\"boolean\\\") {\\n                return \\\"continue\\\";\\n            }\\n            /**\\n             * As we go look through the values defined on this type, if we detect\\n             * a changed value or a value that was removed in a higher priority, we set\\n             * this to true and add this prop to the animation list.\\n             */\\n            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\\n                // If we're making this variant active, we want to always make it active\\n                (type === changedActiveType &&\\n                    typeState.isActive &&\\n                    !isInherited &&\\n                    propIsVariant) ||\\n                // If we removed a higher-priority variant (i is in reverse order)\\n                (i > removedVariantIndex && propIsVariant);\\n            /**\\n             * As animations can be set as variant lists, variants or target objects, we\\n             * coerce everything to an array if it isn't one already\\n             */\\n            var definitionList = Array.isArray(prop) ? prop : [prop];\\n            /**\\n             * Build an object of all the resolved values. We'll use this in the subsequent\\n             * animateChanges calls to determine whether a value has changed.\\n             */\\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\\n            if (activeDelta === false)\\n                resolvedValues = {};\\n            /**\\n             * Now we need to loop through all the keys in the prev prop and this prop,\\n             * and decide:\\n             * 1. If the value has changed, and needs animating\\n             * 2. If it has been removed, and needs adding to the removedKeys set\\n             * 3. If it has been removed in a higher priority type and needs animating\\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\\n             *    needs adding to the type's protectedKeys list.\\n             */\\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\\n            var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\\n            var markToAnimate = function (key) {\\n                shouldAnimateType = true;\\n                removedKeys.delete(key);\\n                typeState.needsAnimating[key] = true;\\n            };\\n            for (var key in allKeys) {\\n                var next = resolvedValues[key];\\n                var prev = prevResolvedValues[key];\\n                // If we've already handled this we can just skip ahead\\n                if (encounteredKeys.hasOwnProperty(key))\\n                    continue;\\n                /**\\n                 * If the value has changed, we probably want to animate it.\\n                 */\\n                if (next !== prev) {\\n                    /**\\n                     * If both values are keyframes, we need to shallow compare them to\\n                     * detect whether any value has changed. If it has, we animate it.\\n                     */\\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\\n                        if (!shallowCompare(next, prev)) {\\n                            markToAnimate(key);\\n                        }\\n                        else {\\n                            /**\\n                             * If it hasn't changed, we want to ensure it doesn't animate by\\n                             * adding it to the list of protected keys.\\n                             */\\n                            typeState.protectedKeys[key] = true;\\n                        }\\n                    }\\n                    else if (next !== undefined) {\\n                        // If next is defined and doesn't equal prev, it needs animating\\n                        markToAnimate(key);\\n                    }\\n                    else {\\n                        // If it's undefined, it's been removed.\\n                        removedKeys.add(key);\\n                    }\\n                }\\n                else if (next !== undefined && removedKeys.has(key)) {\\n                    /**\\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\\n                     * been removed by a higher priority\\n                     */\\n                    markToAnimate(key);\\n                }\\n                else {\\n                    /**\\n                     * If it hasn't changed, we add it to the list of protected values\\n                     * to ensure it doesn't get animated.\\n                     */\\n                    typeState.protectedKeys[key] = true;\\n                }\\n            }\\n            /**\\n             * Update the typeState so next time animateChanges is called we can compare the\\n             * latest prop and resolvedValues to these.\\n             */\\n            typeState.prevProp = prop;\\n            typeState.prevResolvedValues = resolvedValues;\\n            /**\\n             *\\n             */\\n            if (typeState.isActive) {\\n                encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\\n            }\\n            if (isInitialRender && visualElement.blockInitialAnimation) {\\n                shouldAnimateType = false;\\n            }\\n            /**\\n             * If this is an inherited prop we want to hard-block animations\\n             * TODO: Test as this should probably still handle animations triggered\\n             * by removed values?\\n             */\\n            if (shouldAnimateType && !isInherited) {\\n                animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) { return ({\\n                    animation: animation,\\n                    options: tslib.__assign({ type: type }, options),\\n                }); }))));\\n            }\\n        };\\n        /**\\n         * Iterate through all animation types in reverse priority order. For each, we want to\\n         * detect which values it's handling and whether or not they've changed (and therefore\\n         * need to be animated). If any values have been removed, we want to detect those in\\n         * lower priority props and flag for animation.\\n         */\\n        for (var i = 0; i < numAnimationTypes; i++) {\\n            _loop_1(i);\\n        }\\n        allAnimatedKeys = tslib.__assign({}, encounteredKeys);\\n        /**\\n         * If there are some removed value that haven't been dealt with,\\n         * we need to create a new animation that falls back either to the value\\n         * defined in the style prop, or the last read value.\\n         */\\n        if (removedKeys.size) {\\n            var fallbackAnimation_1 = {};\\n            removedKeys.forEach(function (key) {\\n                var fallbackTarget = visualElement.getBaseTarget(key);\\n                if (fallbackTarget !== undefined) {\\n                    fallbackAnimation_1[key] = fallbackTarget;\\n                }\\n            });\\n            animations.push({ animation: fallbackAnimation_1 });\\n        }\\n        var shouldAnimate = Boolean(animations.length);\\n        if (isInitialRender &&\\n            props.initial === false &&\\n            !visualElement.manuallyAnimateOnMount) {\\n            shouldAnimate = false;\\n        }\\n        isInitialRender = false;\\n        return shouldAnimate ? animate(animations) : Promise.resolve();\\n    }\\n    /**\\n     * Change whether a certain animation type is active.\\n     */\\n    function setActive(type, isActive, options) {\\n        var _a;\\n        // If the active state hasn't changed, we can safely do nothing here\\n        if (state[type].isActive === isActive)\\n            return Promise.resolve();\\n        // Propagate active change to children\\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\\n        state[type].isActive = isActive;\\n        return animateChanges(options, type);\\n    }\\n    return {\\n        isAnimated: isAnimated,\\n        animateChanges: animateChanges,\\n        setActive: setActive,\\n        setAnimateFunction: setAnimateFunction,\\n        getState: function () { return state; },\\n    };\\n}\\nfunction variantsHaveChanged(prev, next) {\\n    if (typeof next === \\\"string\\\") {\\n        return next !== prev;\\n    }\\n    else if (isVariantLabels(next)) {\\n        return !shallowCompare(next, prev);\\n    }\\n    return false;\\n}\\nfunction createTypeState(isActive) {\\n    if (isActive === void 0) { isActive = false; }\\n    return {\\n        isActive: isActive,\\n        protectedKeys: {},\\n        needsAnimating: {},\\n        prevResolvedValues: {},\\n    };\\n}\\nfunction createState() {\\n    var _a;\\n    return _a = {},\\n        _a[AnimationType.Animate] = createTypeState(true),\\n        _a[AnimationType.Hover] = createTypeState(),\\n        _a[AnimationType.Tap] = createTypeState(),\\n        _a[AnimationType.Drag] = createTypeState(),\\n        _a[AnimationType.Focus] = createTypeState(),\\n        _a[AnimationType.Exit] = createTypeState(),\\n        _a;\\n}\\n\\nvar animations = {\\n    animation: makeRenderlessComponent(function (_a) {\\n        var visualElement = _a.visualElement, animate = _a.animate;\\n        /**\\n         * We dynamically generate the AnimationState manager as it contains a reference\\n         * to the underlying animation library. We only want to load that if we load this,\\n         * so people can optionally code split it out using the `m` component.\\n         */\\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\\n        /**\\n         * Subscribe any provided AnimationControls to the component's VisualElement\\n         */\\n        if (isAnimationControls(animate)) {\\n            React.useEffect(function () { return animate.subscribe(visualElement); }, [animate]);\\n        }\\n    }),\\n    exit: makeRenderlessComponent(function (props) {\\n        var custom = props.custom, visualElement = props.visualElement;\\n        var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], onExitComplete = _a[1];\\n        var presenceContext = React.useContext(PresenceContext);\\n        React.useEffect(function () {\\n            var _a, _b;\\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\\n        }, [isPresent]);\\n    }),\\n};\\n\\n/**\\n * @internal\\n */\\nvar PanSession = /** @class */ (function () {\\n    function PanSession(event, handlers, _a) {\\n        var _this = this;\\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\\n        /**\\n         * @internal\\n         */\\n        this.startEvent = null;\\n        /**\\n         * @internal\\n         */\\n        this.lastMoveEvent = null;\\n        /**\\n         * @internal\\n         */\\n        this.lastMoveEventInfo = null;\\n        /**\\n         * @internal\\n         */\\n        this.handlers = {};\\n        this.updatePoint = function () {\\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\\n                return;\\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\\n            var isPanStarted = _this.startEvent !== null;\\n            // Only start panning if the offset is larger than 3 pixels. If we make it\\n            // any larger than this we'll want to reset the pointer history\\n            // on the first update to avoid visual snapping to the cursoe.\\n            var isDistancePastThreshold = popmotion.distance(info.offset, { x: 0, y: 0 }) >= 3;\\n            if (!isPanStarted && !isDistancePastThreshold)\\n                return;\\n            var point = info.point;\\n            var timestamp = sync.getFrameData().timestamp;\\n            _this.history.push(tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp }));\\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\\n            if (!isPanStarted) {\\n                onStart && onStart(_this.lastMoveEvent, info);\\n                _this.startEvent = _this.lastMoveEvent;\\n            }\\n            onMove && onMove(_this.lastMoveEvent, info);\\n        };\\n        this.handlePointerMove = function (event, info) {\\n            _this.lastMoveEvent = event;\\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\\n            if (isMouseEvent(event) && event.buttons === 0) {\\n                _this.handlePointerUp(event, info);\\n                return;\\n            }\\n            // Throttle mouse move event to once per frame\\n            sync__default['default'].update(_this.updatePoint, true);\\n        };\\n        this.handlePointerUp = function (event, info) {\\n            _this.end();\\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\\n            if (_this.startEvent && onEnd) {\\n                onEnd(event, panInfo);\\n            }\\n            onSessionEnd && onSessionEnd(event, panInfo);\\n        };\\n        // If we have more than one touch, don't start detecting this gesture\\n        if (isTouchEvent(event) && event.touches.length > 1)\\n            return;\\n        this.handlers = handlers;\\n        this.transformPagePoint = transformPagePoint;\\n        var info = extractEventInfo(event);\\n        var initialInfo = transformPoint(info, this.transformPagePoint);\\n        var point = initialInfo.point;\\n        var timestamp = sync.getFrameData().timestamp;\\n        this.history = [tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp })];\\n        var onSessionStart = handlers.onSessionStart;\\n        onSessionStart &&\\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\\n        this.removeListeners = popmotion.pipe(addPointerEvent(window, \\\"pointermove\\\", this.handlePointerMove), addPointerEvent(window, \\\"pointerup\\\", this.handlePointerUp), addPointerEvent(window, \\\"pointercancel\\\", this.handlePointerUp));\\n    }\\n    PanSession.prototype.updateHandlers = function (handlers) {\\n        this.handlers = handlers;\\n    };\\n    PanSession.prototype.end = function () {\\n        this.removeListeners && this.removeListeners();\\n        sync.cancelSync.update(this.updatePoint);\\n    };\\n    return PanSession;\\n}());\\nfunction transformPoint(info, transformPagePoint) {\\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\\n}\\nfunction subtractPoint(a, b) {\\n    return { x: a.x - b.x, y: a.y - b.y };\\n}\\nfunction getPanInfo(_a, history) {\\n    var point = _a.point;\\n    return {\\n        point: point,\\n        delta: subtractPoint(point, lastDevicePoint(history)),\\n        offset: subtractPoint(point, startDevicePoint(history)),\\n        velocity: getVelocity(history, 0.1),\\n    };\\n}\\nfunction startDevicePoint(history) {\\n    return history[0];\\n}\\nfunction lastDevicePoint(history) {\\n    return history[history.length - 1];\\n}\\nfunction getVelocity(history, timeDelta) {\\n    if (history.length < 2) {\\n        return { x: 0, y: 0 };\\n    }\\n    var i = history.length - 1;\\n    var timestampedPoint = null;\\n    var lastPoint = lastDevicePoint(history);\\n    while (i >= 0) {\\n        timestampedPoint = history[i];\\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\\n            secondsToMilliseconds(timeDelta)) {\\n            break;\\n        }\\n        i--;\\n    }\\n    if (!timestampedPoint) {\\n        return { x: 0, y: 0 };\\n    }\\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\\n    if (time === 0) {\\n        return { x: 0, y: 0 };\\n    }\\n    var currentVelocity = {\\n        x: (lastPoint.x - timestampedPoint.x) / time,\\n        y: (lastPoint.y - timestampedPoint.y) / time,\\n    };\\n    if (currentVelocity.x === Infinity) {\\n        currentVelocity.x = 0;\\n    }\\n    if (currentVelocity.y === Infinity) {\\n        currentVelocity.y = 0;\\n    }\\n    return currentVelocity;\\n}\\n\\nfunction noop(any) {\\n    return any;\\n}\\n\\n/**\\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\\n * it's easier to consider each axis individually. This function returns a bounding box\\n * as a map of single-axis min/max values.\\n */\\nfunction convertBoundingBoxToAxisBox(_a) {\\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\\n    return {\\n        x: { min: left, max: right },\\n        y: { min: top, max: bottom },\\n    };\\n}\\nfunction convertAxisBoxToBoundingBox(_a) {\\n    var x = _a.x, y = _a.y;\\n    return {\\n        top: y.min,\\n        bottom: y.max,\\n        left: x.min,\\n        right: x.max,\\n    };\\n}\\n/**\\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\\n * when measuring DOM elements and DOM event points.\\n */\\nfunction transformBoundingBox(_a, transformPoint) {\\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\\n    if (transformPoint === void 0) { transformPoint = noop; }\\n    var topLeft = transformPoint({ x: left, y: top });\\n    var bottomRight = transformPoint({ x: right, y: bottom });\\n    return {\\n        top: topLeft.y,\\n        left: topLeft.x,\\n        bottom: bottomRight.y,\\n        right: bottomRight.x,\\n    };\\n}\\n/**\\n * Create an empty axis box of zero size\\n */\\nfunction axisBox() {\\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\\n}\\nfunction copyAxisBox(box) {\\n    return {\\n        x: tslib.__assign({}, box.x),\\n        y: tslib.__assign({}, box.y),\\n    };\\n}\\n/**\\n * Create an empty box delta\\n */\\nvar zeroDelta = {\\n    translate: 0,\\n    scale: 1,\\n    origin: 0,\\n    originPoint: 0,\\n};\\nfunction delta() {\\n    return {\\n        x: tslib.__assign({}, zeroDelta),\\n        y: tslib.__assign({}, zeroDelta),\\n    };\\n}\\n\\n// Call a handler once for each axis\\nfunction eachAxis(handler) {\\n    return [handler(\\\"x\\\"), handler(\\\"y\\\")];\\n}\\n\\nvar clampProgress = function (v) { return popmotion.clamp(0, 1, v); };\\n/**\\n * Returns true if the provided value is within maxDistance of the provided target\\n */\\nfunction isNear(value, target, maxDistance) {\\n    if (target === void 0) { target = 0; }\\n    if (maxDistance === void 0) { maxDistance = 0.01; }\\n    return popmotion.distance(value, target) < maxDistance;\\n}\\nfunction calcLength(axis) {\\n    return axis.max - axis.min;\\n}\\n/**\\n * Calculate a transform origin relative to the source axis, between 0-1, that results\\n * in an asthetically pleasing scale/transform needed to project from source to target.\\n */\\nfunction calcOrigin(source, target) {\\n    var origin = 0.5;\\n    var sourceLength = calcLength(source);\\n    var targetLength = calcLength(target);\\n    if (targetLength > sourceLength) {\\n        origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\\n    }\\n    else if (sourceLength > targetLength) {\\n        origin = popmotion.progress(source.min, source.max - targetLength, target.min);\\n    }\\n    return clampProgress(origin);\\n}\\n/**\\n * Update the AxisDelta with a transform that projects source into target.\\n *\\n * The transform `origin` is optional. If not provided, it'll be automatically\\n * calculated based on the relative positions of the two bounding boxes.\\n */\\nfunction updateAxisDelta(delta, source, target, origin) {\\n    if (origin === void 0) { origin = 0.5; }\\n    delta.origin = origin;\\n    delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\\n    delta.scale = calcLength(target) / calcLength(source);\\n    if (isNear(delta.scale, 1, 0.0001))\\n        delta.scale = 1;\\n    delta.translate =\\n        popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\\n    if (isNear(delta.translate))\\n        delta.translate = 0;\\n}\\n/**\\n * Update the BoxDelta with a transform that projects the source into the target.\\n *\\n * The transform `origin` is optional. If not provided, it'll be automatically\\n * calculated based on the relative positions of the two bounding boxes.\\n */\\nfunction updateBoxDelta(delta, source, target, origin) {\\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\\n}\\n/**\\n * Currently this only accepts numerical origins, measured as 0-1, but could\\n * accept pixel values by comparing to the target axis.\\n */\\nfunction defaultOrigin(origin) {\\n    return typeof origin === \\\"number\\\" ? origin : 0.5;\\n}\\nfunction calcRelativeAxis(target, relative, parent) {\\n    target.min = parent.min + relative.min;\\n    target.max = target.min + calcLength(relative);\\n}\\nfunction calcRelativeBox(projection, parentProjection) {\\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\\n}\\n\\n/**\\n * Apply constraints to a point. These constraints are both physical along an\\n * axis, and an elastic factor that determines how much to constrain the point\\n * by if it does lie outside the defined parameters.\\n */\\nfunction applyConstraints(point, _a, elastic) {\\n    var min = _a.min, max = _a.max;\\n    if (min !== undefined && point < min) {\\n        // If we have a min point defined, and this is outside of that, constrain\\n        point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\\n    }\\n    else if (max !== undefined && point > max) {\\n        // If we have a max point defined, and this is outside of that, constrain\\n        point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\\n    }\\n    return point;\\n}\\n/**\\n * Calculates a min projection point based on a pointer, pointer progress\\n * within the drag target, and constraints.\\n *\\n * For instance if an element was 100px width, we were dragging from 0.25\\n * along this axis, the pointer is at 200px, and there were no constraints,\\n * we would calculate a min projection point of 175px.\\n */\\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\\n    // Calculate a min point for this axis and apply it to the current pointer\\n    var min = point - length * progress;\\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\\n}\\n/**\\n * Calculate constraints in terms of the viewport when defined relatively to the\\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\\n */\\nfunction calcRelativeAxisConstraints(axis, min, max) {\\n    return {\\n        min: min !== undefined ? axis.min + min : undefined,\\n        max: max !== undefined\\n            ? axis.max + max - (axis.max - axis.min)\\n            : undefined,\\n    };\\n}\\n/**\\n * Calculate constraints in terms of the viewport when\\n * defined relatively to the measured bounding box.\\n */\\nfunction calcRelativeConstraints(layoutBox, _a) {\\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\\n    return {\\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\\n    };\\n}\\n/**\\n * Calculate viewport constraints when defined as another viewport-relative axis\\n */\\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\\n    var _a;\\n    var min = constraintsAxis.min - layoutAxis.min;\\n    var max = constraintsAxis.max - layoutAxis.max;\\n    // If the constraints axis is actually smaller than the layout axis then we can\\n    // flip the constraints\\n    if (constraintsAxis.max - constraintsAxis.min <\\n        layoutAxis.max - layoutAxis.min) {\\n        _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\\n    }\\n    return {\\n        min: layoutAxis.min + min,\\n        max: layoutAxis.min + max,\\n    };\\n}\\n/**\\n * Calculate viewport constraints when defined as another viewport-relative box\\n */\\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\\n    return {\\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\\n    };\\n}\\n/**\\n * Calculate the an axis position based on two axes and a progress value.\\n */\\nfunction calcPositionFromProgress(axis, constraints, progress) {\\n    var axisLength = axis.max - axis.min;\\n    var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\\n    return { min: min, max: min + axisLength };\\n}\\n/**\\n * Rebase the calculated viewport constraints relative to the layout.min point.\\n */\\nfunction rebaseAxisConstraints(layout, constraints) {\\n    var relativeConstraints = {};\\n    if (constraints.min !== undefined) {\\n        relativeConstraints.min = constraints.min - layout.min;\\n    }\\n    if (constraints.max !== undefined) {\\n        relativeConstraints.max = constraints.max - layout.min;\\n    }\\n    return relativeConstraints;\\n}\\nvar defaultElastic = 0.35;\\n/**\\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\\n */\\nfunction resolveDragElastic(dragElastic) {\\n    if (dragElastic === false) {\\n        dragElastic = 0;\\n    }\\n    else if (dragElastic === true) {\\n        dragElastic = defaultElastic;\\n    }\\n    return {\\n        x: resolveAxisElastic(dragElastic, \\\"left\\\", \\\"right\\\"),\\n        y: resolveAxisElastic(dragElastic, \\\"top\\\", \\\"bottom\\\"),\\n    };\\n}\\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\\n    return {\\n        min: resolvePointElastic(dragElastic, minLabel),\\n        max: resolvePointElastic(dragElastic, maxLabel),\\n    };\\n}\\nfunction resolvePointElastic(dragElastic, label) {\\n    var _a;\\n    return typeof dragElastic === \\\"number\\\"\\n        ? dragElastic\\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\\n}\\n\\n/**\\n * Measure and return the element bounding box.\\n *\\n * We convert the box into an AxisBox2D to make it easier to work with each axis\\n * individually and programmatically.\\n *\\n * This function optionally accepts a transformPagePoint function which allows us to compensate\\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\\n */\\nfunction getBoundingBox(element, transformPagePoint) {\\n    var box = element.getBoundingClientRect();\\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\\n}\\n\\nvar compareByDepth = function (a, b) {\\n    return a.depth - b.depth;\\n};\\n\\nfunction isProjecting(visualElement) {\\n    var isEnabled = visualElement.projection.isEnabled;\\n    return isEnabled || visualElement.shouldResetTransform();\\n}\\nfunction collectProjectingAncestors(visualElement, ancestors) {\\n    if (ancestors === void 0) { ancestors = []; }\\n    var parent = visualElement.parent;\\n    if (parent)\\n        collectProjectingAncestors(parent, ancestors);\\n    if (isProjecting(visualElement))\\n        ancestors.push(visualElement);\\n    return ancestors;\\n}\\nfunction collectProjectingChildren(visualElement) {\\n    var children = [];\\n    var addChild = function (child) {\\n        if (isProjecting(child))\\n            children.push(child);\\n        child.children.forEach(addChild);\\n    };\\n    visualElement.children.forEach(addChild);\\n    return children.sort(compareByDepth);\\n}\\n/**\\n * Update the layoutState by measuring the DOM layout. This\\n * should be called after resetting any layout-affecting transforms.\\n */\\nfunction updateLayoutMeasurement(visualElement) {\\n    if (visualElement.shouldResetTransform())\\n        return;\\n    var layoutState = visualElement.getLayoutState();\\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\\n    layoutState.isHydrated = true;\\n    layoutState.layout = visualElement.measureViewportBox();\\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\\n    sync__default['default'].update(function () { return visualElement.rebaseProjectionTarget(); });\\n}\\n/**\\n * Record the viewport box as it was before an expected mutation/re-render\\n */\\nfunction snapshotViewportBox(visualElement) {\\n    if (visualElement.shouldResetTransform())\\n        return;\\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\\n    /**\\n     * Update targetBox to match the prevViewportBox. This is just to ensure\\n     * that targetBox is affected by scroll in the same way as the measured box\\n     */\\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\\n}\\n\\nfunction tweenAxis(target, prev, next, p) {\\n    target.min = popmotion.mix(prev.min, next.min, p);\\n    target.max = popmotion.mix(prev.max, next.max, p);\\n}\\nfunction calcRelativeOffsetAxis(parent, child) {\\n    return {\\n        min: child.min - parent.min,\\n        max: child.max - parent.min,\\n    };\\n}\\nfunction calcRelativeOffset(parent, child) {\\n    return {\\n        x: calcRelativeOffsetAxis(parent.x, child.x),\\n        y: calcRelativeOffsetAxis(parent.y, child.y),\\n    };\\n}\\nfunction checkIfParentHasChanged(prev, next) {\\n    var prevId = prev.getLayoutId();\\n    var nextId = next.getLayoutId();\\n    return prevId !== nextId || (nextId === undefined && prev !== next);\\n}\\n\\nfunction isDraggable(visualElement) {\\n    var _a = visualElement.getProps(), drag = _a.drag, _dragX = _a._dragX;\\n    return drag && !_dragX;\\n}\\n\\n/**\\n * Reset an axis to the provided origin box.\\n *\\n * This is a mutative operation.\\n */\\nfunction resetAxis(axis, originAxis) {\\n    axis.min = originAxis.min;\\n    axis.max = originAxis.max;\\n}\\n/**\\n * Reset a box to the provided origin box.\\n *\\n * This is a mutative operation.\\n */\\nfunction resetBox(box, originBox) {\\n    resetAxis(box.x, originBox.x);\\n    resetAxis(box.y, originBox.y);\\n}\\n/**\\n * Scales a point based on a factor and an originPoint\\n */\\nfunction scalePoint(point, scale, originPoint) {\\n    var distanceFromOrigin = point - originPoint;\\n    var scaled = scale * distanceFromOrigin;\\n    return originPoint + scaled;\\n}\\n/**\\n * Applies a translate/scale delta to a point\\n */\\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\\n    if (boxScale !== undefined) {\\n        point = scalePoint(point, boxScale, originPoint);\\n    }\\n    return scalePoint(point, scale, originPoint) + translate;\\n}\\n/**\\n * Applies a translate/scale delta to an axis\\n */\\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\\n    if (translate === void 0) { translate = 0; }\\n    if (scale === void 0) { scale = 1; }\\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\\n}\\n/**\\n * Applies a translate/scale delta to a box\\n */\\nfunction applyBoxDelta(box, _a) {\\n    var x = _a.x, y = _a.y;\\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\\n}\\n/**\\n * Apply a transform to an axis from the latest resolved motion values.\\n * This function basically acts as a bridge between a flat motion value map\\n * and applyAxisDelta\\n */\\nfunction applyAxisTransforms(final, axis, transforms, _a) {\\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\\n    // Copy the current axis to the final axis before mutation\\n    final.min = axis.min;\\n    final.max = axis.max;\\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\\n    var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\\n    // Apply the axis delta to the final axis\\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\\n}\\n/**\\n * The names of the motion values we want to apply as translation, scale and origin.\\n */\\nvar xKeys = [\\\"x\\\", \\\"scaleX\\\", \\\"originX\\\"];\\nvar yKeys = [\\\"y\\\", \\\"scaleY\\\", \\\"originY\\\"];\\n/**\\n * Apply a transform to a box from the latest resolved motion values.\\n */\\nfunction applyBoxTransforms(finalBox, box, transforms) {\\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\\n}\\n/**\\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\\n */\\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\\n    point -= translate;\\n    point = scalePoint(point, 1 / scale, originPoint);\\n    if (boxScale !== undefined) {\\n        point = scalePoint(point, 1 / boxScale, originPoint);\\n    }\\n    return point;\\n}\\n/**\\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\\n */\\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\\n    if (translate === void 0) { translate = 0; }\\n    if (scale === void 0) { scale = 1; }\\n    if (origin === void 0) { origin = 0.5; }\\n    var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\\n}\\n/**\\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\\n * and acts as a bridge between motion values and removeAxisDelta\\n */\\nfunction removeAxisTransforms(axis, transforms, _a) {\\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\\n}\\n/**\\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\\n * and acts as a bridge between motion values and removeAxisDelta\\n */\\nfunction removeBoxTransforms(box, transforms) {\\n    removeAxisTransforms(box.x, transforms, xKeys);\\n    removeAxisTransforms(box.y, transforms, yKeys);\\n}\\n/**\\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\\n *\\n * This is the final nested loop within updateLayoutDelta for future refactoring\\n */\\nfunction applyTreeDeltas(box, treeScale, treePath) {\\n    var treeLength = treePath.length;\\n    if (!treeLength)\\n        return;\\n    // Reset the treeScale\\n    treeScale.x = treeScale.y = 1;\\n    var node;\\n    var delta;\\n    for (var i = 0; i < treeLength; i++) {\\n        node = treePath[i];\\n        delta = node.getLayoutState().delta;\\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\\n        treeScale.x *= delta.x.scale;\\n        treeScale.y *= delta.y.scale;\\n        // Apply each ancestor's calculated delta into this component's recorded layout box\\n        applyBoxDelta(box, delta);\\n        // If this is a draggable ancestor, also incorporate the node's transform to the layout box\\n        if (isDraggable(node)) {\\n            applyBoxTransforms(box, box, node.getLatestValues());\\n        }\\n    }\\n}\\n\\n/**\\n * Returns a boolean stating whether or not we converted the projection\\n * to relative projection.\\n */\\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\\n    if (isLayoutDrag === void 0) { isLayoutDrag = true; }\\n    var projectionParent = visualElement.getProjectionParent();\\n    if (!projectionParent)\\n        return false;\\n    var offset;\\n    if (isLayoutDrag) {\\n        offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\\n        removeBoxTransforms(offset, projectionParent.getLatestValues());\\n    }\\n    else {\\n        offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\\n    }\\n    eachAxis(function (axis) {\\n        return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\\n    });\\n    return true;\\n}\\n\\nvar unresolvedJobs = new Set();\\nfunction pushJob(stack, job, pointer) {\\n    if (!stack[pointer])\\n        stack[pointer] = [];\\n    stack[pointer].push(job);\\n}\\nfunction batchLayout(callback) {\\n    unresolvedJobs.add(callback);\\n    return function () { return unresolvedJobs.delete(callback); };\\n}\\nfunction flushLayout() {\\n    if (!unresolvedJobs.size)\\n        return;\\n    var pointer = 0;\\n    var reads = [[]];\\n    var writes = [];\\n    var setRead = function (job) { return pushJob(reads, job, pointer); };\\n    var setWrite = function (job) {\\n        pushJob(writes, job, pointer);\\n        pointer++;\\n    };\\n    /**\\n     * Resolve jobs into their array stacks\\n     */\\n    unresolvedJobs.forEach(function (callback) {\\n        callback(setRead, setWrite);\\n        pointer = 0;\\n    });\\n    unresolvedJobs.clear();\\n    /**\\n     * Execute jobs\\n     */\\n    var numStacks = writes.length;\\n    for (var i = 0; i <= numStacks; i++) {\\n        reads[i] && reads[i].forEach(executeJob);\\n        writes[i] && writes[i].forEach(executeJob);\\n    }\\n}\\nvar executeJob = function (job) { return job(); };\\n\\nvar elementDragControls = new WeakMap();\\n/**\\n *\\n */\\nvar lastPointerEvent;\\nvar VisualElementDragControls = /** @class */ (function () {\\n    function VisualElementDragControls(_a) {\\n        var visualElement = _a.visualElement;\\n        /**\\n         * Track whether we're currently dragging.\\n         *\\n         * @internal\\n         */\\n        this.isDragging = false;\\n        /**\\n         * The current direction of drag, or `null` if both.\\n         *\\n         * @internal\\n         */\\n        this.currentDirection = null;\\n        /**\\n         * The permitted boundaries of travel, in pixels.\\n         *\\n         * @internal\\n         */\\n        this.constraints = false;\\n        /**\\n         * The per-axis resolved elastic values.\\n         *\\n         * @internal\\n         */\\n        this.elastic = axisBox();\\n        /**\\n         * A reference to the host component's latest props.\\n         *\\n         * @internal\\n         */\\n        this.props = {};\\n        /**\\n         * @internal\\n         */\\n        this.hasMutatedConstraints = false;\\n        /**\\n         * Track the initial position of the cursor relative to the dragging element\\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\\n         *\\n         * @internal\\n         */\\n        this.cursorProgress = {\\n            x: 0.5,\\n            y: 0.5,\\n        };\\n        // When updating _dragX, or _dragY instead of the VisualElement,\\n        // persist their values between drag gestures.\\n        this.originPoint = {};\\n        // This is a reference to the global drag gesture lock, ensuring only one component\\n        // can \\\"capture\\\" the drag of one or both axes.\\n        // TODO: Look into moving this into pansession?\\n        this.openGlobalLock = null;\\n        /**\\n         * @internal\\n         */\\n        this.panSession = null;\\n        this.visualElement = visualElement;\\n        this.visualElement.enableLayoutProjection();\\n        elementDragControls.set(visualElement, this);\\n    }\\n    /**\\n     * Instantiate a PanSession for the drag gesture\\n     *\\n     * @public\\n     */\\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\\n        var _this = this;\\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\\n        var onSessionStart = function (event) {\\n            var _a;\\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\\n            // the component.\\n            _this.stopMotion();\\n            /**\\n             * Save the initial point. We'll use this to calculate the pointer's position rather\\n             * than the one we receive when the gesture actually starts. By then, the pointer will\\n             * have already moved, and the perception will be of the pointer \\\"slipping\\\" across the element\\n             */\\n            var initialPoint = getViewportPointFromEvent(event).point;\\n            (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\\n            _this.cancelLayout = batchLayout(function (read, write) {\\n                var ancestors = collectProjectingAncestors(_this.visualElement);\\n                var children = collectProjectingChildren(_this.visualElement);\\n                var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\\n                var hasManuallySetCursorOrigin = false;\\n                /**\\n                 * Apply a simple lock to the projection target. This ensures no animations\\n                 * can run on the projection box while this lock is active.\\n                 */\\n                _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\\n                write(function () {\\n                    tree.forEach(function (element) { return element.resetTransform(); });\\n                });\\n                read(function () {\\n                    updateLayoutMeasurement(_this.visualElement);\\n                    children.forEach(updateLayoutMeasurement);\\n                });\\n                write(function () {\\n                    tree.forEach(function (element) { return element.restoreTransform(); });\\n                    if (snapToCursor) {\\n                        hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\\n                    }\\n                });\\n                read(function () {\\n                    var isRelativeDrag = Boolean(_this.getAxisMotionValue(\\\"x\\\") && !_this.isExternalDrag());\\n                    if (!isRelativeDrag) {\\n                        _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\\n                    }\\n                    _this.visualElement.scheduleUpdateLayoutProjection();\\n                    /**\\n                     * When dragging starts, we want to find where the cursor is relative to the bounding box\\n                     * of the element. Every frame, we calculate a new bounding box using this relative position\\n                     * and let the visualElement renderer figure out how to reproject the element into this bounding\\n                     * box.\\n                     *\\n                     * By doing it this way, rather than applying an x/y transform directly to the element,\\n                     * we can ensure the component always visually sticks to the cursor as we'd expect, even\\n                     * if the DOM element itself changes layout as a result of React updates the user might\\n                     * make based on the drag position.\\n                     */\\n                    var projection = _this.visualElement.projection;\\n                    eachAxis(function (axis) {\\n                        if (!hasManuallySetCursorOrigin) {\\n                            var _a = projection.target[axis], min = _a.min, max = _a.max;\\n                            _this.cursorProgress[axis] = cursorProgress\\n                                ? cursorProgress[axis]\\n                                : popmotion.progress(min, max, initialPoint[axis]);\\n                        }\\n                        /**\\n                         * If we have external drag MotionValues, record their origin point. On pointermove\\n                         * we'll apply the pan gesture offset directly to this value.\\n                         */\\n                        var axisValue = _this.getAxisMotionValue(axis);\\n                        if (axisValue) {\\n                            _this.originPoint[axis] = axisValue.get();\\n                        }\\n                    });\\n                });\\n                write(function () {\\n                    sync.flushSync.update();\\n                    sync.flushSync.preRender();\\n                    sync.flushSync.render();\\n                    sync.flushSync.postRender();\\n                });\\n                read(function () { return _this.resolveDragConstraints(); });\\n            });\\n        };\\n        var onStart = function (event, info) {\\n            var _a, _b, _c;\\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\\n            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;\\n            if (drag && !dragPropagation) {\\n                if (_this.openGlobalLock)\\n                    _this.openGlobalLock();\\n                _this.openGlobalLock = getGlobalLock(drag);\\n                // If we don 't have the lock, don't start dragging\\n                if (!_this.openGlobalLock)\\n                    return;\\n            }\\n            flushLayout();\\n            // Set current drag status\\n            _this.isDragging = true;\\n            _this.currentDirection = null;\\n            // Fire onDragStart event\\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\\n            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\\n        };\\n        var onMove = function (event, info) {\\n            var _a, _b, _c, _d;\\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\\n            // If we didn't successfully receive the gesture lock, early return.\\n            if (!dragPropagation && !_this.openGlobalLock)\\n                return;\\n            var offset = info.offset;\\n            // Attempt to detect drag direction if directionLock is true\\n            if (dragDirectionLock && _this.currentDirection === null) {\\n                _this.currentDirection = getCurrentDirection(offset);\\n                // If we've successfully set a direction, notify listener\\n                if (_this.currentDirection !== null) {\\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\\n                }\\n                return;\\n            }\\n            // Update each point with the latest position\\n            _this.updateAxis(\\\"x\\\", info.point, offset);\\n            _this.updateAxis(\\\"y\\\", info.point, offset);\\n            // Fire onDrag event\\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\\n            // Update the last pointer event\\n            lastPointerEvent = event;\\n        };\\n        var onSessionEnd = function (event, info) {\\n            return _this.stop(event, info);\\n        };\\n        var transformPagePoint = this.props.transformPagePoint;\\n        this.panSession = new PanSession(originEvent, {\\n            onSessionStart: onSessionStart,\\n            onStart: onStart,\\n            onMove: onMove,\\n            onSessionEnd: onSessionEnd,\\n        }, { transformPagePoint: transformPagePoint });\\n    };\\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\\n        var _this = this;\\n        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\\n        var layout = this.visualElement.getLayoutState().layoutCorrected;\\n        if (dragConstraints) {\\n            this.constraints = isRefObject(dragConstraints)\\n                ? this.resolveRefConstraints(layout, dragConstraints)\\n                : calcRelativeConstraints(layout, dragConstraints);\\n        }\\n        else {\\n            this.constraints = false;\\n        }\\n        this.elastic = resolveDragElastic(dragElastic);\\n        /**\\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\\n         * from viewport-relative to component-relative.\\n         */\\n        if (this.constraints && !this.hasMutatedConstraints) {\\n            eachAxis(function (axis) {\\n                if (_this.getAxisMotionValue(axis)) {\\n                    _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\\n                }\\n            });\\n        }\\n    };\\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\\n        var constraintsElement = constraints.current;\\n        heyListen.invariant(constraintsElement !== null, \\\"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\\\");\\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\\n        /**\\n         * If there's an onMeasureDragConstraints listener we call it and\\n         * if different constraints are returned, set constraints to that\\n         */\\n        if (onMeasureDragConstraints) {\\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\\n            this.hasMutatedConstraints = !!userConstraints;\\n            if (userConstraints) {\\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\\n            }\\n        }\\n        return measuredConstraints;\\n    };\\n    VisualElementDragControls.prototype.cancelDrag = function () {\\n        var _a, _b;\\n        this.visualElement.unlockProjectionTarget();\\n        (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\\n        this.isDragging = false;\\n        this.panSession && this.panSession.end();\\n        this.panSession = null;\\n        if (!this.props.dragPropagation && this.openGlobalLock) {\\n            this.openGlobalLock();\\n            this.openGlobalLock = null;\\n        }\\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\\n    };\\n    VisualElementDragControls.prototype.stop = function (event, info) {\\n        var _a, _b, _c;\\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\\n        this.panSession = null;\\n        var isDragging = this.isDragging;\\n        this.cancelDrag();\\n        if (!isDragging)\\n            return;\\n        var velocity = info.velocity;\\n        this.animateDragEnd(velocity);\\n        (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\\n    };\\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\\n        var _this = this;\\n        return eachAxis(function (axis) {\\n            var drag = _this.props.drag;\\n            // If we're not dragging this axis, do an early return.\\n            if (!shouldDrag(axis, drag, _this.currentDirection))\\n                return;\\n            var axisValue = _this.getAxisMotionValue(axis);\\n            if (axisValue) {\\n                var box = _this.visualElement.getLayoutState().layout;\\n                var length_1 = box[axis].max - box[axis].min;\\n                var center = box[axis].min + length_1 / 2;\\n                var offset = point[axis] - center;\\n                _this.originPoint[axis] = point[axis];\\n                axisValue.set(offset);\\n            }\\n            else {\\n                _this.cursorProgress[axis] = 0.5;\\n                return true;\\n            }\\n        }).includes(true);\\n    };\\n    /**\\n     * Update the specified axis with the latest pointer information.\\n     */\\n    VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\\n        var drag = this.props.drag;\\n        // If we're not dragging this axis, do an early return.\\n        if (!shouldDrag(axis, drag, this.currentDirection))\\n            return;\\n        return this.getAxisMotionValue(axis)\\n            ? this.updateAxisMotionValue(axis, offset)\\n            : this.updateVisualElementAxis(axis, point);\\n    };\\n    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\\n        var axisValue = this.getAxisMotionValue(axis);\\n        if (!offset || !axisValue)\\n            return;\\n        var nextValue = this.originPoint[axis] + offset[axis];\\n        var update = this.constraints\\n            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])\\n            : nextValue;\\n        axisValue.set(update);\\n    };\\n    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\\n        var _a;\\n        // Get the actual layout bounding box of the element\\n        var axisLayout = this.visualElement.getLayoutState().layout[axis];\\n        // Calculate its current length. In the future we might want to lerp this to animate\\n        // between lengths if the layout changes as we change the DOM\\n        var axisLength = axisLayout.max - axisLayout.min;\\n        // Get the initial progress that the pointer sat on this axis on gesture start.\\n        var axisProgress = this.cursorProgress[axis];\\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\\n        // Update the axis viewport target with this new min and the length\\n        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\\n    };\\n    VisualElementDragControls.prototype.setProps = function (_a) {\\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = tslib.__rest(_a, [\\\"drag\\\", \\\"dragDirectionLock\\\", \\\"dragPropagation\\\", \\\"dragConstraints\\\", \\\"dragElastic\\\", \\\"dragMomentum\\\"]);\\n        this.props = tslib.__assign({ drag: drag,\\n            dragDirectionLock: dragDirectionLock,\\n            dragPropagation: dragPropagation,\\n            dragConstraints: dragConstraints,\\n            dragElastic: dragElastic,\\n            dragMomentum: dragMomentum }, remainingProps);\\n    };\\n    /**\\n     * Drag works differently depending on which props are provided.\\n     *\\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\\n     * - If the component will perform layout animations, we output the gesture to the component's\\n     *      visual bounding box\\n     * - Otherwise, we apply the delta to the x/y motion values.\\n     */\\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\\n        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\\n        var dragKey = \\\"_drag\\\" + axis.toUpperCase();\\n        if (this.props[dragKey]) {\\n            return this.props[dragKey];\\n        }\\n        else if (!layout && layoutId === undefined) {\\n            return this.visualElement.getValue(axis, 0);\\n        }\\n    };\\n    VisualElementDragControls.prototype.isLayoutDrag = function () {\\n        return !this.getAxisMotionValue(\\\"x\\\");\\n    };\\n    VisualElementDragControls.prototype.isExternalDrag = function () {\\n        var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;\\n        return _dragX || _dragY;\\n    };\\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\\n        var _this = this;\\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\\n        /**\\n         * Everything beyond the drag gesture should be performed with\\n         * relative projection so children stay in sync with their parent element.\\n         */\\n        var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\\n        /**\\n         * If we had previously resolved constraints relative to the viewport,\\n         * we need to also convert those to a relative coordinate space for the animation\\n         */\\n        var constraints = this.constraints || {};\\n        if (isRelative &&\\n            Object.keys(constraints).length &&\\n            this.isLayoutDrag()) {\\n            var projectionParent = this.visualElement.getProjectionParent();\\n            if (projectionParent) {\\n                var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\\n                eachAxis(function (axis) {\\n                    var _a = relativeConstraints_1[axis], min = _a.min, max = _a.max;\\n                    constraints[axis] = {\\n                        min: isNaN(min) ? undefined : min,\\n                        max: isNaN(max) ? undefined : max,\\n                    };\\n                });\\n            }\\n        }\\n        var momentumAnimations = eachAxis(function (axis) {\\n            var _a;\\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\\n                return;\\n            }\\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\\n            /**\\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\\n             * using the value of `dragElastic`.\\n             */\\n            var bounceStiffness = dragElastic ? 200 : 1000000;\\n            var bounceDamping = dragElastic ? 40 : 10000000;\\n            var inertia = tslib.__assign(tslib.__assign({ type: \\\"inertia\\\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\\n            // If we're not animating on an externally-provided `MotionValue` we can use the\\n            // component's animation controls which will handle interactions with whileHover (etc),\\n            // otherwise we just have to animate the `MotionValue` itself.\\n            return _this.getAxisMotionValue(axis)\\n                ? _this.startAxisValueAnimation(axis, inertia)\\n                : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\\n        });\\n        // Run all animations and then resolve the new drag constraints.\\n        return Promise.all(momentumAnimations).then(function () {\\n            var _a, _b;\\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\\n        });\\n    };\\n    VisualElementDragControls.prototype.stopMotion = function () {\\n        var _this = this;\\n        eachAxis(function (axis) {\\n            var axisValue = _this.getAxisMotionValue(axis);\\n            axisValue\\n                ? axisValue.stop()\\n                : _this.visualElement.stopLayoutAnimation();\\n        });\\n    };\\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\\n        var axisValue = this.getAxisMotionValue(axis);\\n        if (!axisValue)\\n            return;\\n        var currentValue = axisValue.get();\\n        axisValue.set(currentValue);\\n        axisValue.set(currentValue); // Set twice to hard-reset velocity\\n        return startAnimation(axis, axisValue, 0, transition);\\n    };\\n    VisualElementDragControls.prototype.scalePoint = function () {\\n        var _this = this;\\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\\n            return;\\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\\n        this.stopMotion();\\n        // Record the relative progress of the targetBox relative to the constraintsBox\\n        var boxProgress = { x: 0, y: 0 };\\n        eachAxis(function (axis) {\\n            boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\\n        });\\n        /**\\n         * For each axis, calculate the current progress of the layout axis within the constraints.\\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\\n         * proportionally within the constraints.\\n         */\\n        this.updateConstraints(function () {\\n            eachAxis(function (axis) {\\n                if (!shouldDrag(axis, drag, null))\\n                    return;\\n                // Calculate the position of the targetBox relative to the constraintsBox using the\\n                // previously calculated progress\\n                var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\\n                _this.visualElement.setProjectionTargetAxis(axis, min, max);\\n            });\\n        });\\n        /**\\n         * If any other draggable components are queuing the same tasks synchronously\\n         * this will wait until they've all been scheduled before flushing.\\n         */\\n        setTimeout(flushLayout, 1);\\n    };\\n    VisualElementDragControls.prototype.updateConstraints = function (onReady) {\\n        var _this = this;\\n        this.cancelLayout = batchLayout(function (read, write) {\\n            var ancestors = collectProjectingAncestors(_this.visualElement);\\n            write(function () {\\n                return ancestors.forEach(function (element) { return element.resetTransform(); });\\n            });\\n            read(function () { return updateLayoutMeasurement(_this.visualElement); });\\n            write(function () {\\n                return ancestors.forEach(function (element) { return element.restoreTransform(); });\\n            });\\n            read(function () {\\n                _this.resolveDragConstraints();\\n            });\\n            if (onReady)\\n                write(onReady);\\n        });\\n    };\\n    VisualElementDragControls.prototype.mount = function (visualElement) {\\n        var _this = this;\\n        var element = visualElement.getInstance();\\n        /**\\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\\n         */\\n        var stopPointerListener = addPointerEvent(element, \\\"pointerdown\\\", function (event) {\\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\\n            drag && dragListener && _this.start(event);\\n        });\\n        /**\\n         * Attach a window resize listener to scale the draggable target within its defined\\n         * constraints as the window resizes.\\n         */\\n        var stopResizeListener = addDomEvent(window, \\\"resize\\\", function () {\\n            _this.scalePoint();\\n        });\\n        /**\\n         * Ensure drag constraints are resolved correctly relative to the dragging element\\n         * whenever its layout changes.\\n         */\\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\\n            if (_this.isDragging) {\\n                _this.resolveDragConstraints();\\n            }\\n        });\\n        /**\\n         * If the previous component with this same layoutId was dragging at the time\\n         * it was unmounted, we want to continue the same gesture on this component.\\n         */\\n        var prevDragCursor = visualElement.prevDragCursor;\\n        if (prevDragCursor) {\\n            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\\n        }\\n        /**\\n         * Return a function that will teardown the drag gesture\\n         */\\n        return function () {\\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\\n            _this.cancelDrag();\\n        };\\n    };\\n    return VisualElementDragControls;\\n}());\\nfunction shouldDrag(direction, drag, currentDirection) {\\n    return ((drag === true || drag === direction) &&\\n        (currentDirection === null || currentDirection === direction));\\n}\\n/**\\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\\n * than the provided threshold, return `null`.\\n *\\n * @param offset - The x/y offset from origin.\\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\\n */\\nfunction getCurrentDirection(offset, lockThreshold) {\\n    if (lockThreshold === void 0) { lockThreshold = 10; }\\n    var direction = null;\\n    if (Math.abs(offset.y) > lockThreshold) {\\n        direction = \\\"y\\\";\\n    }\\n    else if (Math.abs(offset.x) > lockThreshold) {\\n        direction = \\\"x\\\";\\n    }\\n    return direction;\\n}\\n\\n/**\\n * A hook that allows an element to be dragged.\\n *\\n * @internal\\n */\\nfunction useDrag(props) {\\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\\n    var dragControls = useConstant(function () {\\n        return new VisualElementDragControls({\\n            visualElement: visualElement,\\n        });\\n    });\\n    dragControls.setProps(tslib.__assign(tslib.__assign({}, props), { transformPagePoint: transformPagePoint }));\\n    // If we've been provided a DragControls for manual control over the drag gesture,\\n    // subscribe this component to it on mount.\\n    React.useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\\n    // Mount the drag controls with the visualElement\\n    React.useEffect(function () { return dragControls.mount(visualElement); }, []);\\n}\\n\\n/**\\n *\\n * @param handlers -\\n * @param ref -\\n *\\n * @internalremarks\\n * Currently this sets new pan gesture functions every render. The memo route has been explored\\n * in the past but ultimately we're still creating new functions every render. An optimisation\\n * to explore is creating the pan gestures and loading them into a `ref`.\\n *\\n * @internal\\n */\\nfunction usePanGesture(_a) {\\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\\n    var panSession = React.useRef(null);\\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\\n    var handlers = {\\n        onSessionStart: onPanSessionStart,\\n        onStart: onPanStart,\\n        onMove: onPan,\\n        onEnd: function (event, info) {\\n            panSession.current = null;\\n            onPanEnd && onPanEnd(event, info);\\n        },\\n    };\\n    React.useEffect(function () {\\n        if (panSession.current !== null) {\\n            panSession.current.updateHandlers(handlers);\\n        }\\n    });\\n    function onPointerDown(event) {\\n        panSession.current = new PanSession(event, handlers, {\\n            transformPagePoint: transformPagePoint,\\n        });\\n    }\\n    usePointerEvent(visualElement, \\\"pointerdown\\\", hasPanEvents && onPointerDown);\\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\\n}\\n\\nvar drag = {\\n    pan: makeRenderlessComponent(usePanGesture),\\n    drag: makeRenderlessComponent(useDrag),\\n};\\n\\n/**\\n * @public\\n */\\nvar Presence;\\n(function (Presence) {\\n    Presence[Presence[\\\"Entering\\\"] = 0] = \\\"Entering\\\";\\n    Presence[Presence[\\\"Present\\\"] = 1] = \\\"Present\\\";\\n    Presence[Presence[\\\"Exiting\\\"] = 2] = \\\"Exiting\\\";\\n})(Presence || (Presence = {}));\\n/**\\n * @public\\n */\\nexports.VisibilityAction = void 0;\\n(function (VisibilityAction) {\\n    VisibilityAction[VisibilityAction[\\\"Hide\\\"] = 0] = \\\"Hide\\\";\\n    VisibilityAction[VisibilityAction[\\\"Show\\\"] = 1] = \\\"Show\\\";\\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\\n\\nfunction isCSSVariable(value) {\\n    return typeof value === \\\"string\\\" && value.startsWith(\\\"var(--\\\");\\n}\\n/**\\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\\n *\\n * ```\\n * `var(--foo, #fff)` => [`--foo`, '#fff']\\n * ```\\n *\\n * @param current\\n */\\nvar cssVariableRegex = /var\\\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\\\)/;\\nfunction parseCSSVariable(current) {\\n    var match = cssVariableRegex.exec(current);\\n    if (!match)\\n        return [,];\\n    var _a = tslib.__read(match, 3), token = _a[1], fallback = _a[2];\\n    return [token, fallback];\\n}\\nvar maxDepth = 4;\\nfunction getVariableValue(current, element, depth) {\\n    if (depth === void 0) { depth = 1; }\\n    heyListen.invariant(depth <= maxDepth, \\\"Max CSS variable fallback depth detected in property \\\\\\\"\\\" + current + \\\"\\\\\\\". This may indicate a circular fallback dependency.\\\");\\n    var _a = tslib.__read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\\n    // No CSS variable detected\\n    if (!token)\\n        return;\\n    // Attempt to read this CSS variable off the element\\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\\n    if (resolved) {\\n        return resolved.trim();\\n    }\\n    else if (isCSSVariable(fallback)) {\\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\\n        return getVariableValue(fallback, element, depth + 1);\\n    }\\n    else {\\n        return fallback;\\n    }\\n}\\n/**\\n * Resolve CSS variables from\\n *\\n * @internal\\n */\\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\\n    var _b;\\n    var target = tslib.__rest(_a, []);\\n    var element = visualElement.getInstance();\\n    if (!(element instanceof HTMLElement))\\n        return { target: target, transitionEnd: transitionEnd };\\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\\n    if (transitionEnd) {\\n        transitionEnd = tslib.__assign({}, transitionEnd);\\n    }\\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\\n    visualElement.forEachValue(function (value) {\\n        var current = value.get();\\n        if (!isCSSVariable(current))\\n            return;\\n        var resolved = getVariableValue(current, element);\\n        if (resolved)\\n            value.set(resolved);\\n    });\\n    // Cycle through every target property and resolve CSS variables. Currently\\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\\n    for (var key in target) {\\n        var current = target[key];\\n        if (!isCSSVariable(current))\\n            continue;\\n        var resolved = getVariableValue(current, element);\\n        if (!resolved)\\n            continue;\\n        // Clone target if it hasn't already been\\n        target[key] = resolved;\\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\\n        // CSS variable. This will ensure that after the animation the component will reflect\\n        // changes in the value of the CSS variable.\\n        if (transitionEnd)\\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\\n    }\\n    return { target: target, transitionEnd: transitionEnd };\\n}\\n\\nfunction pixelsToPercent(pixels, axis) {\\n    return (pixels / (axis.max - axis.min)) * 100;\\n}\\n/**\\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\\n * borderRadius in both states. If we animate between the two in pixels that will trigger\\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\\n */\\nfunction correctBorderRadius(latest, _layoutState, _a) {\\n    var target = _a.target;\\n    /**\\n     * If latest is a string, if it's a percentage we can return immediately as it's\\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\\n     */\\n    if (typeof latest === \\\"string\\\") {\\n        if (styleValueTypes.px.test(latest)) {\\n            latest = parseFloat(latest);\\n        }\\n        else {\\n            return latest;\\n        }\\n    }\\n    /**\\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\\n     * pixel value as a percentage of each axis\\n     */\\n    var x = pixelsToPercent(latest, target.x);\\n    var y = pixelsToPercent(latest, target.y);\\n    return x + \\\"% \\\" + y + \\\"%\\\";\\n}\\nvar varToken = \\\"_$css\\\";\\nfunction correctBoxShadow(latest, _a) {\\n    var delta = _a.delta, treeScale = _a.treeScale;\\n    var original = latest;\\n    /**\\n     * We need to first strip and store CSS variables from the string.\\n     */\\n    var containsCSSVariables = latest.includes(\\\"var(\\\");\\n    var cssVariables = [];\\n    if (containsCSSVariables) {\\n        latest = latest.replace(cssVariableRegex, function (match) {\\n            cssVariables.push(match);\\n            return varToken;\\n        });\\n    }\\n    var shadow = styleValueTypes.complex.parse(latest);\\n    // TODO: Doesn't support multiple shadows\\n    if (shadow.length > 5)\\n        return original;\\n    var template = styleValueTypes.complex.createTransformer(latest);\\n    var offset = typeof shadow[0] !== \\\"number\\\" ? 1 : 0;\\n    // Calculate the overall context scale\\n    var xScale = delta.x.scale * treeScale.x;\\n    var yScale = delta.y.scale * treeScale.y;\\n    shadow[0 + offset] /= xScale;\\n    shadow[1 + offset] /= yScale;\\n    /**\\n     * Ideally we'd correct x and y scales individually, but because blur and\\n     * spread apply to both we have to take a scale average and apply that instead.\\n     * We could potentially improve the outcome of this by incorporating the ratio between\\n     * the two scales.\\n     */\\n    var averageScale = popmotion.mix(xScale, yScale, 0.5);\\n    // Blur\\n    if (typeof shadow[2 + offset] === \\\"number\\\")\\n        shadow[2 + offset] /= averageScale;\\n    // Spread\\n    if (typeof shadow[3 + offset] === \\\"number\\\")\\n        shadow[3 + offset] /= averageScale;\\n    var output = template(shadow);\\n    if (containsCSSVariables) {\\n        var i_1 = 0;\\n        output = output.replace(varToken, function () {\\n            var cssVariable = cssVariables[i_1];\\n            i_1++;\\n            return cssVariable;\\n        });\\n    }\\n    return output;\\n}\\nvar borderCorrectionDefinition = {\\n    process: correctBorderRadius,\\n};\\nvar defaultScaleCorrectors = {\\n    borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), { applyTo: [\\n            \\\"borderTopLeftRadius\\\",\\n            \\\"borderTopRightRadius\\\",\\n            \\\"borderBottomLeftRadius\\\",\\n            \\\"borderBottomRightRadius\\\",\\n        ] }),\\n    borderTopLeftRadius: borderCorrectionDefinition,\\n    borderTopRightRadius: borderCorrectionDefinition,\\n    borderBottomLeftRadius: borderCorrectionDefinition,\\n    borderBottomRightRadius: borderCorrectionDefinition,\\n    boxShadow: {\\n        process: correctBoxShadow,\\n    },\\n};\\n\\nvar progressTarget = 1000;\\nvar Animate = /** @class */ (function (_super) {\\n    tslib.__extends(Animate, _super);\\n    function Animate() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        /**\\n         * A mutable object that tracks the target viewport box\\n         * for the current animation frame.\\n         */\\n        _this.frameTarget = axisBox();\\n        /**\\n         * The current animation target, we use this to check whether to start\\n         * a new animation or continue the existing one.\\n         */\\n        _this.currentAnimationTarget = axisBox();\\n        /**\\n         * Track whether we're animating this axis.\\n         */\\n        _this.isAnimating = {\\n            x: false,\\n            y: false,\\n        };\\n        _this.stopAxisAnimation = {\\n            x: undefined,\\n            y: undefined,\\n        };\\n        _this.isAnimatingTree = false;\\n        _this.animate = function (target, origin, _a) {\\n            if (_a === void 0) { _a = {}; }\\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = tslib.__rest(_a, [\\\"originBox\\\", \\\"targetBox\\\", \\\"visibilityAction\\\", \\\"shouldStackAnimate\\\", \\\"onComplete\\\", \\\"prevParent\\\"]);\\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\\n            /**\\n             * Early return if we've been instructed not to animate this render.\\n             */\\n            if (shouldStackAnimate === false) {\\n                _this.isAnimatingTree = false;\\n                return _this.safeToRemove();\\n            }\\n            /**\\n             * Prioritise tree animations\\n             */\\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\\n                return;\\n            }\\n            else if (shouldStackAnimate) {\\n                _this.isAnimatingTree = true;\\n            }\\n            /**\\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\\n             * overridden by the provided config.\\n             */\\n            origin = originBox || origin;\\n            target = targetBox || target;\\n            /**\\n             * If this element has a projecting parent, there's an opportunity to animate\\n             * it relatively to that parent rather than relatively to the viewport. This\\n             * allows us to add orchestrated animations.\\n             */\\n            var isRelative = false;\\n            var projectionParent = visualElement.getProjectionParent();\\n            if (projectionParent) {\\n                var prevParentViewportBox = projectionParent.prevViewportBox;\\n                var parentLayout = projectionParent.getLayoutState().layout;\\n                /**\\n                 * If we're being provided a previous parent VisualElement by AnimateSharedLayout\\n                 */\\n                if (prevParent) {\\n                    /**\\n                     * If we've been provided an explicit target box it means we're animating back\\n                     * to this previous parent. So we can make a relative box by comparing to the previous\\n                     * parent's layout\\n                     */\\n                    if (targetBox) {\\n                        parentLayout = prevParent.getLayoutState().layout;\\n                    }\\n                    /**\\n                     * Likewise if we've been provided an explicit origin box it means we're\\n                     * animating out from a different element. So we should figure out where that was\\n                     * on screen relative to the new parent element.\\n                     */\\n                    if (originBox &&\\n                        !checkIfParentHasChanged(prevParent, projectionParent) &&\\n                        prevParent.prevViewportBox) {\\n                        prevParentViewportBox = prevParent.prevViewportBox;\\n                    }\\n                }\\n                if (prevParentViewportBox &&\\n                    isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\\n                    isRelative = true;\\n                    origin = calcRelativeOffset(prevParentViewportBox, origin);\\n                    target = calcRelativeOffset(parentLayout, target);\\n                }\\n            }\\n            var boxHasMoved = hasMoved(origin, target);\\n            var animations = eachAxis(function (axis) {\\n                var _a, _b;\\n                /**\\n                 * If layout is set to \\\"position\\\", we can resize the origin box based on the target\\n                 * box and only animate its position.\\n                 */\\n                if (layout === \\\"position\\\") {\\n                    var targetLength = target[axis].max - target[axis].min;\\n                    origin[axis].max = origin[axis].min + targetLength;\\n                }\\n                if (visualElement.projection.isTargetLocked) {\\n                    return;\\n                }\\n                else if (visibilityAction !== undefined) {\\n                    visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\\n                }\\n                else if (boxHasMoved) {\\n                    // If the box has moved, animate between it's current visual state and its\\n                    // final state\\n                    return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), { isRelative: isRelative }));\\n                }\\n                else {\\n                    (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\\n                    // If the box has remained in the same place, immediately set the axis target\\n                    // to the final desired state\\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\\n                }\\n            });\\n            // Force a render to ensure there's no flash of uncorrected bounding box.\\n            visualElement.syncRender();\\n            /**\\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\\n             * have successfully finished.\\n             */\\n            return Promise.all(animations).then(function () {\\n                _this.isAnimatingTree = false;\\n                onComplete && onComplete();\\n                visualElement.notifyLayoutAnimationComplete();\\n            });\\n        };\\n        return _this;\\n    }\\n    Animate.prototype.componentDidMount = function () {\\n        var _this = this;\\n        var visualElement = this.props.visualElement;\\n        visualElement.animateMotionValue = startAnimation;\\n        visualElement.enableLayoutProjection();\\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\\n        addScaleCorrection(defaultScaleCorrectors);\\n    };\\n    Animate.prototype.componentWillUnmount = function () {\\n        var _this = this;\\n        this.unsubLayoutReady();\\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\\n    };\\n    /**\\n     * TODO: This manually performs animations on the visualElement's layout progress\\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\\n     * API to accept more custom animations like this.\\n     */\\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\\n        var _this = this;\\n        var _b, _c;\\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;\\n        /**\\n         * If we're not animating to a new target, don't run this animation\\n         */\\n        if (this.isAnimating[axis] &&\\n            axisIsEqual(target, this.currentAnimationTarget[axis])) {\\n            return;\\n        }\\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\\n        this.isAnimating[axis] = true;\\n        var visualElement = this.props.visualElement;\\n        var frameTarget = this.frameTarget[axis];\\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\\n        /**\\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\\n         * be re-incoporated into a subsequent spring animation.\\n         */\\n        layoutProgress.clearListeners();\\n        layoutProgress.set(0);\\n        layoutProgress.set(0);\\n        /**\\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\\n         * origin to target using the latest progress value.\\n         */\\n        var frame = function () {\\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\\n            var p = layoutProgress.get() / progressTarget;\\n            // Tween the axis and update the visualElement with the latest values\\n            tweenAxis(frameTarget, origin, target, p);\\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\\n        };\\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\\n        frame();\\n        // Create a function to stop animation on this specific axis\\n        var unsubscribeProgress = layoutProgress.onChange(frame);\\n        this.stopAxisAnimation[axis] = function () {\\n            _this.isAnimating[axis] = false;\\n            layoutProgress.stop();\\n            unsubscribeProgress();\\n        };\\n        this.currentAnimationTarget[axis] = target;\\n        var layoutTransition = transition ||\\n            visualElement.getDefaultTransition() ||\\n            defaultLayoutTransition;\\n        // Start the animation on this axis\\n        var animation = startAnimation(axis === \\\"x\\\" ? \\\"layoutX\\\" : \\\"layoutY\\\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \\\"layout\\\")).then(this.stopAxisAnimation[axis]);\\n        return animation;\\n    };\\n    Animate.prototype.safeToRemove = function () {\\n        var _a, _b;\\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\\n    };\\n    Animate.prototype.render = function () {\\n        return null;\\n    };\\n    return Animate;\\n}(React__namespace.Component));\\nfunction AnimateLayoutContextProvider(props) {\\n    var _a = tslib.__read(usePresence(), 2), safeToRemove = _a[1];\\n    return React__namespace.createElement(Animate, tslib.__assign({}, props, { safeToRemove: safeToRemove }));\\n}\\nfunction hasMoved(a, b) {\\n    return (!isZeroBox(a) &&\\n        !isZeroBox(b) &&\\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\\n}\\nvar zeroAxis = { min: 0, max: 0 };\\nfunction isZeroBox(a) {\\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\\n}\\nfunction axisIsEqual(a, b) {\\n    return a.min === b.min && a.max === b.max;\\n}\\nvar defaultLayoutTransition = {\\n    duration: 0.45,\\n    ease: [0.4, 0, 0.1, 1],\\n};\\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\\n    return prevParent || (!prevParent && !(originBox || targetBox));\\n}\\n\\n/**\\n * Default handlers for batching VisualElements\\n */\\nvar defaultHandler = {\\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\\n};\\n/**\\n * Create a batcher to process VisualElements\\n */\\nfunction createBatcher() {\\n    var queue = new Set();\\n    return {\\n        add: function (child) { return queue.add(child); },\\n        flush: function (_a) {\\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\\n            batchLayout(function (read, write) {\\n                var order = Array.from(queue).sort(compareByDepth);\\n                var ancestors = parent\\n                    ? collectProjectingAncestors(parent)\\n                    : [];\\n                write(function () {\\n                    var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\\n                    allElements.forEach(function (element) { return element.resetTransform(); });\\n                });\\n                read(function () {\\n                    order.forEach(updateLayoutMeasurement);\\n                });\\n                write(function () {\\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\\n                    order.forEach(layoutReady);\\n                });\\n                read(function () {\\n                    /**\\n                     * After all children have started animating, ensure any Entering components are set to Present.\\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\\n                     * are generated in AnimateSharedLayout as this relies on presence data\\n                     */\\n                    order.forEach(function (child) {\\n                        if (child.isPresent)\\n                            child.presence = Presence.Present;\\n                    });\\n                });\\n                write(function () {\\n                    /**\\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\\n                     * we ensure there's no flash.\\n                     */\\n                    sync.flushSync.preRender();\\n                    sync.flushSync.render();\\n                });\\n                read(function () {\\n                    /**\\n                     * Schedule a callback at the end of the following frame to assign the latest projection\\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\\n                     * child attempts to calculate its previous relative position against a prevViewportBox\\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\\n                     * render.\\n                     */\\n                    sync__default['default'].postRender(function () {\\n                        return order.forEach(assignProjectionToSnapshot);\\n                    });\\n                    queue.clear();\\n                });\\n            });\\n            // TODO: Need to find a layout-synchronous way of flushing this\\n            flushLayout();\\n        },\\n    };\\n}\\nfunction assignProjectionToSnapshot(child) {\\n    child.prevViewportBox = child.projection.target;\\n}\\n\\nvar SharedLayoutContext = React.createContext(createBatcher());\\n/**\\n * @internal\\n */\\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\\nfunction isSharedLayout(context) {\\n    return !!context.forceUpdate;\\n}\\n\\n/**\\n * This component is responsible for scheduling the measuring of the motion component\\n */\\nvar Measure = /** @class */ (function (_super) {\\n    tslib.__extends(Measure, _super);\\n    function Measure() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * If this is a child of a SyncContext, register the VisualElement with it on mount.\\n     */\\n    Measure.prototype.componentDidMount = function () {\\n        var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement = _a.visualElement;\\n        isSharedLayout(syncLayout) && syncLayout.register(visualElement);\\n        isSharedLayout(framerSyncLayout) &&\\n            framerSyncLayout.register(visualElement);\\n        visualElement.onUnmount(function () {\\n            if (isSharedLayout(syncLayout)) {\\n                syncLayout.remove(visualElement);\\n            }\\n            if (isSharedLayout(framerSyncLayout)) {\\n                framerSyncLayout.remove(visualElement);\\n            }\\n        });\\n    };\\n    /**\\n     * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\\n     * handle the snapshotting.\\n     *\\n     * If it is stand-alone component, add it to the batcher.\\n     */\\n    Measure.prototype.getSnapshotBeforeUpdate = function () {\\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\\n        if (isSharedLayout(syncLayout)) {\\n            syncLayout.syncUpdate();\\n        }\\n        else {\\n            snapshotViewportBox(visualElement);\\n            syncLayout.add(visualElement);\\n        }\\n        return null;\\n    };\\n    Measure.prototype.componentDidUpdate = function () {\\n        var syncLayout = this.props.syncLayout;\\n        if (!isSharedLayout(syncLayout))\\n            syncLayout.flush();\\n    };\\n    Measure.prototype.render = function () {\\n        return null;\\n    };\\n    return Measure;\\n}(React__default['default'].Component));\\nfunction MeasureContextProvider(props) {\\n    var syncLayout = React.useContext(SharedLayoutContext);\\n    var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\\n    return (React__default['default'].createElement(Measure, tslib.__assign({}, props, { syncLayout: syncLayout, framerSyncLayout: framerSyncLayout })));\\n}\\n\\nvar layoutAnimations = {\\n    measureLayout: MeasureContextProvider,\\n    layoutAnimation: AnimateLayoutContextProvider,\\n};\\n\\nvar createProjectionState = function () { return ({\\n    isEnabled: false,\\n    isHydrated: false,\\n    isTargetLocked: false,\\n    target: axisBox(),\\n    targetFinal: axisBox(),\\n}); };\\nfunction createLayoutState() {\\n    return {\\n        isHydrated: false,\\n        layout: axisBox(),\\n        layoutCorrected: axisBox(),\\n        treeScale: { x: 1, y: 1 },\\n        delta: delta(),\\n        deltaFinal: delta(),\\n        deltaTransform: \\\"\\\",\\n    };\\n}\\nvar zeroLayout = createLayoutState();\\n\\n/**\\n * Build a transform style that takes a calculated delta between the element's current\\n * space on screen and projects it into the desired space.\\n */\\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\\n    var x = _a.x, y = _a.y;\\n    /**\\n     * The translations we use to calculate are always relative to the viewport coordinate space.\\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\\n     */\\n    var xTranslate = x.translate / treeScale.x;\\n    var yTranslate = y.translate / treeScale.y;\\n    var transform = \\\"translate3d(\\\" + xTranslate + \\\"px, \\\" + yTranslate + \\\"px, 0) \\\";\\n    if (latestTransform) {\\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\\n        if (rotate)\\n            transform += \\\"rotate(\\\" + rotate + \\\") \\\";\\n        if (rotateX)\\n            transform += \\\"rotateX(\\\" + rotateX + \\\") \\\";\\n        if (rotateY)\\n            transform += \\\"rotateY(\\\" + rotateY + \\\") \\\";\\n    }\\n    transform += \\\"scale(\\\" + x.scale + \\\", \\\" + y.scale + \\\")\\\";\\n    return !latestTransform && transform === identityProjection ? \\\"\\\" : transform;\\n}\\n/**\\n * Take the calculated delta origin and apply it as a transform string.\\n */\\nfunction buildLayoutProjectionTransformOrigin(_a) {\\n    var deltaFinal = _a.deltaFinal;\\n    return deltaFinal.x.origin * 100 + \\\"% \\\" + deltaFinal.y.origin * 100 + \\\"% 0\\\";\\n}\\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\\n\\nvar names = [\\n    \\\"LayoutMeasure\\\",\\n    \\\"BeforeLayoutMeasure\\\",\\n    \\\"LayoutUpdate\\\",\\n    \\\"ViewportBoxUpdate\\\",\\n    \\\"Update\\\",\\n    \\\"Render\\\",\\n    \\\"AnimationComplete\\\",\\n    \\\"LayoutAnimationComplete\\\",\\n    \\\"AnimationStart\\\",\\n    \\\"SetAxisTarget\\\",\\n    \\\"Unmount\\\",\\n];\\nfunction createLifecycles() {\\n    var managers = names.map(function () { return new SubscriptionManager(); });\\n    var propSubscriptions = {};\\n    var lifecycles = {\\n        clearAllListeners: function () { return managers.forEach(function (manager) { return manager.clear(); }); },\\n        updatePropListeners: function (props) {\\n            return names.forEach(function (name) {\\n                var _a;\\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\\n                var on = \\\"on\\\" + name;\\n                var propListener = props[on];\\n                if (propListener) {\\n                    propSubscriptions[name] = lifecycles[on](propListener);\\n                }\\n            });\\n        },\\n    };\\n    managers.forEach(function (manager, i) {\\n        lifecycles[\\\"on\\\" + names[i]] = function (handler) { return manager.add(handler); };\\n        lifecycles[\\\"notify\\\" + names[i]] = function () {\\n            var args = [];\\n            for (var _i = 0; _i < arguments.length; _i++) {\\n                args[_i] = arguments[_i];\\n            }\\n            return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\\n        };\\n    });\\n    return lifecycles;\\n}\\n\\nfunction updateMotionValuesFromProps(element, next, prev) {\\n    var _a;\\n    for (var key in next) {\\n        var nextValue = next[key];\\n        var prevValue = prev[key];\\n        if (isMotionValue(nextValue)) {\\n            /**\\n             * If this is a motion value found in props or style, we want to add it\\n             * to our visual element's motion value map.\\n             */\\n            element.addValue(key, nextValue);\\n        }\\n        else if (isMotionValue(prevValue)) {\\n            /**\\n             * If we're swapping to a new motion value, create a new motion value\\n             * from that\\n             */\\n            element.addValue(key, motionValue(nextValue));\\n        }\\n        else if (prevValue !== nextValue) {\\n            /**\\n             * If this is a flat value that has changed, update the motion value\\n             * or create one if it doesn't exist. We only want to do this if we're\\n             * not handling the value with our animation state.\\n             */\\n            if (element.hasValue(key)) {\\n                var existingValue = element.getValue(key);\\n                // TODO: Only update values that aren't being animated or even looked at\\n                !existingValue.hasAnimated && existingValue.set(nextValue);\\n            }\\n            else {\\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\\n            }\\n        }\\n    }\\n    // Handle removed values\\n    for (var key in prev) {\\n        if (next[key] === undefined)\\n            element.removeValue(key);\\n    }\\n    return next;\\n}\\n\\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\\n    var delta = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;\\n    var target = _b.target;\\n    /**\\n     * Reset the corrected box with the latest values from box, as we're then going\\n     * to perform mutative operations on it.\\n     */\\n    resetBox(layoutCorrected, layout);\\n    /**\\n     * Apply all the parent deltas to this box to produce the corrected box. This\\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\\n     */\\n    applyTreeDeltas(layoutCorrected, treeScale, treePath);\\n    /**\\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\\n     * to allow people to choose whether these styles are corrected based on just the\\n     * layout reprojection or the final bounding box.\\n     */\\n    updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\\n}\\n\\nvar FlatTree = /** @class */ (function () {\\n    function FlatTree() {\\n        this.children = [];\\n        this.isDirty = false;\\n    }\\n    FlatTree.prototype.add = function (child) {\\n        addUniqueItem(this.children, child);\\n        this.isDirty = true;\\n    };\\n    FlatTree.prototype.remove = function (child) {\\n        removeItem(this.children, child);\\n        this.isDirty = true;\\n    };\\n    FlatTree.prototype.forEach = function (callback) {\\n        this.isDirty && this.children.sort(compareByDepth);\\n        this.isDirty = false;\\n        this.children.forEach(callback);\\n    };\\n    return FlatTree;\\n}());\\n\\nfunction setCurrentViewportBox(visualElement) {\\n    var projectionParent = visualElement.getProjectionParent();\\n    if (!projectionParent) {\\n        visualElement.rebaseProjectionTarget();\\n        return;\\n    }\\n    var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\\n    eachAxis(function (axis) {\\n        visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\\n    });\\n}\\n\\nvar visualElement = function (_a) {\\n    var _b = _a.treeType, treeType = _b === void 0 ? \\\"\\\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\\n    return function (_a, options) {\\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\\n        if (options === void 0) { options = {}; }\\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\\n        /**\\n         * The instance of the render-specific node that will be hydrated by the\\n         * exposed React ref. So for example, this visual element can host a\\n         * HTMLElement, plain object, or Three.js object. The functions provided\\n         * in VisualElementConfig allow us to interface with this instance.\\n         */\\n        var instance;\\n        /**\\n         * Manages the subscriptions for a visual element's lifecycle, for instance\\n         * onRender and onViewportBoxUpdate.\\n         */\\n        var lifecycles = createLifecycles();\\n        /**\\n         *\\n         */\\n        var projection = createProjectionState();\\n        /**\\n         * A reference to the nearest projecting parent. This is either\\n         * undefined if we haven't looked for the nearest projecting parent,\\n         * false if there is no parent performing layout projection, or a reference\\n         * to the projecting parent.\\n         */\\n        var projectionParent;\\n        /**\\n         * This is a reference to the visual state of the \\\"lead\\\" visual element.\\n         * Usually, this will be this visual element. But if it shares a layoutId\\n         * with other visual elements, only one of them will be designated lead by\\n         * AnimateSharedLayout. All the other visual elements will take on the visual\\n         * appearance of the lead while they crossfade to it.\\n         */\\n        var leadProjection = projection;\\n        var leadLatestValues = latestValues;\\n        var unsubscribeFromLeadVisualElement;\\n        /**\\n         * The latest layout measurements and calculated projections. This\\n         * is seperate from the target projection data in visualState as\\n         * many visual elements might point to the same piece of visualState as\\n         * a target, whereas they might each have different layouts and thus\\n         * projection calculations needed to project into the same viewport box.\\n         */\\n        var layoutState = createLayoutState();\\n        /**\\n         *\\n         */\\n        var crossfader;\\n        /**\\n         * Keep track of whether the viewport box has been updated since the\\n         * last time the layout projection was re-calculated.\\n         */\\n        var hasViewportBoxUpdated = false;\\n        /**\\n         * A map of all motion values attached to this visual element. Motion\\n         * values are source of truth for any given animated value. A motion\\n         * value might be provided externally by the component via props.\\n         */\\n        var values = new Map();\\n        /**\\n         * A map of every subscription that binds the provided or generated\\n         * motion values onChange listeners to this visual element.\\n         */\\n        var valueSubscriptions = new Map();\\n        /**\\n         * A reference to the previously-provided motion values as returned\\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\\n         * if any motion values need to be removed after props are updated.\\n         */\\n        var prevMotionValues = {};\\n        /**\\n         * x/y motion values that track the progress of initiated layout\\n         * animations.\\n         *\\n         * TODO: Target for removal\\n         */\\n        var projectionTargetProgress;\\n        /**\\n         * When values are removed from all animation props we need to search\\n         * for a fallback value to animate to. These values are tracked in baseTarget.\\n         */\\n        var baseTarget = tslib.__assign({}, latestValues);\\n        // Internal methods ========================\\n        /**\\n         * On mount, this will be hydrated with a callback to disconnect\\n         * this visual element from its parent on unmount.\\n         */\\n        var removeFromVariantTree;\\n        /**\\n         *\\n         */\\n        function render() {\\n            if (!instance)\\n                return;\\n            if (element.isProjectionReady()) {\\n                /**\\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\\n                 * This is the final box that we will then project into by calculating a transform delta and\\n                 * applying it to the corrected box.\\n                 */\\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\\n                /**\\n                 * Update the delta between the corrected box and the final target box, after\\n                 * user-set transforms are applied to it. This will be used by the renderer to\\n                 * create a transform style that will reproject the element from its actual layout\\n                 * into the desired bounding box.\\n                 */\\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\\n            }\\n            triggerBuild();\\n            renderInstance(instance, renderState);\\n        }\\n        function triggerBuild() {\\n            var valuesToRender = latestValues;\\n            if (crossfader && crossfader.isActive()) {\\n                var crossfadedValues = crossfader.getCrossfadeState(element);\\n                if (crossfadedValues)\\n                    valuesToRender = crossfadedValues;\\n            }\\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\\n        }\\n        function update() {\\n            lifecycles.notifyUpdate(latestValues);\\n        }\\n        function updateLayoutProjection() {\\n            if (!element.isProjectionReady())\\n                return;\\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\\n            var prevTreeScaleX = treeScale.x;\\n            var prevTreeScaleY = treeScale.y;\\n            var prevDeltaTransform = layoutState.deltaTransform;\\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\\n            hasViewportBoxUpdated &&\\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\\n            hasViewportBoxUpdated = false;\\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\\n            if (deltaTransform !== prevDeltaTransform ||\\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\\n                prevTreeScaleX !== treeScale.x ||\\n                prevTreeScaleY !== treeScale.y) {\\n                element.scheduleRender();\\n            }\\n            layoutState.deltaTransform = deltaTransform;\\n        }\\n        function updateTreeLayoutProjection() {\\n            element.layoutTree.forEach(fireUpdateLayoutProjection);\\n        }\\n        /**\\n         *\\n         */\\n        function bindToMotionValue(key, value) {\\n            var removeOnChange = value.onChange(function (latestValue) {\\n                latestValues[key] = latestValue;\\n                props.onUpdate && sync__default['default'].update(update, false, true);\\n            });\\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\\n            valueSubscriptions.set(key, function () {\\n                removeOnChange();\\n                removeOnRenderRequest();\\n            });\\n        }\\n        /**\\n         * Any motion values that are provided to the element when created\\n         * aren't yet bound to the element, as this would technically be impure.\\n         * However, we iterate through the motion values and set them to the\\n         * initial values for this component.\\n         *\\n         * TODO: This is impure and we should look at changing this to run on mount.\\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\\n         * more a reflection of the test.\\n         */\\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\\n        for (var key in initialMotionValues) {\\n            var value = initialMotionValues[key];\\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\\n                value.set(latestValues[key], false);\\n            }\\n        }\\n        /**\\n         * Determine what role this visual element should take in the variant tree.\\n         */\\n        var isControllingVariants = checkIfControllingVariants(props);\\n        var isVariantNode = checkIfVariantNode(props);\\n        var element = tslib.__assign(tslib.__assign({ treeType: treeType, \\n            /**\\n             * This is a mirror of the internal instance prop, which keeps\\n             * VisualElement type-compatible with React's RefObject.\\n             */\\n            current: null, \\n            /**\\n             * The depth of this visual element within the visual element tree.\\n             */\\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \\n            /**\\n             * An ancestor path back to the root visual element. This is used\\n             * by layout projection to quickly recurse back up the tree.\\n             */\\n            path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), \\n            /**\\n             *\\n             */\\n            presenceId: presenceId,\\n            projection: projection, \\n            /**\\n             * If this component is part of the variant tree, it should track\\n             * any children that are also part of the tree. This is essentially\\n             * a shadow tree to simplify logic around how to stagger over children.\\n             */\\n            variantChildren: isVariantNode ? new Set() : undefined, \\n            /**\\n             * Whether this instance is visible. This can be changed imperatively\\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\\n             * hidden elements should take up layout, and needs enacting by the configured\\n             * render function.\\n             */\\n            isVisible: undefined, \\n            /**\\n             * Normally, if a component is controlled by a parent's variants, it can\\n             * rely on that ancestor to trigger animations further down the tree.\\n             * However, if a component is created after its parent is mounted, the parent\\n             * won't trigger that mount animation so the child needs to.\\n             *\\n             * TODO: This might be better replaced with a method isParentMounted\\n             */\\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \\n            /**\\n             * This can be set by AnimatePresence to force components that mount\\n             * at the same time as it to mount as if they have initial={false} set.\\n             */\\n            blockInitialAnimation: blockInitialAnimation, \\n            /**\\n             * Determine whether this component has mounted yet. This is mostly used\\n             * by variant children to determine whether they need to trigger their\\n             * own animations on mount.\\n             */\\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\\n                instance = element.current = newInstance;\\n                element.pointTo(element);\\n                if (isVariantNode && parent && !isControllingVariants) {\\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\\n                }\\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\\n            },\\n            /**\\n             *\\n             */\\n            unmount: function () {\\n                sync.cancelSync.update(update);\\n                sync.cancelSync.render(render);\\n                sync.cancelSync.preRender(element.updateLayoutProjection);\\n                valueSubscriptions.forEach(function (remove) { return remove(); });\\n                element.stopLayoutAnimation();\\n                element.layoutTree.remove(element);\\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\\n                lifecycles.clearAllListeners();\\n            },\\n            /**\\n             * Add a child visual element to our set of children.\\n             */\\n            addVariantChild: function (child) {\\n                var _a;\\n                var closestVariantNode = element.getClosestVariantNode();\\n                if (closestVariantNode) {\\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\\n                }\\n            },\\n            sortNodePosition: function (other) {\\n                /**\\n                 * If these nodes aren't even of the same type we can't compare their depth.\\n                 */\\n                if (!sortNodePosition || treeType !== other.treeType)\\n                    return 0;\\n                return sortNodePosition(element.getInstance(), other.getInstance());\\n            }, \\n            /**\\n             * Returns the closest variant node in the tree starting from\\n             * this visual element.\\n             */\\n            getClosestVariantNode: function () {\\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\\n            }, \\n            /**\\n             * A method that schedules an update to layout projections throughout\\n             * the tree. We inherit from the parent so there's only ever one\\n             * job scheduled on the next frame - that of the root visual element.\\n             */\\n            scheduleUpdateLayoutProjection: parent\\n                ? parent.scheduleUpdateLayoutProjection\\n                : function () {\\n                    return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\\n                }, \\n            /**\\n             * Expose the latest layoutId prop.\\n             */\\n            getLayoutId: function () { return props.layoutId; }, \\n            /**\\n             * Returns the current instance.\\n             */\\n            getInstance: function () { return instance; }, \\n            /**\\n             * Get/set the latest static values.\\n             */\\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \\n            /**\\n             * Returns the latest motion value state. Currently only used to take\\n             * a snapshot of the visual element - perhaps this can return the whole\\n             * visual state\\n             */\\n            getLatestValues: function () { return latestValues; }, \\n            /**\\n             * Set the visiblity of the visual element. If it's changed, schedule\\n             * a render to reflect these changes.\\n             */\\n            setVisibility: function (visibility) {\\n                if (element.isVisible === visibility)\\n                    return;\\n                element.isVisible = visibility;\\n                element.scheduleRender();\\n            },\\n            /**\\n             * Make a target animatable by Popmotion. For instance, if we're\\n             * trying to animate width from 100px to 100vw we need to measure 100vw\\n             * in pixels to determine what we really need to animate to. This is also\\n             * pluggable to support Framer's custom value types like Color,\\n             * and CSS variables.\\n             */\\n            makeTargetAnimatable: function (target, canMutate) {\\n                if (canMutate === void 0) { canMutate = true; }\\n                return makeTargetAnimatable(element, target, props, canMutate);\\n            },\\n            // Motion values ========================\\n            /**\\n             * Add a motion value and bind it to this visual element.\\n             */\\n            addValue: function (key, value) {\\n                // Remove existing value if it exists\\n                if (element.hasValue(key))\\n                    element.removeValue(key);\\n                values.set(key, value);\\n                latestValues[key] = value.get();\\n                bindToMotionValue(key, value);\\n            },\\n            /**\\n             * Remove a motion value and unbind any active subscriptions.\\n             */\\n            removeValue: function (key) {\\n                var _a;\\n                values.delete(key);\\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\\n                valueSubscriptions.delete(key);\\n                delete latestValues[key];\\n                removeValueFromRenderState(key, renderState);\\n            }, \\n            /**\\n             * Check whether we have a motion value for this key\\n             */\\n            hasValue: function (key) { return values.has(key); }, \\n            /**\\n             * Get a motion value for this key. If called with a default\\n             * value, we'll create one if none exists.\\n             */\\n            getValue: function (key, defaultValue) {\\n                var value = values.get(key);\\n                if (value === undefined && defaultValue !== undefined) {\\n                    value = motionValue(defaultValue);\\n                    element.addValue(key, value);\\n                }\\n                return value;\\n            }, \\n            /**\\n             * Iterate over our motion values.\\n             */\\n            forEachValue: function (callback) { return values.forEach(callback); }, \\n            /**\\n             * If we're trying to animate to a previously unencountered value,\\n             * we need to check for it in our state and as a last resort read it\\n             * directly from the instance (which might have performance implications).\\n             */\\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \\n            /**\\n             * Set the base target to later animate back to. This is currently\\n             * only hydrated on creation and when we first read a value.\\n             */\\n            setBaseTarget: function (key, value) {\\n                baseTarget[key] = value;\\n            },\\n            /**\\n             * Find the base target for a value thats been removed from all animation\\n             * props.\\n             */\\n            getBaseTarget: function (key) {\\n                if (getBaseTarget) {\\n                    var target = getBaseTarget(props, key);\\n                    if (target !== undefined && !isMotionValue(target))\\n                        return target;\\n                }\\n                return baseTarget[key];\\n            } }, lifecycles), { \\n            /**\\n             * Build the renderer state based on the latest visual state.\\n             */\\n            build: function () {\\n                triggerBuild();\\n                return renderState;\\n            },\\n            /**\\n             * Schedule a render on the next animation frame.\\n             */\\n            scheduleRender: function () {\\n                sync__default['default'].render(render, false, true);\\n            }, \\n            /**\\n             * Synchronously fire render. It's prefered that we batch renders but\\n             * in many circumstances, like layout measurement, we need to run this\\n             * synchronously. However in those instances other measures should be taken\\n             * to batch reads/writes.\\n             */\\n            syncRender: render, \\n            /**\\n             * Update the provided props. Ensure any newly-added motion values are\\n             * added to our map, old ones removed, and listeners updated.\\n             */\\n            setProps: function (newProps) {\\n                props = newProps;\\n                lifecycles.updatePropListeners(newProps);\\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\\n            }, getProps: function () { return props; }, \\n            // Variants ==============================\\n            /**\\n             * Returns the variant definition with a given name.\\n             */\\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \\n            /**\\n             * Returns the defined default transition on this component.\\n             */\\n            getDefaultTransition: function () { return props.transition; }, \\n            /**\\n             * Used by child variant nodes to get the closest ancestor variant props.\\n             */\\n            getVariantContext: function (startAtParent) {\\n                if (startAtParent === void 0) { startAtParent = false; }\\n                if (startAtParent)\\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\\n                if (!isControllingVariants) {\\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\\n                    if (props.initial !== undefined) {\\n                        context_1.initial = props.initial;\\n                    }\\n                    return context_1;\\n                }\\n                var context = {};\\n                for (var i = 0; i < numVariantProps; i++) {\\n                    var name_1 = variantProps[i];\\n                    var prop = props[name_1];\\n                    if (isVariantLabel(prop) || prop === false) {\\n                        context[name_1] = prop;\\n                    }\\n                }\\n                return context;\\n            },\\n            // Layout projection ==============================\\n            /**\\n             * Enable layout projection for this visual element. Won't actually\\n             * occur until we also have hydrated layout measurements.\\n             */\\n            enableLayoutProjection: function () {\\n                projection.isEnabled = true;\\n                element.layoutTree.add(element);\\n            },\\n            /**\\n             * Lock the projection target, for instance when dragging, so\\n             * nothing else can try and animate it.\\n             */\\n            lockProjectionTarget: function () {\\n                projection.isTargetLocked = true;\\n            },\\n            unlockProjectionTarget: function () {\\n                element.stopLayoutAnimation();\\n                projection.isTargetLocked = false;\\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\\n                crossfader = newCrossfader;\\n            }, isProjectionReady: function () {\\n                return projection.isEnabled &&\\n                    projection.isHydrated &&\\n                    layoutState.isHydrated;\\n            }, \\n            /**\\n             * Start a layout animation on a given axis.\\n             */\\n            startLayoutAnimation: function (axis, transition, isRelative) {\\n                if (isRelative === void 0) { isRelative = false; }\\n                var progress = element.getProjectionAnimationProgress()[axis];\\n                var _a = isRelative\\n                    ? projection.relativeTarget[axis]\\n                    : projection.target[axis], min = _a.min, max = _a.max;\\n                var length = max - min;\\n                progress.clearListeners();\\n                progress.set(min);\\n                progress.set(min); // Set twice to hard-reset velocity\\n                progress.onChange(function (v) {\\n                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);\\n                });\\n                return element.animateMotionValue(axis, progress, 0, transition);\\n            },\\n            /**\\n             * Stop layout animations.\\n             */\\n            stopLayoutAnimation: function () {\\n                eachAxis(function (axis) {\\n                    return element.getProjectionAnimationProgress()[axis].stop();\\n                });\\n            },\\n            /**\\n             * Measure the current viewport box with or without transforms.\\n             * Only measures axis-aligned boxes, rotate and skew must be manually\\n             * removed with a re-render to work.\\n             */\\n            measureViewportBox: function (withTransform) {\\n                if (withTransform === void 0) { withTransform = true; }\\n                var viewportBox = measureViewportBox(instance, options);\\n                if (!withTransform)\\n                    removeBoxTransforms(viewportBox, latestValues);\\n                return viewportBox;\\n            },\\n            /**\\n             * Get the motion values tracking the layout animations on each\\n             * axis. Lazy init if not already created.\\n             */\\n            getProjectionAnimationProgress: function () {\\n                projectionTargetProgress || (projectionTargetProgress = {\\n                    x: motionValue(0),\\n                    y: motionValue(0),\\n                });\\n                return projectionTargetProgress;\\n            },\\n            /**\\n             * Update the projection of a single axis. Schedule an update to\\n             * the tree layout projection.\\n             */\\n            setProjectionTargetAxis: function (axis, min, max, isRelative) {\\n                if (isRelative === void 0) { isRelative = false; }\\n                var target;\\n                if (isRelative) {\\n                    if (!projection.relativeTarget) {\\n                        projection.relativeTarget = axisBox();\\n                    }\\n                    target = projection.relativeTarget[axis];\\n                }\\n                else {\\n                    projection.relativeTarget = undefined;\\n                    target = projection.target[axis];\\n                }\\n                projection.isHydrated = true;\\n                target.min = min;\\n                target.max = max;\\n                // Flag that we want to fire the onViewportBoxUpdate event handler\\n                hasViewportBoxUpdated = true;\\n                lifecycles.notifySetAxisTarget();\\n            },\\n            /**\\n             * Rebase the projection target on top of the provided viewport box\\n             * or the measured layout. This ensures that non-animating elements\\n             * don't fall out of sync differences in measurements vs projections\\n             * after a page scroll or other relayout.\\n             */\\n            rebaseProjectionTarget: function (force, box) {\\n                if (box === void 0) { box = layoutState.layout; }\\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\\n                var shouldRebase = !projection.relativeTarget &&\\n                    !projection.isTargetLocked &&\\n                    !x.isAnimating() &&\\n                    !y.isAnimating();\\n                if (force || shouldRebase) {\\n                    eachAxis(function (axis) {\\n                        var _a = box[axis], min = _a.min, max = _a.max;\\n                        element.setProjectionTargetAxis(axis, min, max);\\n                    });\\n                }\\n            },\\n            /**\\n             * Notify the visual element that its layout is up-to-date.\\n             * Currently Animate.tsx uses this to check whether a layout animation\\n             * needs to be performed.\\n             */\\n            notifyLayoutReady: function (config) {\\n                setCurrentViewportBox(element);\\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\\n            }, \\n            /**\\n             * Temporarily reset the transform of the instance.\\n             */\\n            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,\\n            updateTreeLayoutProjection: function () {\\n                element.layoutTree.forEach(fireResolveRelativeTargetBox);\\n                /**\\n                 * Schedule the projection updates at the end of the current preRender\\n                 * step. This will ensure that all layout trees will first resolve\\n                 * relative projection boxes into viewport boxes, and *then*\\n                 * update projections.\\n                 */\\n                sync__default['default'].preRender(updateTreeLayoutProjection, false, true);\\n                // sync.postRender(() => element.scheduleUpdateLayoutProjection())\\n            },\\n            getProjectionParent: function () {\\n                if (projectionParent === undefined) {\\n                    var foundParent = false;\\n                    // Search backwards through the tree path\\n                    for (var i = element.path.length - 1; i >= 0; i--) {\\n                        var ancestor = element.path[i];\\n                        if (ancestor.projection.isEnabled) {\\n                            foundParent = ancestor;\\n                            break;\\n                        }\\n                    }\\n                    projectionParent = foundParent;\\n                }\\n                return projectionParent;\\n            },\\n            resolveRelativeTargetBox: function () {\\n                var relativeParent = element.getProjectionParent();\\n                if (!projection.relativeTarget || !relativeParent)\\n                    return;\\n                calcRelativeBox(projection, relativeParent.projection);\\n                if (isDraggable(relativeParent)) {\\n                    var target = projection.target;\\n                    applyBoxTransforms(target, target, relativeParent.getLatestValues());\\n                }\\n            },\\n            shouldResetTransform: function () {\\n                return Boolean(props._layoutResetTransform);\\n            },\\n            /**\\n             *\\n             */\\n            pointTo: function (newLead) {\\n                leadProjection = newLead.projection;\\n                leadLatestValues = newLead.getLatestValues();\\n                /**\\n                 * Subscribe to lead component's layout animations\\n                 */\\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\\n                unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\\n                    var _a;\\n                    if (element.isPresent) {\\n                        element.presence = Presence.Present;\\n                    }\\n                    else {\\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\\n                    }\\n                }));\\n            }, \\n            // TODO: Clean this up\\n            isPresent: true, presence: Presence.Entering });\\n        return element;\\n    };\\n};\\nfunction fireResolveRelativeTargetBox(child) {\\n    child.resolveRelativeTargetBox();\\n}\\nfunction fireUpdateLayoutProjection(child) {\\n    child.updateLayoutProjection();\\n}\\nvar variantProps = tslib.__spreadArray([\\\"initial\\\"], tslib.__read(variantPriorityOrder));\\nvar numVariantProps = variantProps.length;\\n\\nvar positionalKeys = new Set([\\n    \\\"width\\\",\\n    \\\"height\\\",\\n    \\\"top\\\",\\n    \\\"left\\\",\\n    \\\"right\\\",\\n    \\\"bottom\\\",\\n    \\\"x\\\",\\n    \\\"y\\\",\\n]);\\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\\nvar hasPositionalKey = function (target) {\\n    return Object.keys(target).some(isPositionalKey);\\n};\\nvar setAndResetVelocity = function (value, to) {\\n    // Looks odd but setting it twice doesn't render, it'll just\\n    // set both prev and current to the latest value\\n    value.set(to, false);\\n    value.set(to);\\n};\\nvar isNumOrPxType = function (v) {\\n    return v === styleValueTypes.number || v === styleValueTypes.px;\\n};\\nvar BoundingBoxDimension;\\n(function (BoundingBoxDimension) {\\n    BoundingBoxDimension[\\\"width\\\"] = \\\"width\\\";\\n    BoundingBoxDimension[\\\"height\\\"] = \\\"height\\\";\\n    BoundingBoxDimension[\\\"left\\\"] = \\\"left\\\";\\n    BoundingBoxDimension[\\\"right\\\"] = \\\"right\\\";\\n    BoundingBoxDimension[\\\"top\\\"] = \\\"top\\\";\\n    BoundingBoxDimension[\\\"bottom\\\"] = \\\"bottom\\\";\\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\\nvar getPosFromMatrix = function (matrix, pos) {\\n    return parseFloat(matrix.split(\\\", \\\")[pos]);\\n};\\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\\n    var transform = _a.transform;\\n    if (transform === \\\"none\\\" || !transform)\\n        return 0;\\n    var matrix3d = transform.match(/^matrix3d\\\\((.+)\\\\)$/);\\n    if (matrix3d) {\\n        return getPosFromMatrix(matrix3d[1], pos3);\\n    }\\n    else {\\n        var matrix = transform.match(/^matrix\\\\((.+)\\\\)$/);\\n        if (matrix) {\\n            return getPosFromMatrix(matrix[1], pos2);\\n        }\\n        else {\\n            return 0;\\n        }\\n    }\\n}; };\\nvar transformKeys = new Set([\\\"x\\\", \\\"y\\\", \\\"z\\\"]);\\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\\nfunction removeNonTranslationalTransform(visualElement) {\\n    var removedTransforms = [];\\n    nonTranslationalTransformKeys.forEach(function (key) {\\n        var value = visualElement.getValue(key);\\n        if (value !== undefined) {\\n            removedTransforms.push([key, value.get()]);\\n            value.set(key.startsWith(\\\"scale\\\") ? 1 : 0);\\n        }\\n    });\\n    // Apply changes to element before measurement\\n    if (removedTransforms.length)\\n        visualElement.syncRender();\\n    return removedTransforms;\\n}\\nvar positionalValues = {\\n    // Dimensions\\n    width: function (_a) {\\n        var x = _a.x;\\n        return x.max - x.min;\\n    },\\n    height: function (_a) {\\n        var y = _a.y;\\n        return y.max - y.min;\\n    },\\n    top: function (_bbox, _a) {\\n        var top = _a.top;\\n        return parseFloat(top);\\n    },\\n    left: function (_bbox, _a) {\\n        var left = _a.left;\\n        return parseFloat(left);\\n    },\\n    bottom: function (_a, _b) {\\n        var y = _a.y;\\n        var top = _b.top;\\n        return parseFloat(top) + (y.max - y.min);\\n    },\\n    right: function (_a, _b) {\\n        var x = _a.x;\\n        var left = _b.left;\\n        return parseFloat(left) + (x.max - x.min);\\n    },\\n    // Transform\\n    x: getTranslateFromMatrix(4, 13),\\n    y: getTranslateFromMatrix(5, 14),\\n};\\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\\n    var originBbox = visualElement.measureViewportBox();\\n    var element = visualElement.getInstance();\\n    var elementComputedStyle = getComputedStyle(element);\\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\\n    // If the element is currently set to display: \\\"none\\\", make it visible before\\n    // measuring the target bounding box\\n    if (display === \\\"none\\\") {\\n        visualElement.setStaticValue(\\\"display\\\", target.display || \\\"block\\\");\\n    }\\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\\n    visualElement.syncRender();\\n    var targetBbox = visualElement.measureViewportBox();\\n    changedKeys.forEach(function (key) {\\n        // Restore styles to their **calculated computed style**, not their actual\\n        // originally set style. This allows us to animate between equivalent pixel units.\\n        var value = visualElement.getValue(key);\\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\\n    });\\n    return target;\\n};\\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\\n    if (origin === void 0) { origin = {}; }\\n    if (transitionEnd === void 0) { transitionEnd = {}; }\\n    target = tslib.__assign({}, target);\\n    transitionEnd = tslib.__assign({}, transitionEnd);\\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\\n    // We want to remove any transform values that could affect the element's bounding box before\\n    // it's measured. We'll reapply these later.\\n    var removedTransformValues = [];\\n    var hasAttemptedToRemoveTransformValues = false;\\n    var changedValueTypeKeys = [];\\n    targetPositionalKeys.forEach(function (key) {\\n        var value = visualElement.getValue(key);\\n        if (!visualElement.hasValue(key))\\n            return;\\n        var from = origin[key];\\n        var to = target[key];\\n        var fromType = findDimensionValueType(from);\\n        var toType;\\n        // TODO: The current implementation of this basically throws an error\\n        // if you try and do value conversion via keyframes. There's probably\\n        // a way of doing this but the performance implications would need greater scrutiny,\\n        // as it'd be doing multiple resize-remeasure operations.\\n        if (isKeyframesTarget(to)) {\\n            var numKeyframes = to.length;\\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\\n                if (!toType) {\\n                    toType = findDimensionValueType(to[i]);\\n                    heyListen.invariant(toType === fromType ||\\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \\\"Keyframes must be of the same dimension as the current value\\\");\\n                }\\n                else {\\n                    heyListen.invariant(findDimensionValueType(to[i]) === toType, \\\"All keyframes must be of the same type\\\");\\n                }\\n            }\\n        }\\n        else {\\n            toType = findDimensionValueType(to);\\n        }\\n        if (fromType !== toType) {\\n            // If they're both just number or px, convert them both to numbers rather than\\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\\n                var current = value.get();\\n                if (typeof current === \\\"string\\\") {\\n                    value.set(parseFloat(current));\\n                }\\n                if (typeof to === \\\"string\\\") {\\n                    target[key] = parseFloat(to);\\n                }\\n                else if (Array.isArray(to) && toType === styleValueTypes.px) {\\n                    target[key] = to.map(parseFloat);\\n                }\\n            }\\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\\n                (from === 0 || to === 0)) {\\n                // If one or the other value is 0, it's safe to coerce it to the\\n                // type of the other without measurement\\n                if (from === 0) {\\n                    value.set(toType.transform(from));\\n                }\\n                else {\\n                    target[key] = fromType.transform(to);\\n                }\\n            }\\n            else {\\n                // If we're going to do value conversion via DOM measurements, we first\\n                // need to remove non-positional transform values that could affect the bbox measurements.\\n                if (!hasAttemptedToRemoveTransformValues) {\\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\\n                    hasAttemptedToRemoveTransformValues = true;\\n                }\\n                changedValueTypeKeys.push(key);\\n                transitionEnd[key] =\\n                    transitionEnd[key] !== undefined\\n                        ? transitionEnd[key]\\n                        : target[key];\\n                setAndResetVelocity(value, to);\\n            }\\n        }\\n    });\\n    if (changedValueTypeKeys.length) {\\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\\n        // If we removed transform values, reapply them before the next render\\n        if (removedTransformValues.length) {\\n            removedTransformValues.forEach(function (_a) {\\n                var _b = tslib.__read(_a, 2), key = _b[0], value = _b[1];\\n                visualElement.getValue(key).set(value);\\n            });\\n        }\\n        // Reapply original values\\n        visualElement.syncRender();\\n        return { target: convertedTarget, transitionEnd: transitionEnd };\\n    }\\n    else {\\n        return { target: target, transitionEnd: transitionEnd };\\n    }\\n};\\n/**\\n * Convert value types for x/y/width/height/top/left/bottom/right\\n *\\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\\n *\\n * @internal\\n */\\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\\n    return hasPositionalKey(target)\\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\\n        : { target: target, transitionEnd: transitionEnd };\\n}\\n\\n/**\\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\\n * and ensuring animations like \\\"20%\\\" => \\\"calc(50vw)\\\" are performed in pixels.\\n */\\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\\n    target = resolved.target;\\n    transitionEnd = resolved.transitionEnd;\\n    return unitConversion(visualElement, target, origin, transitionEnd);\\n};\\n\\nfunction getComputedStyle$1(element) {\\n    return window.getComputedStyle(element);\\n}\\nvar htmlConfig = {\\n    treeType: \\\"dom\\\",\\n    readValueFromInstance: function (domElement, key) {\\n        if (isTransformProp(key)) {\\n            var defaultType = getDefaultValueType(key);\\n            return defaultType ? defaultType.default || 0 : 0;\\n        }\\n        else {\\n            var computedStyle = getComputedStyle$1(domElement);\\n            return ((isCSSVariable$1(key)\\n                ? computedStyle.getPropertyValue(key)\\n                : computedStyle[key]) || 0);\\n        }\\n    },\\n    sortNodePosition: function (a, b) {\\n        /**\\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\\n         * to true if b preceeds a.\\n         */\\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\\n    },\\n    getBaseTarget: function (props, key) {\\n        var _a;\\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\\n    },\\n    measureViewportBox: function (element, _a) {\\n        var transformPagePoint = _a.transformPagePoint;\\n        return getBoundingBox(element, transformPagePoint);\\n    },\\n    /**\\n     * Reset the transform on the current Element. This is called as part\\n     * of a batched process across the entire layout tree. To remove this write\\n     * cycle it'd be interesting to see if it's possible to \\\"undo\\\" all the current\\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\\n     * works\\n     */\\n    resetTransform: function (element, domElement, props) {\\n        var transformTemplate = props.transformTemplate;\\n        domElement.style.transform = transformTemplate\\n            ? transformTemplate({}, \\\"\\\")\\n            : \\\"none\\\";\\n        // Ensure that whatever happens next, we restore our transform on the next frame\\n        element.scheduleRender();\\n    },\\n    restoreTransform: function (instance, mutableState) {\\n        instance.style.transform = mutableState.style.transform;\\n    },\\n    removeValueFromRenderState: function (key, _a) {\\n        var vars = _a.vars, style = _a.style;\\n        delete vars[key];\\n        delete style[key];\\n    },\\n    /**\\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\\n     * can be animated by Motion.\\n     */\\n    makeTargetAnimatable: function (element, _a, _b, isMounted) {\\n        var transformValues = _b.transformValues;\\n        if (isMounted === void 0) { isMounted = true; }\\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\\\"transition\\\", \\\"transitionEnd\\\"]);\\n        var origin = getOrigin(target, transition || {}, element);\\n        /**\\n         * If Framer has provided a function to convert `Color` etc value types, convert them\\n         */\\n        if (transformValues) {\\n            if (transitionEnd)\\n                transitionEnd = transformValues(transitionEnd);\\n            if (target)\\n                target = transformValues(target);\\n            if (origin)\\n                origin = transformValues(origin);\\n        }\\n        if (isMounted) {\\n            checkTargetForNewValues(element, target, origin);\\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\\n            transitionEnd = parsed.transitionEnd;\\n            target = parsed.target;\\n        }\\n        return tslib.__assign({ transition: transition,\\n            transitionEnd: transitionEnd }, target);\\n    },\\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\\n    build: function (element, renderState, latestValues, projection, layoutState, options, props) {\\n        if (element.isVisible !== undefined) {\\n            renderState.style.visibility = element.isVisible\\n                ? \\\"visible\\\"\\n                : \\\"hidden\\\";\\n        }\\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\\n        buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\\n            ? buildLayoutProjectionTransformOrigin\\n            : undefined);\\n    },\\n    render: renderHTML,\\n};\\nvar htmlVisualElement = visualElement(htmlConfig);\\n\\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), { getBaseTarget: function (props, key) {\\n        return props[key];\\n    },\\n    readValueFromInstance: function (domElement, key) {\\n        var _a;\\n        if (isTransformProp(key)) {\\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\\n        }\\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\\n        return domElement.getAttribute(key);\\n    },\\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\\n    build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\\n        buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\\n            ? buildLayoutProjectionTransformOrigin\\n            : undefined);\\n    }, render: renderSVG }));\\n\\nvar createDomVisualElement = function (Component, options) {\\n    return isSVGComponent(Component)\\n        ? svgVisualElement(options, { enableHardwareAcceleration: false })\\n        : htmlVisualElement(options, { enableHardwareAcceleration: true });\\n};\\n\\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\\n/**\\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\\n *\\n * @public\\n */\\nvar motion = /*@__PURE__*/ createMotionProxy(function (Component, config) {\\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\\n});\\n/**\\n * Create a DOM `motion` component with the provided string. This is primarily intended\\n * as a full alternative to `motion` for consumers who have to support environments that don't\\n * support `Proxy`.\\n *\\n * ```javascript\\n * import { createDomMotionComponent } from \\\"framer-motion\\\"\\n *\\n * const motion = {\\n *   div: createDomMotionComponent('div')\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction createDomMotionComponent(key) {\\n    return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, featureBundle, createDomVisualElement));\\n}\\n\\n/**\\n * @public\\n */\\nvar m = createMotionProxy(createDomMotionConfig);\\n\\nfunction useForceUpdate() {\\n    var unloadingRef = React.useRef(false);\\n    var _a = tslib.__read(React.useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\\n    useUnmountEffect(function () { return (unloadingRef.current = true); });\\n    return React.useCallback(function () {\\n        !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\\n    }, [forcedRenderCount]);\\n}\\n\\nvar presenceId = 0;\\nfunction getPresenceId() {\\n    var id = presenceId;\\n    presenceId++;\\n    return id;\\n}\\nvar PresenceChild = function (_a) {\\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\\n    var presenceChildren = useConstant(newChildrenMap);\\n    var id = useConstant(getPresenceId);\\n    var context = React.useMemo(function () { return ({\\n        id: id,\\n        initial: initial,\\n        isPresent: isPresent,\\n        custom: custom,\\n        onExitComplete: function (childId) {\\n            presenceChildren.set(childId, true);\\n            var allComplete = true;\\n            presenceChildren.forEach(function (isComplete) {\\n                if (!isComplete)\\n                    allComplete = false;\\n            });\\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\\n        },\\n        register: function (childId) {\\n            presenceChildren.set(childId, false);\\n            return function () { return presenceChildren.delete(childId); };\\n        },\\n    }); }, \\n    /**\\n     * If the presence of a child affects the layout of the components around it,\\n     * we want to make a new context value to ensure they get re-rendered\\n     * so they can detect that layout change.\\n     */\\n    presenceAffectsLayout ? undefined : [isPresent]);\\n    React.useMemo(function () {\\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\\n    }, [isPresent]);\\n    /**\\n     * If there's no `motion` components to fire exit animations, we want to remove this\\n     * component immediately.\\n     */\\n    React__namespace.useEffect(function () {\\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\\n    }, [isPresent]);\\n    return (React__namespace.createElement(PresenceContext.Provider, { value: context }, children));\\n};\\nfunction newChildrenMap() {\\n    return new Map();\\n}\\n\\nfunction getChildKey(child) {\\n    return child.key || \\\"\\\";\\n}\\nfunction updateChildLookup(children, allChildren) {\\n    var seenChildren = process.env.NODE_ENV !== \\\"production\\\" ? new Set() : null;\\n    children.forEach(function (child) {\\n        var key = getChildKey(child);\\n        if (process.env.NODE_ENV !== \\\"production\\\" && seenChildren) {\\n            if (seenChildren.has(key)) {\\n                console.warn(\\\"Children of AnimatePresence require unique keys. \\\\\\\"\\\" + key + \\\"\\\\\\\" is a duplicate.\\\");\\n            }\\n            seenChildren.add(key);\\n        }\\n        allChildren.set(key, child);\\n    });\\n}\\nfunction onlyElements(children) {\\n    var filtered = [];\\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\\n    React.Children.forEach(children, function (child) {\\n        if (React.isValidElement(child))\\n            filtered.push(child);\\n    });\\n    return filtered;\\n}\\n/**\\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\\n *\\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\\n *\\n * @library\\n *\\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\\n * the tree.\\n *\\n * ```jsx\\n * import { Frame, AnimatePresence } from 'framer'\\n *\\n * // As items are added and removed from `items`\\n * export function Items({ items }) {\\n *   return (\\n *     <AnimatePresence>\\n *       {items.map(item => (\\n *         <Frame\\n *           key={item.id}\\n *           initial={{ opacity: 0 }}\\n *           animate={{ opacity: 1 }}\\n *           exit={{ opacity: 0 }}\\n *         />\\n *       ))}\\n *     </AnimatePresence>\\n *   )\\n * }\\n * ```\\n *\\n * You can sequence exit animations throughout a tree using variants.\\n *\\n * @motion\\n *\\n * Any `motion` components that have an `exit` property defined will animate out when removed from\\n * the tree.\\n *\\n * ```jsx\\n * import { motion, AnimatePresence } from 'framer-motion'\\n *\\n * export const Items = ({ items }) => (\\n *   <AnimatePresence>\\n *     {items.map(item => (\\n *       <motion.div\\n *         key={item.id}\\n *         initial={{ opacity: 0 }}\\n *         animate={{ opacity: 1 }}\\n *         exit={{ opacity: 0 }}\\n *       />\\n *     ))}\\n *   </AnimatePresence>\\n * )\\n * ```\\n *\\n * You can sequence exit animations throughout a tree using variants.\\n *\\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\\n * once all `motion` components have finished animating out. Likewise, any components using\\n * `usePresence` all need to call `safeToRemove`.\\n *\\n * @public\\n */\\nvar AnimatePresence = function (_a) {\\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\\n    // We want to force a re-render once all exiting animations have finished. We\\n    // either use a local forceRender function, or one from a parent context if it exists.\\n    var forceRender = useForceUpdate();\\n    var layoutContext = React.useContext(SharedLayoutContext);\\n    if (isSharedLayout(layoutContext)) {\\n        forceRender = layoutContext.forceUpdate;\\n    }\\n    var isInitialRender = React.useRef(true);\\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\\n    var filteredChildren = onlyElements(children);\\n    // Keep a living record of the children we're actually rendering so we\\n    // can diff to figure out which are entering and exiting\\n    var presentChildren = React.useRef(filteredChildren);\\n    // A lookup table to quickly reference components by key\\n    var allChildren = React.useRef(new Map())\\n        .current;\\n    // A living record of all currently exiting components.\\n    var exiting = React.useRef(new Set()).current;\\n    updateChildLookup(filteredChildren, allChildren);\\n    // If this is the initial component render, just deal with logic surrounding whether\\n    // we play onMount animations or not.\\n    if (isInitialRender.current) {\\n        isInitialRender.current = false;\\n        return (React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) { return (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\\n    }\\n    // If this is a subsequent render, deal with entering and exiting children\\n    var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren));\\n    // Diff the keys of the currently-present and target children to update our\\n    // exiting list.\\n    var presentKeys = presentChildren.current.map(getChildKey);\\n    var targetKeys = filteredChildren.map(getChildKey);\\n    // Diff the present children with our target children and mark those that are exiting\\n    var numPresent = presentKeys.length;\\n    for (var i = 0; i < numPresent; i++) {\\n        var key = presentKeys[i];\\n        if (targetKeys.indexOf(key) === -1) {\\n            exiting.add(key);\\n        }\\n        else {\\n            // In case this key has re-entered, remove from the exiting list\\n            exiting.delete(key);\\n        }\\n    }\\n    // If we currently have exiting children, and we're deferring rendering incoming children\\n    // until after all current children have exiting, empty the childrenToRender array\\n    if (exitBeforeEnter && exiting.size) {\\n        childrenToRender = [];\\n    }\\n    // Loop through all currently exiting components and clone them to overwrite `animate`\\n    // with any `exit` prop they might have defined.\\n    exiting.forEach(function (key) {\\n        // If this component is actually entering again, early return\\n        if (targetKeys.indexOf(key) !== -1)\\n            return;\\n        var child = allChildren.get(key);\\n        if (!child)\\n            return;\\n        var insertionIndex = presentKeys.indexOf(key);\\n        var onExit = function () {\\n            allChildren.delete(key);\\n            exiting.delete(key);\\n            // Remove this child from the present children\\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\\n            presentChildren.current.splice(removeIndex, 1);\\n            // Defer re-rendering until all exiting children have indeed left\\n            if (!exiting.size) {\\n                presentChildren.current = filteredChildren;\\n                forceRender();\\n                onExitComplete && onExitComplete();\\n            }\\n        };\\n        childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\\n    });\\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\\n    // the same tree between renders\\n    childrenToRender = childrenToRender.map(function (child) {\\n        var key = child.key;\\n        return exiting.has(key) ? (child) : (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\\n    });\\n    presentChildren.current = childrenToRender;\\n    if (process.env.NODE_ENV !== \\\"production\\\" &&\\n        exitBeforeEnter &&\\n        childrenToRender.length > 1) {\\n        console.warn(\\\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\\\");\\n    }\\n    return (React__namespace.createElement(React__namespace.Fragment, null, exiting.size\\n        ? childrenToRender\\n        : childrenToRender.map(function (child) { return React.cloneElement(child); })));\\n};\\n\\n/**\\n * Animate a single value or a `MotionValue`.\\n *\\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\\n *\\n * The second is either a value to animate to, or an array of keyframes to animate through.\\n *\\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\\n *\\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\\n *\\n * ```javascript\\n * const x = useMotionValue(0)\\n *\\n * useEffect(() => {\\n *   const controls = animate(x, 100, {\\n *     type: \\\"spring\\\",\\n *     stiffness: 2000,\\n *     onComplete: v => {}\\n *   })\\n *\\n *   return controls.stop\\n * })\\n * ```\\n *\\n * @public\\n */\\nfunction animate(from, to, transition) {\\n    if (transition === void 0) { transition = {}; }\\n    var value = isMotionValue(from) ? from : motionValue(from);\\n    startAnimation(\\\"\\\", value, to, transition);\\n    return {\\n        stop: function () { return value.stop(); },\\n    };\\n}\\n\\nfunction createCrossfader() {\\n    /**\\n     * The current state of the crossfade as a value between 0 and 1\\n     */\\n    var progress = motionValue(1);\\n    var options = {\\n        lead: undefined,\\n        follow: undefined,\\n        crossfadeOpacity: false,\\n        preserveFollowOpacity: false,\\n    };\\n    var prevOptions = tslib.__assign({}, options);\\n    var leadState = {};\\n    var followState = {};\\n    /**\\n     *\\n     */\\n    var isActive = false;\\n    /**\\n     *\\n     */\\n    var finalCrossfadeFrame = null;\\n    /**\\n     * Framestamp of the last frame we updated values at.\\n     */\\n    var prevUpdate = 0;\\n    function startCrossfadeAnimation(target, transition) {\\n        var lead = options.lead, follow = options.follow;\\n        isActive = true;\\n        finalCrossfadeFrame = null;\\n        var hasUpdated = false;\\n        var onUpdate = function () {\\n            hasUpdated = true;\\n            lead && lead.scheduleRender();\\n            follow && follow.scheduleRender();\\n        };\\n        var onComplete = function () {\\n            isActive = false;\\n            /**\\n             * If the crossfade animation is no longer active, flag a frame\\n             * that we're still allowed to crossfade\\n             */\\n            finalCrossfadeFrame = sync.getFrameData().timestamp;\\n        };\\n        transition = transition && getValueTransition(transition, \\\"crossfade\\\");\\n        return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\\n                if (!hasUpdated) {\\n                    progress.set(target);\\n                    /**\\n                     * If we never ran an update, for instance if this was an instant transition, fire a\\n                     * simulated final frame to ensure the crossfade gets applied correctly.\\n                     */\\n                    sync__default['default'].read(onComplete);\\n                }\\n                else {\\n                    onComplete();\\n                }\\n                onUpdate();\\n            } }));\\n    }\\n    function updateCrossfade() {\\n        var _a, _b;\\n        /**\\n         * We only want to compute the crossfade once per frame, so we\\n         * compare the previous update framestamp with the current frame\\n         * and early return if they're the same.\\n         */\\n        var timestamp = sync.getFrameData().timestamp;\\n        var lead = options.lead, follow = options.follow;\\n        if (timestamp === prevUpdate || !lead)\\n            return;\\n        prevUpdate = timestamp;\\n        /**\\n         * Merge each component's latest values into our crossfaded state\\n         * before crossfading.\\n         */\\n        var latestLeadValues = lead.getLatestValues();\\n        Object.assign(leadState, latestLeadValues);\\n        var latestFollowValues = follow\\n            ? follow.getLatestValues()\\n            : options.prevValues;\\n        Object.assign(followState, latestFollowValues);\\n        var p = progress.get();\\n        /**\\n         * Crossfade the opacity between the two components. This will result\\n         * in a different opacity for each component.\\n         */\\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\\n        if (options.crossfadeOpacity && follow) {\\n            leadState.opacity = popmotion.mix(\\n            /**\\n             * If the follow child has been completely hidden we animate\\n             * this opacity from its previous opacity, but otherwise from completely transparent.\\n             */\\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\\n            followState.opacity = options.preserveFollowOpacity\\n                ? followTargetOpacity\\n                : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\\n        }\\n        else if (!follow) {\\n            leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\\n        }\\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\\n    }\\n    return {\\n        isActive: function () {\\n            return leadState &&\\n                (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\\n        },\\n        fromLead: function (transition) {\\n            return startCrossfadeAnimation(0, transition);\\n        },\\n        toLead: function (transition) {\\n            var initialProgress = 0;\\n            if (!options.prevValues && !options.follow) {\\n                /**\\n                 * If we're not coming from anywhere, start at the end of the animation.\\n                 */\\n                initialProgress = 1;\\n            }\\n            else if (prevOptions.lead === options.follow &&\\n                prevOptions.follow === options.lead) {\\n                /**\\n                 * If we're swapping follow/lead we can reverse the progress\\n                 */\\n                initialProgress = 1 - progress.get();\\n            }\\n            progress.set(initialProgress);\\n            return startCrossfadeAnimation(1, transition);\\n        },\\n        reset: function () { return progress.set(1); },\\n        stop: function () { return progress.stop(); },\\n        getCrossfadeState: function (element) {\\n            updateCrossfade();\\n            if (element === options.lead) {\\n                return leadState;\\n            }\\n            else if (element === options.follow) {\\n                return followState;\\n            }\\n        },\\n        setOptions: function (newOptions) {\\n            prevOptions = options;\\n            options = newOptions;\\n            leadState = {};\\n            followState = {};\\n        },\\n        getLatestValues: function () {\\n            return leadState;\\n        },\\n    };\\n}\\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\\nfunction compress(min, max, easing) {\\n    return function (p) {\\n        // Could replace ifs with clamp\\n        if (p < min)\\n            return 0;\\n        if (p > max)\\n            return 1;\\n        return easing(popmotion.progress(min, max, p));\\n    };\\n}\\nvar borders = [\\\"TopLeft\\\", \\\"TopRight\\\", \\\"BottomLeft\\\", \\\"BottomRight\\\"];\\nvar numBorders = borders.length;\\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\\n    /**\\n     * Mix border radius\\n     */\\n    for (var i = 0; i < numBorders; i++) {\\n        var borderLabel = \\\"border\\\" + borders[i] + \\\"Radius\\\";\\n        var followRadius = getRadius(latestFollowValues, borderLabel);\\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\\n        if (followRadius === undefined && leadRadius === undefined)\\n            continue;\\n        followRadius || (followRadius = 0);\\n        leadRadius || (leadRadius = 0);\\n        /**\\n         * Currently we're only crossfading between numerical border radius.\\n         * It would be possible to crossfade between percentages for a little\\n         * extra bundle size.\\n         */\\n        if (typeof followRadius === \\\"number\\\" &&\\n            typeof leadRadius === \\\"number\\\") {\\n            var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\\n            leadState[borderLabel] = followState[borderLabel] = radius;\\n        }\\n    }\\n    /**\\n     * Mix rotation\\n     */\\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\\n        var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\\n        leadState.rotate = followState.rotate = rotate;\\n    }\\n    /**\\n     * We only want to mix the background color if there's a follow element\\n     * that we're not crossfading opacity between. For instance with switch\\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\\n     * element being animated but also cuts down on the number of paints triggered\\n     * for elements where opacity is doing that work for us.\\n     */\\n    if (!hasFollowElement &&\\n        latestLeadValues.backgroundColor &&\\n        latestFollowValues.backgroundColor) {\\n        /**\\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\\n         * We could probably create a mixer that runs at the start of the animation but\\n         * the idea behind the crossfader is that it runs dynamically between two potentially\\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\\n         */\\n        leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\\n    }\\n}\\nfunction getRadius(values, radiusName) {\\n    var _a;\\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\\n}\\n\\nfunction layoutStack() {\\n    var stack = new Set();\\n    var state = { leadIsExiting: false };\\n    var prevState = tslib.__assign({}, state);\\n    var prevValues;\\n    var prevViewportBox;\\n    var prevDragCursor;\\n    var crossfader = createCrossfader();\\n    var needsCrossfadeAnimation = false;\\n    function getFollowViewportBox() {\\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\\n    }\\n    function getFollowLayout() {\\n        var _a;\\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\\n    }\\n    return {\\n        add: function (element) {\\n            element.setCrossfader(crossfader);\\n            stack.add(element);\\n            /**\\n             * Hydrate new element with previous drag position if we have one\\n             */\\n            if (prevDragCursor)\\n                element.prevDragCursor = prevDragCursor;\\n            if (!state.lead)\\n                state.lead = element;\\n        },\\n        remove: function (element) {\\n            stack.delete(element);\\n        },\\n        getLead: function () { return state.lead; },\\n        updateSnapshot: function () {\\n            if (!state.lead)\\n                return;\\n            prevValues = crossfader.isActive()\\n                ? crossfader.getLatestValues()\\n                : state.lead.getLatestValues();\\n            prevViewportBox = state.lead.prevViewportBox;\\n            var dragControls = elementDragControls.get(state.lead);\\n            if (dragControls && dragControls.isDragging) {\\n                prevDragCursor = dragControls.cursorProgress;\\n            }\\n        },\\n        clearSnapshot: function () {\\n            prevDragCursor = prevViewportBox = undefined;\\n        },\\n        updateLeadAndFollow: function () {\\n            var _a;\\n            prevState = tslib.__assign({}, state);\\n            var lead;\\n            var follow;\\n            var order = Array.from(stack);\\n            for (var i = order.length; i--; i >= 0) {\\n                var element = order[i];\\n                if (lead)\\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\\n                lead !== null && lead !== void 0 ? lead : (lead = element);\\n                if (lead && follow)\\n                    break;\\n            }\\n            state.lead = lead;\\n            state.follow = follow;\\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\\n            crossfader.setOptions({\\n                lead: lead,\\n                follow: follow,\\n                prevValues: prevValues,\\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\\n            });\\n            if (\\n            // Don't crossfade if we've just animated back from lead and switched the\\n            // old follow to the new lead.\\n            state.lead !== prevState.follow &&\\n                (prevState.lead !== state.lead ||\\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\\n                needsCrossfadeAnimation = true;\\n            }\\n        },\\n        animate: function (child, shouldCrossfade) {\\n            var _a;\\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\\n            if (child === state.lead) {\\n                if (shouldCrossfade) {\\n                    /**\\n                     * Point a lead to itself in case it was previously pointing\\n                     * to a different visual element\\n                     */\\n                    child.pointTo(state.lead);\\n                }\\n                else {\\n                    child.setVisibility(true);\\n                }\\n                var config = {};\\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\\n                if (prevParent) {\\n                    /**\\n                     * We'll use this to determine if the element or its layoutId has been reparented.\\n                     */\\n                    config.prevParent = prevParent;\\n                }\\n                if (child.presence === Presence.Entering) {\\n                    config.originBox = getFollowViewportBox();\\n                }\\n                else if (child.presence === Presence.Exiting) {\\n                    config.targetBox = getFollowLayout();\\n                }\\n                if (needsCrossfadeAnimation) {\\n                    needsCrossfadeAnimation = false;\\n                    var transition = child.getDefaultTransition();\\n                    child.presence === Presence.Entering\\n                        ? crossfader.toLead(transition)\\n                        : crossfader.fromLead(transition);\\n                }\\n                child.notifyLayoutReady(config);\\n            }\\n            else {\\n                if (shouldCrossfade) {\\n                    state.lead && child.pointTo(state.lead);\\n                }\\n                else {\\n                    child.setVisibility(false);\\n                }\\n            }\\n        },\\n    };\\n}\\n\\nfunction resetRotate(child) {\\n    // If there's no detected rotation values, we can early return without a forced render.\\n    var hasRotate = false;\\n    // Keep a record of all the values we've reset\\n    var resetValues = {};\\n    // Check the rotate value of all axes and reset to 0\\n    for (var i = 0; i < transformAxes.length; i++) {\\n        var axis = transformAxes[i];\\n        var key = \\\"rotate\\\" + axis;\\n        // If this rotation doesn't exist as a motion value, then we don't\\n        // need to reset it\\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\\n            continue;\\n        hasRotate = true;\\n        // Record the rotation and then temporarily set it to 0\\n        resetValues[key] = child.getStaticValue(key);\\n        child.setStaticValue(key, 0);\\n    }\\n    // If there's no rotation values, we don't need to do any more.\\n    if (!hasRotate)\\n        return;\\n    // Force a render of this element to apply the transform with all rotations\\n    // set to 0.\\n    child.syncRender();\\n    // Put back all the values we reset\\n    for (var key in resetValues) {\\n        child.setStaticValue(key, resetValues[key]);\\n    }\\n    // Schedule a render for the next frame. This ensures we won't visually\\n    // see the element with the reset rotate value applied.\\n    child.scheduleRender();\\n}\\n\\n/**\\n * @public\\n */\\nvar AnimateSharedLayout = /** @class */ (function (_super) {\\n    tslib.__extends(AnimateSharedLayout, _super);\\n    function AnimateSharedLayout() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        /**\\n         * A list of all the children in the shared layout\\n         */\\n        _this.children = new Set();\\n        /**\\n         * As animate components with a defined `layoutId` are added/removed to the tree,\\n         * we store them in order. When one is added, it will animate out from the\\n         * previous one, and when it's removed, it'll animate to the previous one.\\n         */\\n        _this.stacks = new Map();\\n        /**\\n         * Track whether the component has mounted. If it hasn't, the presence of added children\\n         * are set to Present, whereas if it has they're considered Entering\\n         */\\n        _this.hasMounted = false;\\n        /**\\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\\n         * and schedule one.\\n         */\\n        _this.updateScheduled = false;\\n        /**\\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\\n         */\\n        _this.renderScheduled = false;\\n        /**\\n         * The methods provided to all children in the shared layout tree.\\n         */\\n        _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\\n                // all children subscribed to the SharedLayout context.\\n                _this.syncContext = tslib.__assign({}, _this.syncContext);\\n                _this.scheduleUpdate(true);\\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\\n        return _this;\\n    }\\n    AnimateSharedLayout.prototype.componentDidMount = function () {\\n        this.hasMounted = true;\\n    };\\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\\n        this.startLayoutAnimation();\\n    };\\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\\n        this.renderScheduled = true;\\n        return true;\\n    };\\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\\n        var _this = this;\\n        /**\\n         * Reset update and render scheduled status\\n         */\\n        this.renderScheduled = this.updateScheduled = false;\\n        var type = this.props.type;\\n        /**\\n         * Update presence metadata based on the latest AnimatePresence status.\\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\\n         */\\n        this.children.forEach(function (child) {\\n            if (!child.isPresent) {\\n                child.presence = Presence.Exiting;\\n            }\\n            else if (child.presence !== Presence.Entering) {\\n                child.presence =\\n                    child.presence === Presence.Exiting\\n                        ? Presence.Entering\\n                        : Presence.Present;\\n            }\\n        });\\n        this.updateStacks();\\n        /**\\n         * Create a handler which we can use to flush the children animations\\n         */\\n        var handler = {\\n            layoutReady: function (child) {\\n                if (child.getLayoutId() !== undefined) {\\n                    var stack = _this.getStack(child);\\n                    stack.animate(child, type === \\\"crossfade\\\");\\n                }\\n                else {\\n                    child.notifyLayoutReady();\\n                }\\n            },\\n            parent: this.context.visualElement,\\n        };\\n        /**\\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\\n         * This requires some co-ordination across components to stop layout thrashing\\n         * and ensure measurements are taken at the correct time.\\n         *\\n         * Here we use that same mechanism of schedule/flush.\\n         */\\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\\n        this.syncContext.flush(handler);\\n        /**\\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\\n         */\\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\\n    };\\n    AnimateSharedLayout.prototype.updateStacks = function () {\\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\\n    };\\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\\n        if (force === void 0) { force = false; }\\n        if (!(force || !this.updateScheduled))\\n            return;\\n        /**\\n         * Flag we've scheduled an update\\n         */\\n        this.updateScheduled = true;\\n        /**\\n         * Write: Reset transforms so bounding boxes can be accurately measured.\\n         */\\n        this.children.forEach(function (child) {\\n            resetRotate(child);\\n            if (child.shouldResetTransform())\\n                child.resetTransform();\\n        });\\n        /**\\n         * Read: Snapshot children\\n         */\\n        this.children.forEach(snapshotViewportBox);\\n        /**\\n         * Every child keeps a local snapshot, but we also want to record\\n         * snapshots of the visible children as, if they're are being removed\\n         * in this render, we can still access them.\\n         *\\n         * TODO: What would be better here is doing a single loop where we\\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\\n         */\\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\\n        /**\\n         * Force a rerender by setting state if we aren't already going to render.\\n         */\\n        if (force || !this.renderScheduled) {\\n            this.renderScheduled = true;\\n            this.forceUpdate();\\n        }\\n    };\\n    AnimateSharedLayout.prototype.addChild = function (child) {\\n        this.children.add(child);\\n        this.addToStack(child);\\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\\n    };\\n    AnimateSharedLayout.prototype.removeChild = function (child) {\\n        this.scheduleUpdate();\\n        this.children.delete(child);\\n        this.removeFromStack(child);\\n    };\\n    AnimateSharedLayout.prototype.addToStack = function (child) {\\n        var stack = this.getStack(child);\\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\\n    };\\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\\n        var stack = this.getStack(child);\\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\\n    };\\n    /**\\n     * Return a stack of animate children based on the provided layoutId.\\n     * Will create a stack if none currently exists with that layoutId.\\n     */\\n    AnimateSharedLayout.prototype.getStack = function (child) {\\n        var id = child.getLayoutId();\\n        if (id === undefined)\\n            return;\\n        // Create stack if it doesn't already exist\\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\\n        return this.stacks.get(id);\\n    };\\n    AnimateSharedLayout.prototype.render = function () {\\n        return (React__namespace.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\\n    };\\n    AnimateSharedLayout.contextType = MotionContext;\\n    return AnimateSharedLayout;\\n}(React__namespace.Component));\\n\\n/**\\n * `MotionConfig` is used to set configuration options for all children `motion` components.\\n *\\n * ```jsx\\n * import { motion, MotionConfig } from \\\"framer-motion\\\"\\n *\\n * export function App() {\\n *   return (\\n *     <MotionConfig transition={{ type: \\\"spring\\\" }}>\\n *       <motion.div animate={{ x: 100 }} />\\n *     </MotionConfig>\\n *   )\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction MotionConfig(_a) {\\n    var children = _a.children, config = tslib.__rest(_a, [\\\"children\\\"]);\\n    /**\\n     * Inherit props from any parent MotionConfig components\\n     */\\n    config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\\n    /**\\n     * Don't allow isStatic to change between renders as it affects how many hooks\\n     * motion components fire.\\n     */\\n    config.isStatic = useConstant(function () { return config.isStatic; });\\n    /**\\n     * Creating a new config context object will re-render every `motion` component\\n     * every time it renders. So we only want to create a new one sparingly.\\n     */\\n    var transitionDependency = typeof config.transition === \\\"object\\\"\\n        ? config.transition.toString()\\n        : \\\"\\\";\\n    var context = React.useMemo(function () { return config; }, [\\n        transitionDependency,\\n        config.transformPagePoint,\\n    ]);\\n    return (React__namespace.createElement(MotionConfigContext.Provider, { value: context }, children));\\n}\\n\\n/**\\n * Used in conjunction with the `m` component to reduce bundle size.\\n *\\n * `m` is a version of the `motion` component that only loads functionality\\n * critical for the initial render.\\n *\\n * `LazyMotion` can then be used to either synchronously or asynchronously\\n * load animation and gesture support.\\n *\\n * ```jsx\\n * // Synchronous loading\\n * import { LazyMotion, m, domAnimations } from \\\"framer-motion\\\"\\n *\\n * function App() {\\n *   return (\\n *     <LazyMotion features={domAnimations}>\\n *       <m.div animate={{ scale: 2 }} />\\n *     </LazyMotion>\\n *   )\\n * }\\n *\\n * // Asynchronous loading\\n * import { LazyMotion, m } from \\\"framer-motion\\\"\\n *\\n * function App() {\\n *   return (\\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\\n *       <m.div animate={{ scale: 2 }} />\\n *     </LazyMotion>\\n *   )\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction LazyMotion(_a) {\\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\\n    var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\\n    var loadedRenderer = React.useRef(undefined);\\n    /**\\n     * If this is a synchronous load, load features immediately\\n     */\\n    if (!isLazyBundle(features)) {\\n        var renderer = features.renderer, loadedFeatures = tslib.__rest(features, [\\\"renderer\\\"]);\\n        loadedRenderer.current = renderer;\\n        loadFeatures(loadedFeatures);\\n    }\\n    React.useEffect(function () {\\n        if (isLazyBundle(features)) {\\n            features().then(function (_a) {\\n                var renderer = _a.renderer, loadedFeatures = tslib.__rest(_a, [\\\"renderer\\\"]);\\n                loadFeatures(loadedFeatures);\\n                loadedRenderer.current = renderer;\\n                setIsLoaded(true);\\n            });\\n        }\\n    }, []);\\n    return (React__namespace.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict: strict } }, children));\\n}\\nfunction isLazyBundle(features) {\\n    return typeof features === \\\"function\\\";\\n}\\n\\n/**\\n * @public\\n */\\nvar domAnimation = tslib.__assign(tslib.__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);\\n\\n/**\\n * @public\\n */\\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\\n\\n/**\\n * Creates a `MotionValue` to track the state and velocity of a value.\\n *\\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\\n *\\n * @library\\n *\\n * ```jsx\\n * export function MyComponent() {\\n *   const scale = useMotionValue(1)\\n *\\n *   return <Frame scale={scale} />\\n * }\\n * ```\\n *\\n * @motion\\n *\\n * ```jsx\\n * export const MyComponent = () => {\\n *   const scale = useMotionValue(1)\\n *\\n *   return <motion.div style={{ scale }} />\\n * }\\n * ```\\n *\\n * @param initial - The initial state.\\n *\\n * @public\\n */\\nfunction useMotionValue(initial) {\\n    var value = useConstant(function () { return motionValue(initial); });\\n    /**\\n     * If this motion value is being used in static mode, like on\\n     * the Framer canvas, force components to rerender when the motion\\n     * value is updated.\\n     */\\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\\n    if (isStatic) {\\n        var _a = tslib.__read(React.useState(initial), 2), setLatest_1 = _a[1];\\n        React.useEffect(function () { return value.onChange(setLatest_1); }, []);\\n    }\\n    return value;\\n}\\n\\nfunction useOnChange(value, callback) {\\n    React.useEffect(function () {\\n        if (isMotionValue(value))\\n            return value.onChange(callback);\\n    }, [callback]);\\n}\\nfunction useMultiOnChange(values, handler) {\\n    React.useEffect(function () {\\n        var subscriptions = values.map(function (value) { return value.onChange(handler); });\\n        return function () { return subscriptions.forEach(function (unsubscribe) { return unsubscribe(); }); };\\n    });\\n}\\n\\nfunction useCombineMotionValues(values, combineValues) {\\n    /**\\n     * Initialise the returned motion value. This remains the same between renders.\\n     */\\n    var value = useMotionValue(combineValues());\\n    /**\\n     * Create a function that will update the template motion value with the latest values.\\n     * This is pre-bound so whenever a motion value updates it can schedule its\\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\\n     * in a single frame.\\n     */\\n    var updateValue = function () { return value.set(combineValues()); };\\n    /**\\n     * Synchronously update the motion value with the latest values during the render.\\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\\n     */\\n    updateValue();\\n    /**\\n     * Subscribe to all motion values found within the template. Whenever any of them change,\\n     * schedule an update.\\n     */\\n    useMultiOnChange(values, function () { return sync__default['default'].update(updateValue, false, true); });\\n    return value;\\n}\\n\\n/**\\n * Combine multiple motion values into a new one using a string template literal.\\n *\\n * ```jsx\\n * import {\\n *   motion,\\n *   useSpring,\\n *   useMotionValue,\\n *   useMotionTemplate\\n * } from \\\"framer-motion\\\"\\n *\\n * function Component() {\\n *   const shadowX = useSpring(0)\\n *   const shadowY = useMotionValue(0)\\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\\n *\\n *   return <motion.div style={{ filter: shadow }} />\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction useMotionTemplate(fragments) {\\n    var values = [];\\n    for (var _i = 1; _i < arguments.length; _i++) {\\n        values[_i - 1] = arguments[_i];\\n    }\\n    /**\\n     * Create a function that will build a string from the latest motion values.\\n     */\\n    var numFragments = fragments.length;\\n    function buildValue() {\\n        var output = \\\"\\\";\\n        for (var i = 0; i < numFragments; i++) {\\n            output += fragments[i];\\n            var value = values[i];\\n            if (value)\\n                output += values[i].get();\\n        }\\n        return output;\\n    }\\n    return useCombineMotionValues(values, buildValue);\\n}\\n\\nvar isCustomValueType = function (v) {\\n    return typeof v === \\\"object\\\" && v.mix;\\n};\\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\\nfunction transform() {\\n    var args = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        args[_i] = arguments[_i];\\n    }\\n    var useImmediate = !Array.isArray(args[0]);\\n    var argOffset = useImmediate ? 0 : -1;\\n    var inputValue = args[0 + argOffset];\\n    var inputRange = args[1 + argOffset];\\n    var outputRange = args[2 + argOffset];\\n    var options = args[3 + argOffset];\\n    var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({ mixer: getMixer(outputRange[0]) }, options));\\n    return useImmediate ? interpolator(inputValue) : interpolator;\\n}\\n\\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\\n    var transformer = typeof inputRangeOrTransformer === \\\"function\\\"\\n        ? inputRangeOrTransformer\\n        : transform(inputRangeOrTransformer, outputRange, options);\\n    return Array.isArray(input)\\n        ? useListTransform(input, transformer)\\n        : useListTransform([input], function (_a) {\\n            var _b = tslib.__read(_a, 1), latest = _b[0];\\n            return transformer(latest);\\n        });\\n}\\nfunction useListTransform(values, transformer) {\\n    var latest = useConstant(function () { return []; });\\n    return useCombineMotionValues(values, function () {\\n        latest.length = 0;\\n        var numValues = values.length;\\n        for (var i = 0; i < numValues; i++) {\\n            latest[i] = values[i].get();\\n        }\\n        return transformer(latest);\\n    });\\n}\\n\\n/**\\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\\n *\\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\\n * to another `MotionValue`.\\n *\\n * @remarks\\n *\\n * ```jsx\\n * const x = useSpring(0, { stiffness: 300 })\\n * const y = useSpring(x, { damping: 10 })\\n * ```\\n *\\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\\n * @param springConfig - Configuration options for the spring.\\n * @returns `MotionValue`\\n *\\n * @public\\n */\\nfunction useSpring(source, config) {\\n    if (config === void 0) { config = {}; }\\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\\n    var activeSpringAnimation = React.useRef(null);\\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\\n    React.useMemo(function () {\\n        return value.attach(function (v, set) {\\n            /**\\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\\n             * at that level, but this will work for now\\n             */\\n            if (isStatic)\\n                return set(v);\\n            if (activeSpringAnimation.current) {\\n                activeSpringAnimation.current.stop();\\n            }\\n            activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\\n            return value.get();\\n        });\\n    }, Object.values(config));\\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\\n    return value;\\n}\\n\\n/**\\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\\n *\\n * ```javascript\\n * const x = useMotionValue(0)\\n * const xVelocity = useVelocity(x)\\n * const xAcceleration = useVelocity(xVelocity)\\n * ```\\n *\\n * @public\\n */\\nfunction useVelocity(value) {\\n    var velocity = useMotionValue(value.getVelocity());\\n    React.useEffect(function () {\\n        return value.velocityUpdateSubscribers.add(function (newVelocity) {\\n            velocity.set(newVelocity);\\n        });\\n    }, [value]);\\n    return velocity;\\n}\\n\\nfunction createScrollMotionValues() {\\n    return {\\n        scrollX: motionValue(0),\\n        scrollY: motionValue(0),\\n        scrollXProgress: motionValue(0),\\n        scrollYProgress: motionValue(0),\\n    };\\n}\\nfunction setProgress(offset, maxOffset, value) {\\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\\n}\\nfunction createScrollUpdater(values, getOffsets) {\\n    var update = function () {\\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\\n        // Set absolute positions\\n        values.scrollX.set(xOffset);\\n        values.scrollY.set(yOffset);\\n        // Set 0-1 progress\\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\\n    };\\n    update();\\n    return update;\\n}\\n\\nvar getElementScrollOffsets = function (element) { return function () {\\n    return {\\n        xOffset: element.scrollLeft,\\n        yOffset: element.scrollTop,\\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\\n    };\\n}; };\\n/**\\n * Returns MotionValues that update when the provided element scrolls:\\n *\\n * - `scrollX` \\u2014 Horizontal scroll distance in pixels.\\n * - `scrollY` \\u2014 Vertical scroll distance in pixels.\\n * - `scrollXProgress` \\u2014 Horizontal scroll progress between `0` and `1`.\\n * - `scrollYProgress` \\u2014 Vertical scroll progress between `0` and `1`.\\n *\\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\\n *\\n * @library\\n *\\n * ```jsx\\n * import * as React from \\\"react\\\"\\n * import {\\n *   Frame,\\n *   useElementScroll,\\n *   useTransform\\n * } from \\\"framer\\\"\\n *\\n * export function MyComponent() {\\n *   const ref = React.useRef()\\n *   const { scrollYProgress } = useElementScroll(ref)\\n *\\n *   return (\\n *     <Frame ref={ref}>\\n *       <Frame scaleX={scrollYProgress} />\\n *     </Frame>\\n *   )\\n * }\\n * ```\\n *\\n * @motion\\n *\\n * ```jsx\\n * export const MyComponent = () => {\\n *   const ref = useRef()\\n *   const { scrollYProgress } = useElementScroll(ref)\\n *\\n *   return (\\n *     <div ref={ref}>\\n *       <motion.div style={{ scaleX: scrollYProgress }} />\\n *     </div>\\n *   )\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction useElementScroll(ref) {\\n    var values = useConstant(createScrollMotionValues);\\n    useIsomorphicLayoutEffect(function () {\\n        var element = ref.current;\\n        heyListen.invariant(!!element, \\\"ref provided to useScroll must be passed into a HTML element.\\\");\\n        if (!element)\\n            return;\\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\\n        var scrollListener = addDomEvent(element, \\\"scroll\\\", updateScrollValues, { passive: true });\\n        var resizeListener = addDomEvent(element, \\\"resize\\\", updateScrollValues);\\n        return function () {\\n            scrollListener && scrollListener();\\n            resizeListener && resizeListener();\\n        };\\n    }, []);\\n    return values;\\n}\\n\\nvar viewportScrollValues;\\nfunction getViewportScrollOffsets() {\\n    return {\\n        xOffset: window.pageXOffset,\\n        yOffset: window.pageYOffset,\\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\\n    };\\n}\\nvar hasListeners = false;\\nfunction addEventListeners() {\\n    hasListeners = true;\\n    if (typeof window === \\\"undefined\\\")\\n        return;\\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\\n    addDomEvent(window, \\\"scroll\\\", updateScrollValues, { passive: true });\\n    addDomEvent(window, \\\"resize\\\", updateScrollValues);\\n}\\n/**\\n * Returns MotionValues that update when the viewport scrolls:\\n *\\n * - `scrollX` \\u2014 Horizontal scroll distance in pixels.\\n * - `scrollY` \\u2014 Vertical scroll distance in pixels.\\n * - `scrollXProgress` \\u2014 Horizontal scroll progress between `0` and `1`.\\n * - `scrollYProgress` \\u2014 Vertical scroll progress between `0` and `1`.\\n *\\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\\n * values as this breaks the browser's capability to accurately measure the page length.\\n *\\n * @library\\n *\\n * ```jsx\\n * import * as React from \\\"react\\\"\\n * import {\\n *   Frame,\\n *   useViewportScroll,\\n *   useTransform\\n * } from \\\"framer\\\"\\n *\\n * export function MyComponent() {\\n *   const { scrollYProgress } = useViewportScroll()\\n *   return <Frame scaleX={scrollYProgress} />\\n * }\\n * ```\\n *\\n * @motion\\n *\\n * ```jsx\\n * export const MyComponent = () => {\\n *   const { scrollYProgress } = useViewportScroll()\\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\\n * }\\n * ```\\n *\\n * @public\\n */\\nfunction useViewportScroll() {\\n    /**\\n     * Lazy-initialise the viewport scroll values\\n     */\\n    if (!viewportScrollValues) {\\n        viewportScrollValues = createScrollMotionValues();\\n    }\\n    useIsomorphicLayoutEffect(function () {\\n        !hasListeners && addEventListeners();\\n    }, []);\\n    return viewportScrollValues;\\n}\\n\\n// Does this device prefer reduced motion? Returns `null` server-side.\\nvar prefersReducedMotion;\\nfunction initPrefersReducedMotion() {\\n    prefersReducedMotion = motionValue(null);\\n    if (typeof window === \\\"undefined\\\")\\n        return;\\n    if (window.matchMedia) {\\n        var motionMediaQuery_1 = window.matchMedia(\\\"(prefers-reduced-motion)\\\");\\n        var setReducedMotionPreferences = function () {\\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\\n        };\\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\\n        setReducedMotionPreferences();\\n    }\\n    else {\\n        prefersReducedMotion.set(false);\\n    }\\n}\\n/**\\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\\n *\\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\\n *\\n * It will actively respond to changes and re-render your components with the latest setting.\\n *\\n * ```jsx\\n * export function Sidebar({ isOpen }) {\\n *   const shouldReduceMotion = useReducedMotion()\\n *   const closedX = shouldReduceMotion ? 0 : \\\"-100%\\\"\\n *\\n *   return (\\n *     <motion.div animate={{\\n *       opacity: isOpen ? 1 : 0,\\n *       x: isOpen ? 0 : closedX\\n *     }} />\\n *   )\\n * }\\n * ```\\n *\\n * @return boolean\\n *\\n * @public\\n */\\nfunction useReducedMotion() {\\n    /**\\n     * Lazy initialisation of prefersReducedMotion\\n     */\\n    !prefersReducedMotion && initPrefersReducedMotion();\\n    var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\\n    useOnChange(prefersReducedMotion, setShouldReduceMotion);\\n    return shouldReduceMotion;\\n}\\n\\n/**\\n * @public\\n */\\nfunction animationControls() {\\n    /**\\n     * Track whether the host component has mounted.\\n     */\\n    var hasMounted = false;\\n    /**\\n     * Pending animations that are started before a component is mounted.\\n     * TODO: Remove this as animations should only run in effects\\n     */\\n    var pendingAnimations = [];\\n    /**\\n     * A collection of linked component animation controls.\\n     */\\n    var subscribers = new Set();\\n    var controls = {\\n        subscribe: function (visualElement) {\\n            subscribers.add(visualElement);\\n            return function () { return void subscribers.delete(visualElement); };\\n        },\\n        start: function (definition, transitionOverride) {\\n            /**\\n             * TODO: We only perform this hasMounted check because in Framer we used to\\n             * encourage the ability to start an animation within the render phase. This\\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\\n             * we can ditch this.\\n             */\\n            if (hasMounted) {\\n                var animations_1 = [];\\n                subscribers.forEach(function (visualElement) {\\n                    animations_1.push(animateVisualElement(visualElement, definition, {\\n                        transitionOverride: transitionOverride,\\n                    }));\\n                });\\n                return Promise.all(animations_1);\\n            }\\n            else {\\n                return new Promise(function (resolve) {\\n                    pendingAnimations.push({\\n                        animation: [definition, transitionOverride],\\n                        resolve: resolve,\\n                    });\\n                });\\n            }\\n        },\\n        set: function (definition) {\\n            heyListen.invariant(hasMounted, \\\"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\\\");\\n            return subscribers.forEach(function (visualElement) {\\n                setValues(visualElement, definition);\\n            });\\n        },\\n        stop: function () {\\n            subscribers.forEach(function (visualElement) {\\n                stopAnimation(visualElement);\\n            });\\n        },\\n        mount: function () {\\n            hasMounted = true;\\n            pendingAnimations.forEach(function (_a) {\\n                var animation = _a.animation, resolve = _a.resolve;\\n                controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\\n            });\\n            return function () {\\n                hasMounted = false;\\n                controls.stop();\\n            };\\n        },\\n    };\\n    return controls;\\n}\\n\\n/**\\n * Creates `AnimationControls`, which can be used to manually start, stop\\n * and sequence animations on one or more components.\\n *\\n * The returned `AnimationControls` should be passed to the `animate` property\\n * of the components you want to animate.\\n *\\n * These components can then be animated with the `start` method.\\n *\\n * @library\\n *\\n * ```jsx\\n * import * as React from 'react'\\n * import { Frame, useAnimation } from 'framer'\\n *\\n * export function MyComponent(props) {\\n *    const controls = useAnimation()\\n *\\n *    controls.start({\\n *        x: 100,\\n *        transition: { duration: 0.5 },\\n *    })\\n *\\n *    return <Frame animate={controls} />\\n * }\\n * ```\\n *\\n * @motion\\n *\\n * ```jsx\\n * import * as React from 'react'\\n * import { motion, useAnimation } from 'framer-motion'\\n *\\n * export function MyComponent(props) {\\n *    const controls = useAnimation()\\n *\\n *    controls.start({\\n *        x: 100,\\n *        transition: { duration: 0.5 },\\n *    })\\n *\\n *    return <motion.div animate={controls} />\\n * }\\n * ```\\n *\\n * @returns Animation controller with `start` and `stop` methods\\n *\\n * @public\\n */\\nfunction useAnimation() {\\n    var controls = useConstant(animationControls);\\n    React.useEffect(controls.mount, []);\\n    return controls;\\n}\\n\\n/**\\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\\n *\\n * @library\\n *\\n * ```jsx\\n * import * as React from \\\"react\\\"\\n * import { Frame, useCycle } from \\\"framer\\\"\\n *\\n * export function MyComponent() {\\n *   const [x, cycleX] = useCycle(0, 50, 100)\\n *\\n *   return (\\n *     <Frame\\n *       animate={{ x: x }}\\n *       onTap={() => cycleX()}\\n *      />\\n *    )\\n * }\\n * ```\\n *\\n * @motion\\n *\\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\\n *\\n * ```jsx\\n * import * as React from \\\"react\\\"\\n * import { motion, useCycle } from \\\"framer-motion\\\"\\n *\\n * export const MyComponent = () => {\\n *   const [x, cycleX] = useCycle(0, 50, 100)\\n *\\n *   return (\\n *     <motion.div\\n *       animate={{ x: x }}\\n *       onTap={() => cycleX()}\\n *      />\\n *    )\\n * }\\n * ```\\n *\\n * @param items - items to cycle through\\n * @returns [currentState, cycleState]\\n *\\n * @public\\n */\\nfunction useCycle() {\\n    var items = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        items[_i] = arguments[_i];\\n    }\\n    var index = React.useRef(0);\\n    var _a = tslib.__read(React.useState(items[index.current]), 2), item = _a[0], setItem = _a[1];\\n    return [\\n        item,\\n        function (next) {\\n            index.current =\\n                typeof next !== \\\"number\\\"\\n                    ? popmotion.wrap(0, items.length, index.current + 1)\\n                    : next;\\n            setItem(items[index.current]);\\n        },\\n    ];\\n}\\n\\n/**\\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\\n *\\n * @library\\n *\\n * ```jsx\\n * const dragControls = useDragControls()\\n *\\n * function startDrag(event) {\\n *   dragControls.start(event, { snapToCursor: true })\\n * }\\n *\\n * return (\\n *   <>\\n *     <Frame onTapStart={startDrag} />\\n *     <Frame drag=\\\"x\\\" dragControls={dragControls} />\\n *   </>\\n * )\\n * ```\\n *\\n * @motion\\n *\\n * ```jsx\\n * const dragControls = useDragControls()\\n *\\n * function startDrag(event) {\\n *   dragControls.start(event, { snapToCursor: true })\\n * }\\n *\\n * return (\\n *   <>\\n *     <div onPointerDown={startDrag} />\\n *     <motion.div drag=\\\"x\\\" dragControls={dragControls} />\\n *   </>\\n * )\\n * ```\\n *\\n * @public\\n */\\nvar DragControls = /** @class */ (function () {\\n    function DragControls() {\\n        this.componentControls = new Set();\\n    }\\n    /**\\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\\n     *\\n     * @internal\\n     */\\n    DragControls.prototype.subscribe = function (controls) {\\n        var _this = this;\\n        this.componentControls.add(controls);\\n        return function () { return _this.componentControls.delete(controls); };\\n    };\\n    /**\\n     * Start a drag gesture on every `motion` component that has this set of drag controls\\n     * passed into it via the `dragControls` prop.\\n     *\\n     * ```jsx\\n     * dragControls.start(e, {\\n     *   snapToCursor: true\\n     * })\\n     * ```\\n     *\\n     * @param event - PointerEvent\\n     * @param options - Options\\n     *\\n     * @public\\n     */\\n    DragControls.prototype.start = function (event, options) {\\n        this.componentControls.forEach(function (controls) {\\n            controls.start(event.nativeEvent || event, options);\\n        });\\n    };\\n    DragControls.prototype.updateConstraints = function (flush) {\\n        if (flush === void 0) { flush = true; }\\n        this.componentControls.forEach(function (controls) {\\n            controls.updateConstraints();\\n        });\\n        flush && flushLayout();\\n    };\\n    return DragControls;\\n}());\\nvar createDragControls = function () { return new DragControls(); };\\n/**\\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\\n * might want to initiate that dragging from a different component than the draggable one.\\n *\\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\\n * the draggable component's `dragControls` prop. It exposes a `start` method\\n * that can start dragging from pointer events on other components.\\n *\\n * @library\\n *\\n * ```jsx\\n * const dragControls = useDragControls()\\n *\\n * function startDrag(event) {\\n *   dragControls.start(event, { snapToCursor: true })\\n * }\\n *\\n * return (\\n *   <>\\n *     <Frame onTapStart={startDrag} />\\n *     <Frame drag=\\\"x\\\" dragControls={dragControls} />\\n *   </>\\n * )\\n * ```\\n *\\n * @motion\\n *\\n * ```jsx\\n * const dragControls = useDragControls()\\n *\\n * function startDrag(event) {\\n *   dragControls.start(event, { snapToCursor: true })\\n * }\\n *\\n * return (\\n *   <>\\n *     <div onPointerDown={startDrag} />\\n *     <motion.div drag=\\\"x\\\" dragControls={dragControls} />\\n *   </>\\n * )\\n * ```\\n *\\n * @public\\n */\\nfunction useDragControls() {\\n    return useConstant(createDragControls);\\n}\\n\\nvar createObject = function () { return ({}); };\\nvar stateVisualElement = visualElement({\\n    build: function () { },\\n    measureViewportBox: axisBox,\\n    resetTransform: function () { },\\n    restoreTransform: function () { },\\n    removeValueFromRenderState: function () { },\\n    render: function () { },\\n    scrapeMotionValuesFromProps: createObject,\\n    readValueFromInstance: function (_state, key, options) {\\n        return options.initialState[key] || 0;\\n    },\\n    makeTargetAnimatable: function (element, _a) {\\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\\\"transition\\\", \\\"transitionEnd\\\"]);\\n        var origin = getOrigin(target, transition || {}, element);\\n        checkTargetForNewValues(element, target, origin);\\n        return tslib.__assign({ transition: transition, transitionEnd: transitionEnd }, target);\\n    },\\n});\\nvar useVisualState = makeUseVisualState({\\n    scrapeMotionValuesFromProps: createObject,\\n    createRenderState: createObject,\\n});\\n/**\\n * This is not an officially supported API and may be removed\\n * on any version.\\n * @internal\\n */\\nfunction useAnimatedState(initialState) {\\n    var _a = tslib.__read(React.useState(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\\n    var visualState = useVisualState({}, false);\\n    var element = useConstant(function () {\\n        return stateVisualElement({ props: {}, visualState: visualState }, { initialState: initialState });\\n    });\\n    React.useEffect(function () {\\n        element.mount({});\\n        return element.unmount();\\n    }, []);\\n    React.useEffect(function () {\\n        element.setProps({\\n            onUpdate: function (v) { return setAnimationState(tslib.__assign({}, v)); },\\n        });\\n    });\\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\\n        return animateVisualElement(element, animationDefinition);\\n    }; });\\n    return [animationState, startAnimation];\\n}\\n\\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\\n// to simply hide content at unreasonable scales.\\nvar maxScale = 100000;\\nvar invertScale = function (scale) {\\n    return scale > 0.001 ? 1 / scale : maxScale;\\n};\\nvar hasWarned = false;\\n/**\\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\\n * of their respective parent scales.\\n *\\n * This is useful for undoing the distortion of content when scaling a parent component.\\n *\\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\\n * of those instead.\\n *\\n * @motion\\n *\\n * ```jsx\\n * const MyComponent = () => {\\n *   const { scaleX, scaleY } = useInvertedScale()\\n *   return <motion.div style={{ scaleX, scaleY }} />\\n * }\\n * ```\\n *\\n * @library\\n *\\n * ```jsx\\n * function MyComponent() {\\n *   const { scaleX, scaleY } = useInvertedScale()\\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\\n * }\\n * ```\\n *\\n * @deprecated\\n * @internal\\n */\\nfunction useInvertedScale(scale) {\\n    var parentScaleX = useMotionValue(1);\\n    var parentScaleY = useMotionValue(1);\\n    var visualElement = useVisualElementContext();\\n    heyListen.invariant(!!(scale || visualElement), \\\"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\\\");\\n    heyListen.warning(hasWarned, \\\"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\\\");\\n    hasWarned = true;\\n    if (scale) {\\n        parentScaleX = scale.scaleX || parentScaleX;\\n        parentScaleY = scale.scaleY || parentScaleY;\\n    }\\n    else if (visualElement) {\\n        parentScaleX = visualElement.getValue(\\\"scaleX\\\", 1);\\n        parentScaleY = visualElement.getValue(\\\"scaleY\\\", 1);\\n    }\\n    var scaleX = useTransform(parentScaleX, invertScale);\\n    var scaleY = useTransform(parentScaleY, invertScale);\\n    return { scaleX: scaleX, scaleY: scaleY };\\n}\\n\\nexports.AnimatePresence = AnimatePresence;\\nexports.AnimateSharedLayout = AnimateSharedLayout;\\nexports.DragControls = DragControls;\\nexports.FlatTree = FlatTree;\\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\\nexports.LayoutGroupContext = LayoutGroupContext;\\nexports.LazyMotion = LazyMotion;\\nexports.MotionConfig = MotionConfig;\\nexports.MotionConfigContext = MotionConfigContext;\\nexports.MotionValue = MotionValue;\\nexports.PresenceContext = PresenceContext;\\nexports.SharedLayoutContext = SharedLayoutContext;\\nexports.addScaleCorrection = addScaleCorrection;\\nexports.animate = animate;\\nexports.animateVisualElement = animateVisualElement;\\nexports.animationControls = animationControls;\\nexports.batchLayout = batchLayout;\\nexports.createBatcher = createBatcher;\\nexports.createCrossfader = createCrossfader;\\nexports.createDomMotionComponent = createDomMotionComponent;\\nexports.createMotionComponent = createMotionComponent;\\nexports.domAnimation = domAnimation;\\nexports.domMax = domMax;\\nexports.flushLayout = flushLayout;\\nexports.isValidMotionProp = isValidMotionProp;\\nexports.m = m;\\nexports.motion = motion;\\nexports.motionValue = motionValue;\\nexports.resolveMotionValue = resolveMotionValue;\\nexports.snapshotViewportBox = snapshotViewportBox;\\nexports.transform = transform;\\nexports.useAnimation = useAnimation;\\nexports.useCycle = useCycle;\\nexports.useDeprecatedAnimatedState = useAnimatedState;\\nexports.useDeprecatedInvertedScale = useInvertedScale;\\nexports.useDomEvent = useDomEvent;\\nexports.useDragControls = useDragControls;\\nexports.useElementScroll = useElementScroll;\\nexports.useIsPresent = useIsPresent;\\nexports.useMotionTemplate = useMotionTemplate;\\nexports.useMotionValue = useMotionValue;\\nexports.usePresence = usePresence;\\nexports.useReducedMotion = useReducedMotion;\\nexports.useSpring = useSpring;\\nexports.useTransform = useTransform;\\nexports.useVelocity = useVelocity;\\nexports.useViewportScroll = useViewportScroll;\\nexports.visualElement = visualElement;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopDefaultLegacy\",\"e\",\"loadFeatures\",\"features\",\"key\",\"Component\",\"featureDefinitions\",\"useConstant\",\"init\",\"ref\",\"React\",\"useRef\",\"current\",\"usePresence\",\"context\",\"useContext\",\"PresenceContext\",\"isPresent\",\"onExitComplete\",\"register\",\"id\",\"incrementId\",\"useEffect\",\"safeToRemove\",\"useLayoutId\",\"_a\",\"layoutId\",\"layoutGroupId\",\"LayoutGroupContext\",\"undefined\",\"useVisualElement\",\"visualState\",\"props\",\"createVisualElement\",\"config\",\"MotionConfigContext\",\"lazyContext\",\"LazyContext\",\"parent\",\"MotionContext\",\"visualElement\",\"presenceContext\",\"visualElementRef\",\"renderer\",\"tslib\",\"__assign\",\"presenceId\",\"blockInitialAnimation\",\"initial\",\"useIsomorphicLayoutEffect\",\"setProps\",\"isPresenceRoot\",\"syncRender\",\"animationState\",\"animateChanges\",\"notifyUnmount\",\"isRefObject\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"useMotionRef\",\"externalRef\",\"useCallback\",\"instance\",\"mount\",\"unmount\",\"isVariantLabel\",\"v\",\"Array\",\"isArray\",\"getCurrent\",\"forEachValue\",\"value\",\"get\",\"getVelocity$1\",\"velocity\",\"getVelocity\",\"resolveVariantFromProps\",\"definition\",\"custom\",\"currentValues\",\"currentVelocity\",\"variants\",\"resolveVariant\",\"getProps\",\"checkIfControllingVariants\",\"animate\",\"start\",\"whileHover\",\"whileDrag\",\"whileTap\",\"whileFocus\",\"exit\",\"checkIfVariantNode\",\"getCurrentTreeVariants\",\"inherit\",\"useCreateMotionContext\",\"isStatic\",\"useMemo\",\"variantLabelsAsDependency\",\"prop\",\"join\",\"createMotionComponent\",\"preloadedFeatures\",\"useRender\",\"useVisualState\",\"forwardRef\",\"MotionComponent\",\"isBrowser\",\"strict\",\"heyListen\",\"invariant\",\"i\",\"numFeatures\",\"name_1\",\"featureNames\",\"isEnabled\",\"push\",\"React__namespace\",\"createElement\",\"Fragment\",\"Provider\",\"createMotionProxy\",\"createConfig\",\"customMotionComponentConfig\",\"componentCache\",\"Map\",\"Proxy\",\"_target\",\"has\",\"set\",\"isSVGComponent\",\"includes\",\"lowercaseSVGElements\",\"indexOf\",\"test\",\"addScaleCorrection\",\"correctors\",\"valueScaleCorrection\",\"sortTransformProps\",\"a\",\"b\",\"transformProps\",\"isForcedMotionValue\",\"layout\",\"transformPropSet\",\"transformOriginProps\",\"buildHTMLStyles\",\"state\",\"latestValues\",\"projection\",\"layoutState\",\"options\",\"transformTemplate\",\"buildProjectionTransform\",\"buildProjectionTransformOrigin\",\"style\",\"vars\",\"transform\",\"transformKeys\",\"transformOrigin\",\"length\",\"hasTransform\",\"hasTransformOrigin\",\"transformIsNone\",\"startsWith\",\"valueType\",\"numberValueTypes\",\"valueAsType\",\"default\",\"isHydrated\",\"correctedValue\",\"applyTo\",\"process\",\"num\",\"deltaFinal\",\"treeScale\",\"_c\",\"enableHardwareAcceleration\",\"_d\",\"allowTransformNone\",\"transformString\",\"sort\",\"transformHasZ\",\"numTransformKeys\",\"translateAlias\",\"trim\",\"transformIsDefault\",\"_b\",\"originX\",\"originY\",\"originZ\",\"copyRawValuesOnly\",\"target\",\"source\",\"isMotionValue\",\"useInitialMotionValues\",\"createHtmlRenderState\",\"useHTMLProps\",\"htmlProps\",\"assign\",\"transformValues\",\"drag\",\"draggable\",\"userSelect\",\"WebkitUserSelect\",\"WebkitTouchCallout\",\"touchAction\",\"isValidMotionProp\",\"validMotionProps\",\"calcOrigin$1\",\"origin\",\"offset\",\"size\",\"styleValueTypes\",\"px\",\"buildSVGAttrs\",\"attrX\",\"attrY\",\"pathLength\",\"pathSpacing\",\"pathOffset\",\"latest\",\"__rest\",\"attrs\",\"dimensions\",\"totalPathLength\",\"pxOriginX\",\"x\",\"width\",\"pxOriginY\",\"y\",\"height\",\"spacing\",\"useDashCase\",\"keys\",\"dashKeys\",\"camelKeys\",\"progress\",\"array\",\"useSVGProps\",\"visualProps\",\"createSvgRenderState\",\"rawStyles\",\"createUseRender\",\"forwardMotionProps\",\"useVisualProps\",\"filteredProps\",\"shouldForward\",\"isDom\",\"elementProps\",\"renderHTML\",\"element\",\"setProperty\",\"renderSVG\",\"renderState\",\"setAttribute\",\"camelCaseAttributes\",\"replace\",\"CAMEL_CASE_PATTERN\",\"REPLACE_TEMPLATE\",\"toLowerCase\",\"scrapeMotionValuesFromProps$1\",\"newValues\",\"scrapeMotionValuesFromProps\",\"targetKey\",\"toUpperCase\",\"isAnimationControls\",\"resolveMotionValue\",\"unwrappedValue\",\"mix\",\"toValue\",\"makeState\",\"createRenderState\",\"onMount\",\"makeLatestValues\",\"state.mount\",\"scrapeMotionValues\",\"values\",\"motionValues\",\"isControllingVariants\",\"isVariantNode\",\"variantToSet\",\"list\",\"forEach\",\"resolved\",\"transitionEnd\",\"transition\",\"createDomMotionConfig\",\"baseConfig\",\"svgMotionConfig\",\"htmlMotionConfig\",\"addDomEvent\",\"eventName\",\"handler\",\"addEventListener\",\"removeEventListener\",\"useDomEvent\",\"isMouseEvent\",\"event\",\"PointerEvent\",\"pointerType\",\"MouseEvent\",\"filterPrimaryPointer\",\"eventHandler\",\"button\",\"extractEventInfo\",\"pointType\",\"touches\",\"point\",\"changedTouches\",\"defaultPagePoint\",\"getPointerEventName\",\"name\",\"window\",\"onpointerdown\",\"ontouchstart\",\"touchEventNames\",\"onmousedown\",\"mouseEventNames\",\"addPointerEvent\",\"wrapHandler\",\"usePointerEvent\",\"createLock\",\"lock\",\"openLock\",\"getGlobalLock\",\"globalVerticalLock\",\"globalHorizontalLock\",\"openHorizontal_1\",\"openVertical_1\",\"isDragActive\",\"openGestureLock\",\"createHoverEvent\",\"isActive\",\"callback\",\"info\",\"setActive\",\"AnimationType\",\"Hover\",\"useUnmountEffect\",\"shallowCompare\",\"next\",\"prev\",\"prevLength\",\"getAnimatableNone\",\"defaultValueType\",\"defaultValueTypes\",\"filter\",\"complex\",\"convertTransitionToAnimationOptions\",\"ease\",\"times\",\"yoyo\",\"flip\",\"loop\",\"duration\",\"repeatDelay\",\"map\",\"easingDefinitionToFunction\",\"type\",\"warning\",\"legacyRepeatWarning\",\"repeatType\",\"repeat\",\"getDelayFromTransition\",\"getValueTransition\",\"delay\",\"getPopmotionAnimationOptions\",\"to\",\"__spreadArray\",\"__read\",\"from\",\"when\",\"delayChildren\",\"staggerChildren\",\"staggerDirection\",\"getDefaultTransition\",\"getAnimation\",\"onComplete\",\"onUpdate\",\"valueTransition\",\"popmotion\",\"inertia\",\"stop\",\"isTargetAnimatable\",\"isAnimatable\",\"isZero\",\"isOriginAnimatable\",\"parseFloat\",\"startAnimation\",\"delayTimer\",\"controls\",\"animation\",\"setTimeout\",\"clearTimeout\",\"addUniqueItem\",\"arr\",\"item\",\"motionValue\",\"MotionValue\",\"setTarget\",\"makeTargetAnimatable\",\"hasValue\",\"getValue\",\"addValue\",\"setVariants\",\"variantLabels\",\"reversedLabels\",\"reverse\",\"variant\",\"getVariant\",\"variantChildren\",\"child\",\"checkTargetForNewValues\",\"newValueKeys\",\"numNewValues\",\"targetValue\",\"readValue\",\"valueTypes\",\"find\",\"testValueType\",\"setBaseTarget\",\"getOrigin\",\"animateVisualElement\",\"notifyAnimationStart\",\"animations\",\"animateVariant\",\"Promise\",\"all\",\"resolvedDefinition\",\"animateTarget\",\"then\",\"notifyAnimationComplete\",\"transitionOverride\",\"resolve\",\"getChildAnimations\",\"forwardDelay\",\"animateChildren\",\"last\",\"first\",\"_e\",\"_f\",\"animationTypeState\",\"getState\",\"valueTarget\",\"shouldBlockAnimation\",\"maxStaggerDuration\",\"generateStaggerDuration\",\"sortByTreeOrder\",\"stopAnimation\",\"sortNodePosition\",\"needsAnimating\",\"shouldBlock\",\"protectedKeys\",\"animateList\",\"createAnimationState\",\"changedActiveType\",\"getVariantContext\",\"removedKeys\",\"Set\",\"encounteredKeys\",\"removedVariantIndex\",\"Infinity\",\"_loop_1\",\"reversePriorityOrder\",\"typeState\",\"propIsVariant\",\"activeDelta\",\"isInherited\",\"isInitialRender\",\"manuallyAnimateOnMount\",\"prevProp\",\"shouldAnimateType\",\"variantsHaveChanged\",\"definitionList\",\"resolvedValues\",\"reduce\",\"buildResolvedTypeValues\",\"prevResolvedValues\",\"allKeys\",\"markToAnimate\",\"delete\",\"add\",\"apply\",\"numAnimationTypes\",\"allAnimatedKeys\",\"fallbackAnimation_1\",\"fallbackTarget\",\"getBaseTarget\",\"shouldAnimate\",\"createState\",\"acc\",\"isAnimated\",\"setAnimateFunction\",\"makeAnimator\",\"createTypeState\",\"Animate\",\"Tap\",\"Drag\",\"Focus\",\"Exit\",\"transformPoint\",\"transformPagePoint\",\"subtractPoint\",\"getPanInfo\",\"history\",\"delta\",\"timeDelta\",\"timestampedPoint\",\"lastPoint\",\"timestamp\",\"time\",\"noop\",\"any\",\"convertBoundingBoxToAxisBox\",\"min\",\"left\",\"max\",\"right\",\"top\",\"bottom\",\"axisBox\",\"copyAxisBox\",\"box\",\"eachAxis\",\"isNear\",\"maxDistance\",\"distance\",\"updateAxisDelta\",\"originPoint\",\"scale\",\"translate\",\"updateBoxDelta\",\"defaultOrigin\",\"applyConstraints\",\"elastic\",\"Math\",\"calcRelativeAxisConstraints\",\"axis\",\"calcRelativeConstraints\",\"layoutBox\",\"calcViewportAxisConstraints\",\"layoutAxis\",\"constraintsAxis\",\"resolveDragElastic\",\"dragElastic\",\"defaultElastic\",\"resolvePointElastic\",\"minLabel\",\"maxLabel\",\"label\",\"getBoundingBox\",\"getBoundingClientRect\",\"topLeft\",\"bottomRight\",\"collectProjectingAncestors\",\"ancestors\",\"shouldResetTransform\",\"collectProjectingChildren\",\"children\",\"addChild\",\"compareByDepth\",\"updateLayoutMeasurement\",\"getLayoutState\",\"notifyBeforeLayoutMeasure\",\"measureViewportBox\",\"layoutCorrected\",\"notifyLayoutMeasure\",\"prevViewportBox\",\"sync__default\",\"update\",\"rebaseProjectionTarget\",\"snapshotViewportBox\",\"calcRelativeOffsetAxis\",\"calcRelativeOffset\",\"checkIfParentHasChanged\",\"prevId\",\"getLayoutId\",\"nextId\",\"isDraggable\",\"_dragX\",\"applyPointDelta\",\"boxScale\",\"applyAxisDelta\",\"applyAxisTransforms\",\"final\",\"transforms\",\"scaleKey\",\"originKey\",\"axisOrigin\",\"applyBoxTransforms\",\"finalBox\",\"xKeys\",\"yKeys\",\"removePointDelta\",\"removeAxisTransforms\",\"removeBoxTransforms\",\"convertToRelativeProjection\",\"isLayoutDrag\",\"projectionParent\",\"getProjectionParent\",\"getLatestValues\",\"setProjectionTargetAxis\",\"batchLayout\",\"unresolvedJobs\",\"flushLayout\",\"pointer\",\"reads\",\"writes\",\"setRead\",\"job\",\"setWrite\",\"clear\",\"numStacks\",\"executeJob\",\"shouldDrag\",\"direction\",\"currentDirection\",\"isCSSVariable\",\"parseCSSVariable\",\"match\",\"cssVariableRegex\",\"exec\",\"token\",\"fallback\",\"getVariableValue\",\"depth\",\"maxDepth\",\"getComputedStyle\",\"getPropertyValue\",\"resolveCSSVariables\",\"getInstance\",\"HTMLElement\",\"hasMoved\",\"isZeroBox\",\"axisIsEqual\",\"zeroAxis\",\"createBatcher\",\"queue\",\"flush\",\"defaultHandler\",\"layoutReady\",\"read\",\"write\",\"order\",\"allElements\",\"resetTransform\",\"restoreTransform\",\"presence\",\"Presence\",\"Present\",\"sync\",\"flushSync\",\"preRender\",\"render\",\"postRender\",\"assignProjectionToSnapshot\",\"createLayoutState\",\"zeroDelta\",\"deltaTransform\",\"buildLayoutProjectionTransform\",\"latestTransform\",\"rotate\",\"rotateX\",\"rotateY\",\"identityProjection\",\"buildLayoutProjectionTransformOrigin\",\"createLifecycles\",\"managers\",\"names\",\"SubscriptionManager\",\"propSubscriptions\",\"lifecycles\",\"clearAllListeners\",\"manager\",\"updatePropListeners\",\"on\",\"propListener\",\"args\",\"_i\",\"arguments\",\"notify\",\"setCurrentViewportBox\",\"relativeOffset\",\"fireResolveRelativeTargetBox\",\"resolveRelativeTargetBox\",\"fireUpdateLayoutProjection\",\"updateLayoutProjection\",\"removeNonTranslationalTransform\",\"removedTransforms\",\"nonTranslationalTransformKeys\",\"useForceUpdate\",\"unloadingRef\",\"useState\",\"forcedRenderCount\",\"setForcedRenderCount\",\"getPresenceId\",\"newChildrenMap\",\"getChildKey\",\"updateChildLookup\",\"allChildren\",\"seenChildren\",\"console\",\"warn\",\"onlyElements\",\"filtered\",\"Children\",\"isValidElement\",\"createCrossfader\",\"startCrossfadeAnimation\",\"lead\",\"follow\",\"finalCrossfadeFrame\",\"hasUpdated\",\"scheduleRender\",\"getFrameData\",\"crossfadeOpacity\",\"preserveFollowOpacity\",\"prevOptions\",\"leadState\",\"followState\",\"prevUpdate\",\"fromLead\",\"toLead\",\"initialProgress\",\"prevValues\",\"reset\",\"getCrossfadeState\",\"latestLeadValues\",\"latestFollowValues\",\"p\",\"leadTargetOpacity\",\"opacity\",\"followTargetOpacity\",\"isVisible\",\"easeCrossfadeIn\",\"easeCrossfadeOut\",\"numBorders\",\"borderLabel\",\"borders\",\"followRadius\",\"getRadius\",\"leadRadius\",\"radius\",\"hasFollowElement\",\"backgroundColor\",\"mixColor\",\"setOptions\",\"newOptions\",\"compress\",\"easing\",\"radiusName\",\"borderRadius\",\"layoutStack\",\"stack\",\"leadIsExiting\",\"prevState\",\"prevDragCursor\",\"crossfader\",\"needsCrossfadeAnimation\",\"setCrossfader\",\"remove\",\"getLead\",\"updateSnapshot\",\"dragControls\",\"elementDragControls\",\"isDragging\",\"cursorProgress\",\"clearSnapshot\",\"updateLeadAndFollow\",\"Exiting\",\"shouldCrossfade\",\"pointTo\",\"setVisibility\",\"prevParent\",\"Entering\",\"originBox\",\"targetBox\",\"notifyLayoutReady\",\"isLazyBundle\",\"useMotionValue\",\"setLatest_1\",\"onChange\",\"useOnChange\",\"useMultiOnChange\",\"subscriptions\",\"unsubscribe\",\"useCombineMotionValues\",\"combineValues\",\"updateValue\",\"argOffset\",\"useImmediate\",\"inputValue\",\"outputRange\",\"interpolator\",\"interpolate\",\"inputRange\",\"mixer\",\"getMixer\",\"useTransform\",\"input\",\"inputRangeOrTransformer\",\"transformer\",\"useListTransform\",\"numValues\",\"createScrollMotionValues\",\"scrollX\",\"scrollY\",\"scrollXProgress\",\"scrollYProgress\",\"createScrollUpdater\",\"getOffsets\",\"xOffset\",\"yOffset\",\"xMaxOffset\",\"yMaxOffset\",\"getViewportScrollOffsets\",\"pageXOffset\",\"pageYOffset\",\"document\",\"body\",\"clientWidth\",\"innerWidth\",\"clientHeight\",\"innerHeight\",\"initPrefersReducedMotion\",\"prefersReducedMotion\",\"matchMedia\",\"motionMediaQuery_1\",\"setReducedMotionPreferences\",\"matches\",\"addListener\",\"animationControls\",\"hasMounted\",\"pendingAnimations\",\"subscribers\",\"subscribe\",\"animations_1\",\"defineProperty\",\"_interopNamespace\",\"__esModule\",\"n\",\"create\",\"k\",\"d\",\"getOwnPropertyDescriptor\",\"enumerable\",\"freeze\",\"React__default\",\"createDefinition\",\"propNames\",\"some\",\"measureLayout\",\"focus\",\"hover\",\"tap\",\"pan\",\"layoutAnimation\",\"createContext\",\"counter\",\"useLayoutEffect\",\"transformAxes\",\"operationKey\",\"axesKey\",\"z\",\"transformPerspective\",\"int\",\"number\",\"round\",\"borderWidth\",\"borderTopWidth\",\"borderRightWidth\",\"borderBottomWidth\",\"borderLeftWidth\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomRightRadius\",\"borderBottomLeftRadius\",\"maxWidth\",\"maxHeight\",\"padding\",\"paddingTop\",\"paddingRight\",\"paddingBottom\",\"paddingLeft\",\"margin\",\"marginTop\",\"marginRight\",\"marginBottom\",\"marginLeft\",\"degrees\",\"rotateZ\",\"scaleX\",\"scaleY\",\"scaleZ\",\"skew\",\"skewX\",\"skewY\",\"translateX\",\"translateY\",\"translateZ\",\"perspective\",\"alpha\",\"progressPercentage\",\"zIndex\",\"fillOpacity\",\"strokeOpacity\",\"numOctaves\",\"emotionIsPropValid_1\",\"makeUseVisualState\",\"getBBox\",\"tagName\",\"getTotalLength\",\"pageX\",\"pageY\",\"shouldFilterPrimaryPointer\",\"listener\",\"pointerdown\",\"pointermove\",\"pointerup\",\"pointercancel\",\"pointerover\",\"pointerout\",\"pointerenter\",\"pointerleave\",\"isNodeOrChild\",\"parentElement\",\"makeRenderlessComponent\",\"hook\",\"gestureAnimations\",\"useTapGesture\",\"removePointerEndListener\",\"cancelPointerEndListeners\",\"checkPointerEnd\",\"isPressing\",\"onPointerUp\",\"onTap\",\"onTapCancel\",\"onPointerCancel\",\"onPointerDown\",\"pipe\",\"onTapStart\",\"hasPressListeners\",\"useFocusGesture\",\"onFocus\",\"onBlur\",\"useHoverGesture\",\"onHoverStart\",\"onHoverEnd\",\"easingLookup\",\"linear\",\"easeIn\",\"easeInOut\",\"easeOut\",\"circIn\",\"circInOut\",\"circOut\",\"backIn\",\"backInOut\",\"backOut\",\"anticipate\",\"bounceIn\",\"bounceInOut\",\"bounceOut\",\"cubicBezier\",\"x1\",\"y1\",\"x2\",\"y2\",\"underDampedSpring\",\"stiffness\",\"damping\",\"restDelta\",\"restSpeed\",\"criticallyDampedSpring\",\"sqrt\",\"linearTween\",\"keyframes\",\"defaultTransitions\",\"color\",\"valueKey\",\"transitionFactory\",\"outlineColor\",\"fill\",\"stroke\",\"borderColor\",\"borderTopColor\",\"borderRightColor\",\"borderBottomColor\",\"borderLeftColor\",\"WebkitFilter\",\"SubscriptionManager.prototype.add\",\"_this\",\"index\",\"splice\",\"SubscriptionManager.prototype.notify\",\"c\",\"numSubscriptions\",\"getSize\",\"SubscriptionManager.prototype.getSize\",\"SubscriptionManager.prototype.clear\",\"lastUpdated\",\"updateSubscribers\",\"velocityUpdateSubscribers\",\"renderSubscribers\",\"canTrackVelocity\",\"updateAndNotify\",\"this.updateAndNotify\",\"scheduleVelocityCheck\",\"this.scheduleVelocityCheck\",\"velocityCheck\",\"this.velocityCheck\",\"hasAnimated\",\"isNaN\",\"MotionValue.prototype.onChange\",\"subscription\",\"clearListeners\",\"MotionValue.prototype.clearListeners\",\"onRenderRequest\",\"MotionValue.prototype.onRenderRequest\",\"attach\",\"MotionValue.prototype.attach\",\"passiveEffect\",\"MotionValue.prototype.set\",\"MotionValue.prototype.get\",\"getPrevious\",\"MotionValue.prototype.getPrevious\",\"MotionValue.prototype.getVelocity\",\"velocityPerSecond\",\"MotionValue.prototype.start\",\"clearAnimation\",\"MotionValue.prototype.stop\",\"isAnimating\",\"MotionValue.prototype.isAnimating\",\"MotionValue.prototype.clearAnimation\",\"destroy\",\"MotionValue.prototype.destroy\",\"dimensionValueTypes\",\"percent\",\"vw\",\"vh\",\"auto\",\"parse\",\"variantPriorityOrder\",\"PanSession\",\"handlers\",\"lastMoveEventInfo\",\"lastMoveEvent\",\"startEvent\",\"updatePoint\",\"this.updatePoint\",\"isPanStarted\",\"isDistancePastThreshold\",\"onStart\",\"onMove\",\"handlePointerMove\",\"this.handlePointerMove\",\"buttons\",\"handlePointerUp\",\"this.handlePointerUp\",\"end\",\"onEnd\",\"onSessionEnd\",\"panInfo\",\"initialInfo\",\"onSessionStart\",\"removeListeners\",\"updateHandlers\",\"PanSession.prototype.updateHandlers\",\"PanSession.prototype.end\",\"cancelSync\",\"WeakMap\",\"lastPointerEvent\",\"VisualElementDragControls\",\"constraints\",\"hasMutatedConstraints\",\"panSession\",\"openGlobalLock\",\"enableLayoutProjection\",\"VisualElementDragControls.prototype.start\",\"originEvent\",\"snapToCursor\",\"stopMotion\",\"initialPoint\",\"cancelLayout\",\"tree\",\"hasManuallySetCursorOrigin\",\"lockProjectionTarget\",\"getAxisMotionValue\",\"isExternalDrag\",\"scheduleUpdateLayoutProjection\",\"axisValue\",\"resolveDragConstraints\",\"dragPropagation\",\"onDragStart\",\"dragDirectionLock\",\"lockThreshold\",\"abs\",\"onDirectionLock\",\"updateAxis\",\"onDrag\",\"VisualElementDragControls.prototype.resolveDragConstraints\",\"dragConstraints\",\"resolveRefConstraints\",\"relativeConstraints\",\"VisualElementDragControls.prototype.resolveRefConstraints\",\"onMeasureDragConstraints\",\"constraintsElement\",\"constraintsBox\",\"measuredConstraints\",\"userConstraints\",\"cancelDrag\",\"VisualElementDragControls.prototype.cancelDrag\",\"unlockProjectionTarget\",\"VisualElementDragControls.prototype.stop\",\"animateDragEnd\",\"onDragEnd\",\"VisualElementDragControls.prototype.snapToCursor\",\"VisualElementDragControls.prototype.updateAxis\",\"updateAxisMotionValue\",\"updateVisualElementAxis\",\"VisualElementDragControls.prototype.updateAxisMotionValue\",\"nextValue\",\"VisualElementDragControls.prototype.updateVisualElementAxis\",\"axisLayout\",\"axisLength\",\"axisProgress\",\"VisualElementDragControls.prototype.setProps\",\"_g\",\"dragMomentum\",\"remainingProps\",\"VisualElementDragControls.prototype.getAxisMotionValue\",\"dragKey\",\"VisualElementDragControls.prototype.isLayoutDrag\",\"VisualElementDragControls.prototype.isExternalDrag\",\"_dragY\",\"VisualElementDragControls.prototype.animateDragEnd\",\"dragTransition\",\"isRelative\",\"relativeConstraints_1\",\"targetFinal\",\"momentumAnimations\",\"bounceStiffness\",\"bounceDamping\",\"timeConstant\",\"startAxisValueAnimation\",\"startLayoutAnimation\",\"onDragTransitionEnd\",\"VisualElementDragControls.prototype.stopMotion\",\"stopLayoutAnimation\",\"VisualElementDragControls.prototype.startAxisValueAnimation\",\"currentValue\",\"scalePoint\",\"VisualElementDragControls.prototype.scalePoint\",\"boxProgress\",\"sourceLength\",\"targetLength\",\"clamp\",\"updateConstraints\",\"VisualElementDragControls.prototype.updateConstraints\",\"onReady\",\"VisualElementDragControls.prototype.mount\",\"stopPointerListener\",\"dragListener\",\"stopResizeListener\",\"stopLayoutUpdateListener\",\"onLayoutUpdate\",\"usePanGesture\",\"onPan\",\"onPanStart\",\"onPanEnd\",\"onPanSessionStart\",\"hasPanEvents\",\"useDrag\",\"groupDragControls\",\"VisibilityAction\",\"borderCorrectionDefinition\",\"correctBorderRadius\",\"_layoutState\",\"defaultScaleCorrectors\",\"boxShadow\",\"correctBoxShadow\",\"original\",\"containsCSSVariables\",\"cssVariables\",\"varToken\",\"shadow\",\"template\",\"createTransformer\",\"xScale\",\"yScale\",\"averageScale\",\"output\",\"i_1\",\"cssVariable\",\"_super\",\"frameTarget\",\"currentAnimationTarget\",\"stopAxisAnimation\",\"isAnimatingTree\",\"_this.animate\",\"visibilityAction\",\"shouldStackAnimate\",\"prevParentViewportBox\",\"parentLayout\",\"boxHasMoved\",\"isTargetLocked\",\"Show\",\"animateAxis\",\"notifyLayoutAnimationComplete\",\"__extends\",\"componentDidMount\",\"Animate.prototype.componentDidMount\",\"animateMotionValue\",\"unsubLayoutReady\",\"layoutSafeToRemove\",\"visualElement.layoutSafeToRemove\",\"componentWillUnmount\",\"Animate.prototype.componentWillUnmount\",\"Animate.prototype.animateAxis\",\"layoutProgress\",\"getProjectionAnimationProgress\",\"frame\",\"progressTarget\",\"unsubscribeProgress\",\"layoutTransition\",\"defaultLayoutTransition\",\"Animate.prototype.safeToRemove\",\"Animate.prototype.render\",\"SharedLayoutContext\",\"FramerTreeLayoutContext\",\"Measure\",\"Measure.prototype.componentDidMount\",\"syncLayout\",\"framerSyncLayout\",\"forceUpdate\",\"onUnmount\",\"getSnapshotBeforeUpdate\",\"Measure.prototype.getSnapshotBeforeUpdate\",\"syncUpdate\",\"componentDidUpdate\",\"Measure.prototype.componentDidUpdate\",\"Measure.prototype.render\",\"layoutAnimations\",\"MeasureContextProvider\",\"AnimateLayoutContextProvider\",\"zeroLayout\",\"FlatTree\",\"isDirty\",\"FlatTree.prototype.add\",\"FlatTree.prototype.remove\",\"FlatTree.prototype.forEach\",\"treeType\",\"build\",\"renderInstance\",\"readValueFromInstance\",\"removeValueFromRenderState\",\"isProjectionReady\",\"leadProjection\",\"leadLatestValues\",\"triggerBuild\",\"valuesToRender\",\"crossfadedValues\",\"notifyUpdate\",\"updateTreeLayoutProjection\",\"layoutTree\",\"bindToMotionValue\",\"removeOnChange\",\"latestValue\",\"removeOnRenderRequest\",\"valueSubscriptions\",\"unsubscribeFromLeadVisualElement\",\"hasViewportBoxUpdated\",\"prevMotionValues\",\"projectionTargetProgress\",\"baseTarget\",\"removeFromVariantTree\",\"initialMotionValues\",\"path\",\"isMounted\",\"newInstance\",\"addVariantChild\",\"closestVariantNode\",\"getClosestVariantNode\",\"other\",\"getStaticValue\",\"setStaticValue\",\"visibility\",\"canMutate\",\"removeValue\",\"defaultValue\",\"newProps\",\"prevValue\",\"existingValue\",\"startAtParent\",\"context_1\",\"numVariantProps\",\"variantProps\",\"newCrossfader\",\"relativeTarget\",\"withTransform\",\"viewportBox\",\"notifySetAxisTarget\",\"force\",\"shouldRebase\",\"notifyLayoutUpdate\",\"prevTreeScaleX\",\"prevTreeScaleY\",\"prevDeltaTransform\",\"originAxis\",\"treeLength\",\"treePath\",\"node\",\"notifyViewportBoxUpdate\",\"foundParent\",\"ancestor\",\"relativeParent\",\"parentProjection\",\"relative\",\"_layoutResetTransform\",\"newLead\",\"onSetAxisTarget\",\"onLayoutAnimationComplete\",\"positionalKeys\",\"isPositionalKey\",\"isNumOrPxType\",\"BoundingBoxDimension\",\"getTranslateFromMatrix\",\"pos2\",\"pos3\",\"_bbox\",\"matrix3d\",\"matrix\",\"split\",\"positionalValues\",\"convertChangedValueTypes\",\"changedKeys\",\"originBbox\",\"elementComputedStyle\",\"originComputedStyle\",\"display\",\"targetBbox\",\"checkAndConvertChangedValueTypes\",\"removedTransformValues\",\"hasAttemptedToRemoveTransformValues\",\"changedValueTypeKeys\",\"targetPositionalKeys\",\"fromType\",\"numKeyframes\",\"toType\",\"convertedTarget\",\"htmlConfig\",\"domElement\",\"defaultType\",\"computedStyle\",\"compareDocumentPosition\",\"mutableState\",\"parsed\",\"isProjectionTranform\",\"htmlVisualElement\",\"svgVisualElement\",\"getAttribute\",\"_element\",\"createDomVisualElement\",\"featureBundle\",\"motion\",\"m\",\"PresenceChild\",\"presenceAffectsLayout\",\"presenceChildren\",\"childId\",\"allComplete\",\"isComplete\",\"_\",\"AnimateSharedLayout\",\"stacks\",\"updateScheduled\",\"renderScheduled\",\"syncContext\",\"scheduleUpdate\",\"removeChild\",\"AnimateSharedLayout.prototype.componentDidMount\",\"AnimateSharedLayout.prototype.componentDidUpdate\",\"shouldComponentUpdate\",\"AnimateSharedLayout.prototype.shouldComponentUpdate\",\"AnimateSharedLayout.prototype.startLayoutAnimation\",\"updateStacks\",\"getStack\",\"AnimateSharedLayout.prototype.updateStacks\",\"AnimateSharedLayout.prototype.scheduleUpdate\",\"hasRotate\",\"resetValues\",\"AnimateSharedLayout.prototype.addChild\",\"addToStack\",\"AnimateSharedLayout.prototype.removeChild\",\"removeFromStack\",\"AnimateSharedLayout.prototype.addToStack\",\"AnimateSharedLayout.prototype.removeFromStack\",\"AnimateSharedLayout.prototype.getStack\",\"AnimateSharedLayout.prototype.render\",\"contextType\",\"domAnimation\",\"domMax\",\"getElementScrollOffsets\",\"scrollLeft\",\"scrollTop\",\"scrollWidth\",\"offsetWidth\",\"scrollHeight\",\"offsetHeight\",\"viewportScrollValues\",\"hasListeners\",\"DragControls\",\"componentControls\",\"DragControls.prototype.subscribe\",\"DragControls.prototype.start\",\"nativeEvent\",\"DragControls.prototype.updateConstraints\",\"createDragControls\",\"createObject\",\"stateVisualElement\",\"_state\",\"initialState\",\"invertScale\",\"maxScale\",\"hasWarned\",\"AnimatePresence\",\"exitBeforeEnter\",\"forceRender\",\"layoutContext\",\"filteredChildren\",\"presentChildren\",\"exiting\",\"childrenToRender\",\"presentKeys\",\"targetKeys\",\"numPresent\",\"insertionIndex\",\"onExit\",\"removeIndex\",\"findIndex\",\"presentChild\",\"cloneElement\",\"LazyMotion\",\"setIsLoaded\",\"loadedRenderer\",\"loadedFeatures\",\"MotionConfig\",\"transitionDependency\",\"toString\",\"createDomMotionComponent\",\"useAnimation\",\"useCycle\",\"items\",\"setItem\",\"wrap\",\"useDeprecatedAnimatedState\",\"useAnimatedState\",\"setAnimationState\",\"animationDefinition\",\"useDeprecatedInvertedScale\",\"useInvertedScale\",\"parentScaleX\",\"parentScaleY\",\"useDragControls\",\"useElementScroll\",\"updateScrollValues\",\"scrollListener\",\"passive\",\"resizeListener\",\"useIsPresent\",\"useMotionTemplate\",\"fragments\",\"numFragments\",\"buildValue\",\"useReducedMotion\",\"shouldReduceMotion\",\"setShouldReduceMotion\",\"useSpring\",\"activeSpringAnimation\",\"useVelocity\",\"newVelocity\",\"useViewportScroll\"]\n}\n"]